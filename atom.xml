<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ruiming&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ruiming.github.io/"/>
  <updated>2017-01-08T12:40:36.064Z</updated>
  <id>https://ruiming.github.io/</id>
  
  <author>
    <name>Ruiming</name>
    <email>ruiming.zhuang@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2016 总结</title>
    <link href="https://ruiming.github.io/2016/12/28/2016-%E6%80%BB%E7%BB%93/"/>
    <id>https://ruiming.github.io/2016/12/28/2016-总结/</id>
    <published>2016-12-28T07:56:44.000Z</published>
    <updated>2017-01-08T12:40:36.064Z</updated>
    
    <content type="html"><![CDATA[<p>2016 年, 要用一个词来形容我的话, 那可能是”技术宅”. 终日沉迷代码不能自拔, 不过正因如此, 技术上成长特别快. 马上要 2017 年, 稍微总结下自己即将过去的 2016 年吧~</p>
<h2 id="技术篇"><a href="#技术篇" class="headerlink" title="技术篇"></a>技术篇</h2><p>2016 年, 学习使用了非常多的东西, 包括但不限于:</p>
<p>AngularJS, React, Redux, Vue2, Vuex, Underscore, Electron, Koa2, PEG.js, D3, jQuery, ESLint, Swig, Mongoose, Sass, PostCSS, Gulp, Bower, Webpack, NPM, Git, PHP, Laravel, Vagrant, Bootstrap, Python, BeautifulSoap.</p>
<p>有的技术是花了很多时间, 例如 AngularJS 几乎做了一整年项目, Vue2 则是目前主要使用的前端框架, Koa2 是目前主要使用的后端框架. 而有些则是做一下小应用, 例如 React 和 Redux 结合这做了一个问卷设计页面, PEG.js 写了一个 XML 解析器, Python 和 BeautifulSoap 撸爬虫. 另有一些其实都快忘了, PHP 和 Laravel 主要是去年年底和年初在搞, 自从把精力放在前端之后就再也没用, 大概已经忘光了.</p>
<h2 id="项目篇"><a href="#项目篇" class="headerlink" title="项目篇"></a>项目篇</h2><p>2016年, 做了很多项目</p>
<ul>
<li>使用 PHP 和 laravel 自己搭建了一个博客框架</li>
<li>使用 Python 写了豆瓣爬虫</li>
<li>使用 AngularJS 写了一个书籍推荐和购买平台</li>
<li>使用 jQuery 写了一个飞机大战游戏</li>
<li>使用 AngularJS 和 ELectron 写了一个类似 Windows 资源管理器的软件</li>
<li>使用 AngularJS 和 Electron 写了一个磁盘分析软件</li>
<li>使用 React 和 Redux 写了一个问卷设计小应用</li>
<li>发布了 node-wmic 模块</li>
<li>使用 PEG.js 写了一个 XML 解析器</li>
<li>使用 Vue2, AngularJS, Koa2 写了一个 RSS 订阅器</li>
<li>使用 Node 写了一个静态博客框架</li>
<li>使用 JAVA 写了一个 YACC</li>
</ul>
<a id="more"></a>
<h2 id="Github-篇"><a href="#Github-篇" class="headerlink" title="Github 篇"></a>Github 篇</h2><p>2016 年泡了很久的 Github. 目前在 Github 有 20 个 Repo (含私人), 提价了 1145 次 Commit. 参与了三个开源项目. 参与了多个项目 issue 的讨论. 获得两次 Pull Request. 得到 13 个关注. 项目一共获得 32 个 star. 不得不说看到之前绿了一大屏, 都不想停下来. 不过最近由于考试缘故真的不得不停下来.</p>
<img src="/2016/12/28/2016-总结/github.png" alt="github.png" title="">
<h2 id="博客篇"><a href="#博客篇" class="headerlink" title="博客篇"></a>博客篇</h2><p>2016 年 6 月 18 日, 开始使用 Hexo. 至今写了 27 篇原创博客, 一篇翻译. 前期博客主要还是重在 AngularJS 以及 Underscore 上面. 最近的则比较分散, 有 Vue2, 有 Webpack, 有 JS 源码也有 co 源码等等. 自认为有几篇写的还是挺不错的. 虽然博客至今没有任何评论, 这也没办法, 自己也没有去宣传过. 在写博客的过程中我总担心写错了, 被别人看到了误人子弟, 这些博客大多数都是个人在项目中遇到的一些坑或者是一些经验的总结. 在使用 Hexo 之前我也是偶尔写博客, 只不过那些博客质量太低被我丢掉了.</p>
<h2 id="资讯篇"><a href="#资讯篇" class="headerlink" title="资讯篇"></a>资讯篇</h2><p>2016 年开始关注前端和 Node. 在知乎和 Github 关注了很多前端或 Node 的大神, 知乎成了我技术资讯获取的一大重要地盘. 另外, 也从很多网站如淘宝 FED, 百度 FEX, 掘金, 奇舞团等获取前端和 Node 的信息, 为此使用了 RSS 订阅了很多订阅源, 后来甚至自己写了一个订阅器. 此外, 在 StackOverflow 上面解决了很多我在项目中遇到的问题, StackOverflow 有些回答真的是不能不赞了. 同时, 也关注了 Reddit 上面的 JS 等专栏. 前端和 Node 技术迭代快, 变化快, 落后就要滚粗啊, 各方面消息都得跟上才行.</p>
<h2 id="工具篇"><a href="#工具篇" class="headerlink" title="工具篇"></a>工具篇</h2><p>2016 年也搞了很多其他新的东西. 从 5 月开始就使用 ArchLinux 至今, 用了半年 XFCE 现在用 GNOME. 4月也捣鼓了下黑苹果. 另外也学习了下 VIM 的使用, 用 VIM 写了一阵子项目, 不过感觉 VIM 还是不太适合写前端. 在编辑器/IDE方面, 从最开始的 Sublime 到 PHPStorm/PyStorm/WebStorm 到现在的 VSCode. 几乎不再使用 M$ OFFICE, 转而使用 Google Docs. 梯子从香港绕到美国又到日本最后又回来香港折腾了一大遍. 手机从安卓阵营调到了苹果阵营, 再也不关心那些安卓破事.</p>
<h2 id="实习篇"><a href="#实习篇" class="headerlink" title="实习篇"></a>实习篇</h2><p>2016 年 11 月的时候参加了一个 Node 地下铁沙龙. 后来有个人主动加我, 发现他是华工今年毕业的师兄, 现在是一家初创公司的技术总监. 聊得挺好并且刚好我想找下学期的实习, 实习顺利的通过了并且拿到了日薪 300 元的待遇. 这应该是今年一整年我得到的最大的肯定了.</p>
<h2 id="生活篇"><a href="#生活篇" class="headerlink" title="生活篇"></a>生活篇</h2><p>2016 年上半年, 有不少时间花在创行上面, 但下半年退队了之后, 就一直宅宿舍写代码了, 沉迷代码不能自拔. 上个月一个人去红砖厂走了走放松了下, 最近又去做一件很早之前就想做的事情 – 矫牙, 苦逼的我要拔四颗牙… 现在已经戴上牙套了. 医生说要两年左右. 55555… 好像也没什么好说的, 2016 年都变成技术宅了, 生活方面希望明年这时候可以写的很丰富0.0</p>
<h2 id="进行时"><a href="#进行时" class="headerlink" title="进行时"></a>进行时</h2><p>2016 年即将结束, 看似我学习了很多东西, 但是学的越多不会的越多. 前段时间正在看 Angular2, Angular2 这一套绑定了 RxJS 和 TypeScript. 本来学了 Vue2 不想搞 NG2 的, 但后来发现 TS 以及 RxJS 这两套东西真心不错, 于是决定上手 Angular2. 毕竟有 Angular1 的老本 Angular2 入门也会相对容易些吧. 另外, 最近也在实现一个 OJ, 使用了 Docker 技术, 目前已经搞定外部 C++ 代码在 Docker 内的执行. </p>
<h2 id="未来时"><a href="#未来时" class="headerlink" title="未来时"></a>未来时</h2><p>2017 年, 计划时间主要花在实习上面, 业余刷一下 LeetCode 以及了解掌握更多的 Web 相关的知识. 然后多花点时间去吃喝玩乐(实习有钱了嘛). 还有贯彻整个上半年的准备暑期 Google 的实习. 17 年上半年的计划大概就是这样. 下半年的话, 到时候再看吧, 现在还说不准哈哈. </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2016 年, 要用一个词来形容我的话, 那可能是”技术宅”. 终日沉迷代码不能自拔, 不过正因如此, 技术上成长特别快. 马上要 2017 年, 稍微总结下自己即将过去的 2016 年吧~&lt;/p&gt;
&lt;h2 id=&quot;技术篇&quot;&gt;&lt;a href=&quot;#技术篇&quot; class=&quot;headerlink&quot; title=&quot;技术篇&quot;&gt;&lt;/a&gt;技术篇&lt;/h2&gt;&lt;p&gt;2016 年, 学习使用了非常多的东西, 包括但不限于:&lt;/p&gt;
&lt;p&gt;AngularJS, React, Redux, Vue2, Vuex, Underscore, Electron, Koa2, PEG.js, D3, jQuery, ESLint, Swig, Mongoose, Sass, PostCSS, Gulp, Bower, Webpack, NPM, Git, PHP, Laravel, Vagrant, Bootstrap, Python, BeautifulSoap.&lt;/p&gt;
&lt;p&gt;有的技术是花了很多时间, 例如 AngularJS 几乎做了一整年项目, Vue2 则是目前主要使用的前端框架, Koa2 是目前主要使用的后端框架. 而有些则是做一下小应用, 例如 React 和 Redux 结合这做了一个问卷设计页面, PEG.js 写了一个 XML 解析器, Python 和 BeautifulSoap 撸爬虫. 另有一些其实都快忘了, PHP 和 Laravel 主要是去年年底和年初在搞, 自从把精力放在前端之后就再也没用, 大概已经忘光了.&lt;/p&gt;
&lt;h2 id=&quot;项目篇&quot;&gt;&lt;a href=&quot;#项目篇&quot; class=&quot;headerlink&quot; title=&quot;项目篇&quot;&gt;&lt;/a&gt;项目篇&lt;/h2&gt;&lt;p&gt;2016年, 做了很多项目&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 PHP 和 laravel 自己搭建了一个博客框架&lt;/li&gt;
&lt;li&gt;使用 Python 写了豆瓣爬虫&lt;/li&gt;
&lt;li&gt;使用 AngularJS 写了一个书籍推荐和购买平台&lt;/li&gt;
&lt;li&gt;使用 jQuery 写了一个飞机大战游戏&lt;/li&gt;
&lt;li&gt;使用 AngularJS 和 ELectron 写了一个类似 Windows 资源管理器的软件&lt;/li&gt;
&lt;li&gt;使用 AngularJS 和 Electron 写了一个磁盘分析软件&lt;/li&gt;
&lt;li&gt;使用 React 和 Redux 写了一个问卷设计小应用&lt;/li&gt;
&lt;li&gt;发布了 node-wmic 模块&lt;/li&gt;
&lt;li&gt;使用 PEG.js 写了一个 XML 解析器&lt;/li&gt;
&lt;li&gt;使用 Vue2, AngularJS, Koa2 写了一个 RSS 订阅器&lt;/li&gt;
&lt;li&gt;使用 Node 写了一个静态博客框架&lt;/li&gt;
&lt;li&gt;使用 JAVA 写了一个 YACC&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅谈 co 库</title>
    <link href="https://ruiming.github.io/2016/11/30/%E6%B5%85%E8%B0%88-co-%E5%BA%93/"/>
    <id>https://ruiming.github.io/2016/11/30/浅谈-co-库/</id>
    <published>2016-11-29T16:28:08.000Z</published>
    <updated>2016-11-30T06:14:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写一个静态博客框架. 但不同于 hexo 之类的, 框架本身提供了博客书写和管理功能. 后端同样使用了 Koa2 来做, </p>
<p>归功于 Arch, 我已经在使用 Node 7.2 了, 不过好像默认还是不能支持 <code>async</code> 和 <code>await</code> , 经查发现是要输入参数开启的=.=. 不过当时第一时间并没有想说去加参数解决, 而是使用了 <code>co</code> 这个库… 虽然也可以用 <code>babel</code> , 但是通过 <code>babel</code> 运行代码很难调试. </p>
<img src="/2016/11/30/浅谈-co-库/node.png" alt="node.png" title="node.png">
<p><code>co</code> 用起来其实和 <code>async</code> 差不多, <del>甚至一些地方更简洁, 比如他可以 yield 一个 Promise 数组. 而 <code>async</code> 则只能 <code>await</code> 一个 Promise.all. 其实归根就是 <code>co</code> 进行了一个隐性的转换.</del> <code>co</code> 内可以直接 <code>yeild</code> 一个数组或对象, <code>co</code> 会自动把数组或对象里面的所有值尝试转为 Promise 并包装在 Promise.all 中返回. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">yield</span> [promise1, promise2, ..., promisen]</div></pre></td></tr></table></figure>
<p>而 <code>async</code> 要处理多个异步的并行操作, 只能把这些操作手动放入 Promise.all 返回. 即:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">await</span> <span class="built_in">Promise</span>.all([promise1, promise2, ..., promisen])</div></pre></td></tr></table></figure>
<p>草案还有一个 <code>await*</code> , 这个也是最近才注意到的, 使用 <code>await*</code> 就可以这样写了:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">await</span>* [promise1, promise2, ..., promisen]</div></pre></td></tr></table></figure>
<p>然而草案并不推荐 <code>await*</code> , 目前 Node 7.2 也不支持 <code>await*</code> , 不过 babel 支持 ~ </p>
<a id="more"></a>
<p><code>co</code> 的代码其实刚接触异步的时候我就去看了下, 当然当时肯定看不懂. 不过现在回过来看感觉很明了. 其实 <code>co</code> 的实现思路也很简单. <code>co</code> 接收一个 generator, 然后他就可以自动的运行这个 generator 而不需要手动的 <code>yield</code> . </p>
<p><code>co</code> 的实现简要过程:</p>
<ol>
<li>接受一个 generator</li>
<li>generator 封装进 promise</li>
<li>调用该 generator</li>
<li>判断是否可以 next, 如果不可以直接 resolve, 否则下一步</li>
<li>执行 next 操作并取得 next 后的 generator</li>
<li>判断是否已经 done, 如果是则直接 resolve, 否则下一步</li>
<li>递归调用第 2 步</li>
</ol>
<p>参考以上自己可以结合 <a href="https://github.com/tj/co/blob/master/index.js" target="_blank" rel="external">co</a> 源码看下. 看看是不是就这么回事.</p>
<p><code>co</code> 内部有一个方法来对 <code>yield</code> 后面的东西进行处理:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toPromise</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!obj) <span class="keyword">return</span> obj;</div><div class="line">  <span class="keyword">if</span> (isPromise(obj)) <span class="keyword">return</span> obj;</div><div class="line">  <span class="keyword">if</span> (isGeneratorFunction(obj) || isGenerator(obj)) <span class="keyword">return</span> co.call(<span class="keyword">this</span>, obj);</div><div class="line">  <span class="keyword">if</span> (<span class="string">'function'</span> == <span class="keyword">typeof</span> obj) <span class="keyword">return</span> thunkToPromise.call(<span class="keyword">this</span>, obj);</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(obj)) <span class="keyword">return</span> arrayToPromise.call(<span class="keyword">this</span>, obj);</div><div class="line">  <span class="keyword">if</span> (isObject(obj)) <span class="keyword">return</span> objectToPromise.call(<span class="keyword">this</span>, obj);</div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我觉得 <code>yield</code> 可以接一个数组这点很好, 相比起来 <code>async</code> 则要接一个 Promise.all 来处理多个异步的同时运行处理. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayToPromise</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(obj.map(toPromise, <span class="keyword">this</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外, 它也可以接收对象, 这个不是普通的对象, 这个对象里面的值也会执行上面的 toPromise 方法, 然后用 Promise.all 包装后返回.</p>
<p>这样来看其实 <code>co</code> 除了语义没有 <code>async-await</code> 好其实很多方面都更胜一筹. </p>
<p>最后还有一个 <code>co.wrap</code> 方法, 它用来封装一个 generator. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">co.wrap = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</div><div class="line">  createPromise.__generatorFunction__ = fn;</div><div class="line">  <span class="keyword">return</span> createPromise;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createPromise</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> co.call(<span class="keyword">this</span>, fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实就是把 generator 放在一个方法里面, 当这个方法调用时立即通过 <code>co</code> 自动启动该 generator 而已. 把这个方法返回了用于导出或者其他用途都可以咯.</p>
<p>真的短小精悍… 膜拜 TJ 大神… 但, <code>async-await</code> 势不可挡, 该用还是得用 0.0, 打算把 <code>co</code> 全部替换为 <code>async</code> 去了. 不过 <code>co</code> 这个库的思想和实现还是可以好好看一看滴.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在写一个静态博客框架. 但不同于 hexo 之类的, 框架本身提供了博客书写和管理功能. 后端同样使用了 Koa2 来做, &lt;/p&gt;
&lt;p&gt;归功于 Arch, 我已经在使用 Node 7.2 了, 不过好像默认还是不能支持 &lt;code&gt;async&lt;/code&gt; 和 &lt;code&gt;await&lt;/code&gt; , 经查发现是要输入参数开启的=.=. 不过当时第一时间并没有想说去加参数解决, 而是使用了 &lt;code&gt;co&lt;/code&gt; 这个库… 虽然也可以用 &lt;code&gt;babel&lt;/code&gt; , 但是通过 &lt;code&gt;babel&lt;/code&gt; 运行代码很难调试. &lt;/p&gt;
&lt;img src=&quot;/2016/11/30/浅谈-co-库/node.png&quot; alt=&quot;node.png&quot; title=&quot;node.png&quot;&gt;
&lt;p&gt;&lt;code&gt;co&lt;/code&gt; 用起来其实和 &lt;code&gt;async&lt;/code&gt; 差不多, &lt;del&gt;甚至一些地方更简洁, 比如他可以 yield 一个 Promise 数组. 而 &lt;code&gt;async&lt;/code&gt; 则只能 &lt;code&gt;await&lt;/code&gt; 一个 Promise.all. 其实归根就是 &lt;code&gt;co&lt;/code&gt; 进行了一个隐性的转换.&lt;/del&gt; &lt;code&gt;co&lt;/code&gt; 内可以直接 &lt;code&gt;yeild&lt;/code&gt; 一个数组或对象, &lt;code&gt;co&lt;/code&gt; 会自动把数组或对象里面的所有值尝试转为 Promise 并包装在 Promise.all 中返回. &lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; [promise1, promise2, ..., promisen]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而 &lt;code&gt;async&lt;/code&gt; 要处理多个异步的并行操作, 只能把这些操作手动放入 Promise.all 返回. 即:&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;.all([promise1, promise2, ..., promisen])&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;草案还有一个 &lt;code&gt;await*&lt;/code&gt; , 这个也是最近才注意到的, 使用 &lt;code&gt;await*&lt;/code&gt; 就可以这样写了:&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt;* [promise1, promise2, ..., promisen]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然而草案并不推荐 &lt;code&gt;await*&lt;/code&gt; , 目前 Node 7.2 也不支持 &lt;code&gt;await*&lt;/code&gt; , 不过 babel 支持 ~ &lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://ruiming.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="co" scheme="https://ruiming.github.io/tags/co/"/>
    
  </entry>
  
  <entry>
    <title>正确使用 JS 的 sort 方法</title>
    <link href="https://ruiming.github.io/2016/11/21/%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8-JS-%E7%9A%84-sort-%E6%96%B9%E6%B3%95/"/>
    <id>https://ruiming.github.io/2016/11/21/正确使用-JS-的-sort-方法/</id>
    <published>2016-11-21T08:52:15.000Z</published>
    <updated>2016-11-21T09:24:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>sort() 方法对数组的元素做原地的排序, 并返回这个数组. 默认按照字符串的 Unicode 编码排序. sort 排序可能是不稳定的. 但其实 sort 方法可能并没有你想象的那么简单, 不信的话你耐心往下看看.</p>
<h3 id="默认排序"><a href="#默认排序" class="headerlink" title="默认排序"></a>默认排序</h3><p>sort 方法支持传入一个比较函数, 如果不传入则默认按照其字符串的 Unicode 编码排序, 因此默认情况下会出现以下情况.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">42</span>].sort()</div><div class="line"><span class="comment">// [1, 11, 4, 42, 5]</span></div></pre></td></tr></table></figure>
<p>解决方法就是:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">42</span>].sort(<span class="function">(<span class="params">pre, curr</span>) =&gt;</span> pre - curr)</div><div class="line"><span class="comment">// [1, 4, 5, 11, 42]</span></div></pre></td></tr></table></figure>
<p>pre - curr 的值有三种情况</p>
<ul>
<li>小于 0 时, curr 排在 pre 后面</li>
<li>大于 0 时, curr 排在 pre 前面</li>
<li>等于 0 时, curr 和 pre 的位置不变</li>
</ul>
<p>另外, 我们也可以对字符串进行排序:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="string">'d'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>].sort()</div><div class="line"><span class="comment">// [a, b, c, d]</span></div></pre></td></tr></table></figure>
<h3 id="可能-是不稳定"><a href="#可能-是不稳定" class="headerlink" title="可能?是不稳定?"></a>可能?是不稳定?</h3><p>因为 ECMAScript 只是制定了 sort 这个方法, 但并没有给出具体的实现方式以及是否需要稳定的要求, sort 的实现就和其他大多数的方法一样由浏览器自行制定. 不同的浏览器或者同个浏览器不同版本上 sort 方法可能是稳定的, 也可能是不稳定的.</p>
<p>这里结合 V8 源码分析下这个 sort 方法的内部调优过程.</p>
<p>在 V8 中, 会通过以下函数方法进入 <code>innerArraySort</code> 中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArraySort</span>(<span class="params">comparefn</span>) </span>&#123;</div><div class="line">  CHECK_OBJECT_COERCIBLE(<span class="keyword">this</span>, <span class="string">"Array.prototype.sort"</span>);</div><div class="line"></div><div class="line">  <span class="keyword">var</span> array = TO_OBJECT(<span class="keyword">this</span>);</div><div class="line">  <span class="keyword">var</span> length = TO_LENGTH(array.length);</div><div class="line">  <span class="keyword">return</span> InnerArraySort(array, length, comparefn);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>源码有点长, 可以自己看下 <a href="https://github.com/v8/v8/blob/master/src/js/array.js#L710" target="_blank" rel="external">这里</a></p>
<p>注释已经点明了:</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">InnerArraySort</span>(<span class="params">array, length, comparefn</span>) </span>&#123;</div><div class="line">  <span class="comment">// In-place QuickSort algorithm.</span></div><div class="line">  <span class="comment">// For short (length &lt;= 22) arrays, insertion sort is used for efficiency.</span></div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!IS_CALLABLE(comparefn)) &#123;</div><div class="line">    comparefn = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (x === y) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">      <span class="keyword">if</span> (%_IsSmi(x) &amp;&amp; %_IsSmi(y)) &#123;</div><div class="line">        <span class="keyword">return</span> %SmiLexicographicCompare(x, y);</div><div class="line">      &#125;</div><div class="line">      x = TO_STRING(x);</div><div class="line">      y = TO_STRING(y);</div><div class="line">      <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">      <span class="keyword">else</span> <span class="keyword">return</span> x &lt; y ? <span class="number">-1</span> : <span class="number">1</span>;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一行注释表明这是一个原地排序, 第二行注释说明当数组长度小于 22 时(其实应该是 10 ?), 使用插入排序.</p>
<p>再看上面给出的条件语句, 则是判断有没有传入 <code>comparefn</code> , 如果未传入, 则这里会去获取每两个数的字符串的 Unicode 码进行比较, 按照其字符串的 Unicode 编码实现排序.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> QuickSort = <span class="function"><span class="keyword">function</span> <span class="title">QuickSort</span>(<span class="params">a, from, to</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> third_index = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">    <span class="comment">// Insertion sort is faster for short arrays.</span></div><div class="line">    <span class="keyword">if</span> (to - <span class="keyword">from</span> &lt;= <span class="number">10</span>) &#123;</div><div class="line">      InsertionSort(a, <span class="keyword">from</span>, to);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (to - <span class="keyword">from</span> &gt; <span class="number">1000</span>) &#123;</div><div class="line">      third_index = GetThirdIndex(a, <span class="keyword">from</span>, to);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      third_index = <span class="keyword">from</span> + ((to - <span class="keyword">from</span>) &gt;&gt; <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>当数组长度小于等于 10 时, 直接使用插入排序, 该算法算法复杂度为 O(n2) , 明显是不稳定的</p>
</li>
<li><p>当数组长度大于 10 小于等于 1000 时, 获取 <code>third_index</code> 即中位数. 这里的方法有点屌</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">third_index = <span class="keyword">from</span> + ((to - <span class="keyword">from</span>) &gt;&gt; <span class="number">1</span>);</div></pre></td></tr></table></figure>
<p>其实就是 <code>from + ( to - from ) / 2</code> , 以后别用 <code>/2</code> 了, 用 <code>&gt;&gt;1</code> 逼格才高</p>
</li>
<li><p>当数组长度大于 1000 时, 通过 <code>GetThirdIndex</code> 方法获取 <code>third_index</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> GetThirdIndex = <span class="function"><span class="keyword">function</span>(<span class="params">a, from, to</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> t_array = <span class="keyword">new</span> InternalArray();</div><div class="line">  <span class="comment">// Use both 'from' and 'to' to determine the pivot candidates.</span></div><div class="line">  <span class="keyword">var</span> increment = <span class="number">200</span> + ((to - <span class="keyword">from</span>) &amp; <span class="number">15</span>);</div><div class="line">  <span class="keyword">var</span> j = <span class="number">0</span>;</div><div class="line">  <span class="keyword">from</span> += <span class="number">1</span>;</div><div class="line">  to -= <span class="number">1</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="keyword">from</span>; i &lt; to; i += increment) &#123;</div><div class="line">    t_array[j] = [i, a[i]];</div><div class="line">    j++;</div><div class="line">  &#125;</div><div class="line">  t_array.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> comparefn(a[<span class="number">1</span>], b[<span class="number">1</span>]);</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">var</span> third_index = t_array[t_array.length &gt;&gt; <span class="number">1</span>][<span class="number">0</span>];</div><div class="line">  <span class="keyword">return</span> third_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法就要好好琢磨琢磨了.</p>
<p>关于 <code>var increment = 200 + ((to - from) &amp; 15)</code> , 这里拿 <code>to</code> 与 <code>from</code> 之差与 15 (2^4 -1) 相与, 为什么是这样写, 我也不太明白 ╮(╯▽╰)╭ , 但这个很明显就是得到一个划分范围.</p>
<p>然后进行划分, <code>t_array</code> 是一个二维数组, 第一维是下标, 第二维是下标对应的数组 <code>a</code> 的值. 这里根据划分值 <code>increment</code> 得到 <code>t_array</code> 这个数组, 其实这个数组就是 <code>a</code> 的划分, 记录了每个划分的第一个数的下标值和数值. 接着这个 <code>t_array</code> 根据第二维即数值来对划分做排序, 然后取中间的划分的下标值</p>
<p>接着的部分到 <code>partition</code> 前的代码, 其实就是做下图的处理</p>
 <img src="/2016/11/21/正确使用-JS-的-sort-方法/split.png" alt="split.png" title="split.png">
<p>以上其实是一个快速排序的优化算法 – 三数取中( median-of-three )</p>
<blockquote>
<p>正如已知的，快速排序的阿克琉斯之踵在于，最差数组组合情况下会算法退化。</p>
<p>快速排序的算法核心在于选择一个基准 <code>(pivot)</code>，将经过比较交换的数组按基准分解为两个数区进行后续递归。试想如果对一个已经有序的数组，每次选择基准元素时总是选择第一个或者最后一个元素，那么每次都会有一个数区是空的，递归的层数将达到 <code>n</code>，最后导致算法的时间复杂度退化为 <code>O(n²)</code>。因此 <code>pivot</code> 的选择非常重要。</p>
<p>v8采用的是 <code>三数取中(median-of-three)</code> 的优化：除了头尾两个元素再额外选择一个元素参与基准元素的竞争。</p>
<p>第三个元素的选取策略大致为：</p>
<ol>
<li>当数组长度小于等于1000时，选择折半位置的元素作为目标元素。</li>
<li>当数组长度超过1000时，每隔200-215个<em>(非固定，跟着数组长度而变化)</em>左右选择一个元素来先确定一批候选元素。接着在这批候选元素中进行一次排序，将所得的中位值作为目标元素</li>
</ol>
<p>最后取三个元素的中位值作为 <code>pivot</code>。</p>
</blockquote>
</li>
</ul>
<p>其实 Chrome 的快速排序也是饱受争议, 因为在此之前 JavaScript 的 sort 实现都是稳定的, Firefox 中使用的是归并排序, 归并排序是稳定的. 但至今 Chrome 还是坚持不稳定的快速排序算法 O__O “…</p>
<p>后面就是快速排序的算法了. 快速排序大概的步骤就是遍历数组, 将基准值插入到正确的位置中去, 然后以该位置左右划分, 以此递归进行下去.</p>
<h3 id="常见误用"><a href="#常见误用" class="headerlink" title="常见误用"></a>常见误用</h3><p>虽然 Chrome 和 Firefox 的 sort 方法实现不同, 但其实并没有什么影响. 但仍然有不少人会发现在 Chrome 的排序结果是错的, Firefox 则是正常的. 我没有去看 Firefox 的实现, 但是我大概知道为什么他们会出错．</p>
<p>其实大部分人都错在了 Chrome 下的 compareFn 要求返回值有三种情况, 正, 负和0. 而不少人则是返回 true 或 false. 看看下面这段<a href="https://github.com/v8/v8/blob/master/src/js/array.js#L784" target="_blank" rel="external">代码</a>, 这里是快速排序才需要进入的.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> c02 = comparefn(v0, v2);</div><div class="line"><span class="keyword">if</span> (c02 &gt;= <span class="number">0</span>) &#123;</div><div class="line">  <span class="comment">// v2 &lt;= v0 &lt;= v1.</span></div><div class="line">  <span class="keyword">var</span> tmp = v0;</div><div class="line">  v0 = v2;</div><div class="line">  v2 = v1;</div><div class="line">  v1 = tmp;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">// v0 &lt;= v1 &amp;&amp; v0 &lt; v2</span></div><div class="line">  <span class="keyword">var</span> c12 = comparefn(v1, v2);</div><div class="line">  <span class="keyword">if</span> (c12 &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// v0 &lt;= v2 &lt; v1</span></div><div class="line">    <span class="keyword">var</span> tmp = v1;</div><div class="line">    v1 = v2;</div><div class="line">    v2 = tmp;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 JavaScript 中, false &gt;=0 和 true &gt;=0 都是成立的. 既然如此, 那么 c02 这里就永远取第一条了. sort 方法返回值分为三种, 大于0, 小于0, 等于0. 不要再返回 true 或返回 false 了. 之所以你返回 true 或 false 也可以运行起来那只是因为 JavaScript 隐性的类型转换以及运气好, 没碰到快排而已=.=</p>
<p>比如以下代码在 Chrome 中的执行结果, 由于 Node 也是使用 V8, 所以 Node 也会有同样的问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">15</span>, <span class="number">51</span>, <span class="number">24</span>, <span class="number">95</span>, <span class="number">26</span>, <span class="number">88</span>, <span class="number">6</span>, <span class="number">14</span>, <span class="number">18</span>, <span class="number">11</span>]</div><div class="line">a.sort(<span class="function">(<span class="params">pre, curr</span>) =&gt;</span> pre &gt; curr)</div><div class="line"><span class="comment">// [6, 11, 14, 15, 18, 24, 26, 51, 88, 95]</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="number">15</span>, <span class="number">51</span>, <span class="number">24</span>, <span class="number">95</span>, <span class="number">26</span>, <span class="number">88</span>, <span class="number">6</span>, <span class="number">14</span>, <span class="number">18</span>, <span class="number">11</span>, <span class="number">17</span>]</div><div class="line">a.sort(<span class="function">(<span class="params">pre, curr</span>) =&gt;</span> pre &gt; curr)</div><div class="line"><span class="comment">// [88, 15, 11, 14, 6, 17, 18, 24, 26, 51, 95]</span></div></pre></td></tr></table></figure>
<p>现在就可以解释了, 在 Chrome 中, 小于等于 10 的时候是插入排序, 排序正常, 但大于 10 的时候, 是快速排序, 如果函数返回值只有 true 或 false 那么就不正常了. 由于 Firefox 使用归并排序, 所以 Firefox 没有这个问题.</p>
<p>sort 方法还有常见的一个误用就是用于随机排序.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[...].sort(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random())<span class="number">-0.5</span>)</div></pre></td></tr></table></figure>
<p>这并不能做到完全随机, 首先各个浏览器的 sort 方法实现就不同, 并且也不能证明其能进行随机的排序.</p>
<p>真的要进行完全随机的排序的话, 还是得使用洗牌算法, 它是一种等概率随机的 In-place 排列算法. 具体的实现可以自己去网上搜下~</p>
<hr>
<p>参考资料:</p>
<ul>
<li><a href="http://web.jobbole.com/87127/" target="_blank" rel="external">聊聊前端排序的那些事</a></li>
<li><a href="https://github.com/v8/v8/blob/master/src/js/array.js#L710" target="_blank" rel="external">array.js</a></li>
<li><a href="http://stackoverflow.com/questions/3026281/array-sort-sorting-stability-in-different-browsers" target="_blank" rel="external">Array.sort Sorting Stability in Different Browsers</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;sort() 方法对数组的元素做原地的排序, 并返回这个数组. 默认按照字符串的 Unicode 编码排序. sort 排序可能是不稳定的. 但其实 sort 方法可能并没有你想象的那么简单, 不信的话你耐心往下看看.&lt;/p&gt;
&lt;h3 id=&quot;默认排序&quot;&gt;&lt;a href=&quot;#默认排序&quot; class=&quot;headerlink&quot; title=&quot;默认排序&quot;&gt;&lt;/a&gt;默认排序&lt;/h3&gt;&lt;p&gt;sort 方法支持传入一个比较函数, 如果不传入则默认按照其字符串的 Unicode 编码排序, 因此默认情况下会出现以下情况.&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;].sort()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// [1, 11, 4, 42, 5]&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;解决方法就是:&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;].sort(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;pre, curr&lt;/span&gt;) =&amp;gt;&lt;/span&gt; pre - curr)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// [1, 4, 5, 11, 42]&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;pre - curr 的值有三种情况&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小于 0 时, curr 排在 pre 后面&lt;/li&gt;
&lt;li&gt;大于 0 时, curr 排在 pre 前面&lt;/li&gt;
&lt;li&gt;等于 0 时, curr 和 pre 的位置不变&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外, 我们也可以对字符串进行排序:&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;[&lt;span class=&quot;string&quot;&gt;&#39;d&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;c&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;].sort()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// [a, b, c, d]&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;可能-是不稳定&quot;&gt;&lt;a href=&quot;#可能-是不稳定&quot; class=&quot;headerlink&quot; title=&quot;可能?是不稳定?&quot;&gt;&lt;/a&gt;可能?是不稳定?&lt;/h3&gt;&lt;p&gt;因为 ECMAScript 只是制定了 sort 这个方法, 但并没有给出具体的实现方式以及是否需要稳定的要求, sort 的实现就和其他大多数的方法一样由浏览器自行制定. 不同的浏览器或者同个浏览器不同版本上 sort 方法可能是稳定的, 也可能是不稳定的.&lt;/p&gt;
&lt;p&gt;这里结合 V8 源码分析下这个 sort 方法的内部调优过程.&lt;/p&gt;
&lt;p&gt;在 V8 中, 会通过以下函数方法进入 &lt;code&gt;innerArraySort&lt;/code&gt; 中&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ArraySort&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;comparefn&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  CHECK_OBJECT_COERCIBLE(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Array.prototype.sort&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; array = TO_OBJECT(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; length = TO_LENGTH(array.length);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; InnerArraySort(array, length, comparefn);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;源码有点长, 可以自己看下 &lt;a href=&quot;https://github.com/v8/v8/blob/master/src/js/array.js#L710&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注释已经点明了:&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://ruiming.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="Node" scheme="https://ruiming.github.io/tags/Node/"/>
    
      <category term="V8" scheme="https://ruiming.github.io/tags/V8/"/>
    
      <category term="Sort" scheme="https://ruiming.github.io/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>聊聊 Webpack 使用</title>
    <link href="https://ruiming.github.io/2016/11/17/%E8%81%8A%E8%81%8A-Webpack-%E4%BD%BF%E7%94%A8/"/>
    <id>https://ruiming.github.io/2016/11/17/聊聊-Webpack-使用/</id>
    <published>2016-11-17T05:24:47.000Z</published>
    <updated>2017-01-05T09:24:25.233Z</updated>
    
    <content type="html"><![CDATA[<p>老早的时候就听说了 Webpack 这个工具, 当时大概的印象就是类似 Gulp 这样的东西, 并且看起来好像挺复杂的. 直到学习 React 的时候才开始接触 Webpack, 才知道 Webpack 更多的是做模块化的工作. 不过当时也是乱配置一通能用就行=.=.</p>
<p>现在 Vue 标配也是用 Webpack 了. Webpack 其实并没有想象中的那么复杂, 其实最核心的还是 loader 那一块. 这次就主要聊一聊 Webpack. 我用的是 Webpack 最新版本 2.1.0-beta.27.</p>
<img src="/2016/11/17/聊聊-Webpack-使用/what-is-webpack.png" alt="what-is-webpack" title="what-is-webpack">
<h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p>Loader 是 Webpack 的核心, 它会自动查找项目中的我们指定的文件类型, 然后使用我们指定的 Loader 进行处理. 例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>: &#123;</div><div class="line">  <span class="attr">rules</span>: [&#123;</div><div class="line">    <span class="attr">test</span>:    <span class="regexp">/\.vue$/</span>,</div><div class="line">    <span class="attr">loader</span>:  <span class="string">'vue-loader'</span>,</div><div class="line">    <span class="attr">options</span>: &#123;</div><div class="line">      <span class="attr">loaders</span>: &#123;</div><div class="line">        <span class="attr">css</span>: ExtractTextPlugin.extract(&#123;</div><div class="line">          <span class="attr">loader</span>:         [<span class="string">'css-loader?minimize'</span>, <span class="string">'postcss-loader'</span>],</div><div class="line">          <span class="attr">fallbackLoader</span>: <span class="string">'vue-style-loader'</span></div><div class="line">        &#125;)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;, &#123;</div><div class="line">    <span class="attr">test</span>:    <span class="regexp">/\.js$/</span>,</div><div class="line">    <span class="attr">loader</span>:  <span class="string">'babel-loader'</span>,</div><div class="line">    <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span></div><div class="line">  &#125;, &#123;</div><div class="line">    <span class="attr">test</span>:   <span class="regexp">/\.css$/</span>,</div><div class="line">    <span class="attr">loader</span>: ExtractTextPlugin.extract(&#123;</div><div class="line">      <span class="attr">loader</span>: [<span class="string">'css-loader?minimize'</span>, <span class="string">'postcss-loader'</span>]</div><div class="line">    &#125;)</div><div class="line">  &#125;, &#123;</div><div class="line">    <span class="attr">test</span>:   <span class="regexp">/\.(eot|woff|woff2|ttf)([\?]?.*)$/</span>,</div><div class="line">    <span class="attr">loader</span>: <span class="string">'file-loader'</span></div><div class="line">  &#125;, &#123;</div><div class="line">    <span class="attr">test</span>:   <span class="regexp">/\.(png|jpg|gif|svg|ico)$/</span>,</div><div class="line">    <span class="attr">loader</span>: <span class="string">'url-loader?limit=8192'</span>,</div><div class="line">  &#125;]</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>对于 Vue 文件, 我们要让 <code>vue-loader</code> 来处理, 这里可以先忽略 <code>ExtractTextPlugin</code> 部分, 它作用是提取 CSS 这个在后面会提. 对于 <code>.js</code> 文件, 我们使用 <code>babel-loader</code> 来处理, 我们可以在项目配置一个 <code>.babelrc</code> 文件来指定我们使用的 presets 和 plugins. </p>
<a id="more"></a>
<p>Webpack 我觉得一个不太好的地方就是写法很多, 而且那么多种写法大体是一样的, 但是在一些场景下它们可能又会有区别, 就不能统一一下吗? 例如, 如果我们使用了 Sass, 那常用的两种写法如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 写法1</span></div><div class="line">&#123;</div><div class="line">    <span class="attr">test</span>:   <span class="regexp">/\.scss$/</span>,</div><div class="line">    <span class="attr">loader</span>: <span class="string">'css-loader!sass-loader'</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 写法2</span></div><div class="line">&#123;</div><div class="line">    <span class="attr">test</span>:   <span class="regexp">/\.scss$/</span>,</div><div class="line">    <span class="attr">loader</span>: [</div><div class="line">      <span class="string">'css-loader'</span>,</div><div class="line">      <span class="string">'sass-loader'</span></div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以使用 <code>!</code> 来连接多个 loader, 它们会自右向左执行.</p>
<p>另外, <code>-loader</code> 可以省略不写, 但在 Webpack2 中推荐写上. 如果不加 <code>-loader</code> 的话在一些场景下它会出错.</p>
<h2 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h2><p>这个是 webpack 另一个强大的地方了. Webpack-dev-server 是一个小型的 node.js Express 服务器, 通过 websocket 可以实现浏览器的模块热替换. 即前端代码变动的时候无需刷新整个页面, 而只是把变化的部分替换掉. 关于这个热替换, 其实也有好几种配置方法, 这里我只说我用的情况.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">devServer: &#123;</div><div class="line">        <span class="attr">hot</span>:                <span class="literal">true</span>,	<span class="comment">// 热替换</span></div><div class="line">        historyApiFallback: <span class="literal">true</span>,	<span class="comment">// HTML5 Mode</span></div><div class="line">        port:               <span class="number">7000</span>,	<span class="comment">// 端口</span></div><div class="line">        proxy:              &#123;		<span class="comment">// 代理</span></div><div class="line">            <span class="string">'/api/*'</span>: &#123;</div><div class="line">                <span class="attr">target</span>: <span class="string">'http://127.0.0.1:3000'</span></div><div class="line">            &#125;,</div><div class="line">            <span class="string">'/auth/*'</span>: &#123;</div><div class="line">                <span class="attr">target</span>: <span class="string">'http://127.0.0.1:3000'</span></div><div class="line">            &#125;,</div><div class="line">            <span class="string">'/img/*'</span>: &#123;</div><div class="line">                <span class="attr">target</span>: <span class="string">'http://127.0.0.1:3000'</span></div><div class="line">            &#125;,</div><div class="line">            <span class="string">'/css/*'</span>: &#123;</div><div class="line">                <span class="attr">target</span>: <span class="string">'http://127.0.0.1:3000'</span></div><div class="line">            &#125;,</div><div class="line">            <span class="string">'/fonts/*'</span>: &#123;</div><div class="line">                <span class="attr">target</span>: <span class="string">'http://127.0.0.1:3000'</span></div><div class="line">            &#125;,</div><div class="line">            <span class="string">'/js/*'</span>: &#123;</div><div class="line">                <span class="attr">target</span>: <span class="string">'http://127.0.0.1:3000'</span></div><div class="line">            &#125;,</div><div class="line">            <span class="string">'/favicon/*'</span>: &#123;</div><div class="line">                <span class="attr">target</span>: <span class="string">'http://127.0.0.1:3000'</span></div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的 proxy 也是 webpack-dev-server 一个强大的地方之一, 我们可以配置一些代理来避免跨域问题和端口不一致的问题.</p>
<p>接着运行即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack-dev-server --hot --open --inline --progress</div></pre></td></tr></table></figure>
<h2 id="减少打包体积"><a href="#减少打包体积" class="headerlink" title="减少打包体积"></a>减少打包体积</h2><p>Webpack 在开发环境打包的体积非常大, 因为其包含了 source-map 等. 我们在生产环境并不需要它, 可以如下配置:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">devtool</span>: isProduction() ? <span class="literal">false</span> : <span class="string">'#eval-source-map'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了这点, 有时候我们还想生产环境使用 CDN, 开发环境使用本地的资源. CDN 可以通过 externals 配置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  externals = &#123;</div><div class="line">    <span class="string">'vue'</span>:          <span class="string">'Vue'</span>,</div><div class="line">    <span class="string">'underscore'</span>:   <span class="string">'_'</span>,</div><div class="line">    <span class="string">'vue-resource'</span>: <span class="string">'VueResource'</span>,</div><div class="line">    <span class="string">'vue-router'</span>:   <span class="string">'VueRouter'</span>,</div><div class="line">    <span class="string">'vuex'</span>:         <span class="string">'Vuex'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同时不要忘记了在 <code>index.html</code> 中把各文件的 CDN 链接导入. 区分两个环境我们可以建立两个配置文件, 或者简单的通过条件语句判断. 这样处理后生产环境和开发环境的 <code>index.html</code> 就有了比较大的区别, 我处理方式是建立了两个 <code>index.html</code> 一个用于开发环境一个用于生产环境, 再者他们刚好也位于不同的位置, 开发环境从根目录加载 <code>index.html</code> , 而生产环境则有后端根据 UA 指向 <code>public</code> 下的 <code>index.html</code></p>
<p>再有的优化就是进行 JavaScript 代码的压缩混淆, 当然这个也只推荐在生产环境中使用:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">plugins.push(</div><div class="line">  <span class="comment">// 生产环境压缩 JavaScript 代码</span></div><div class="line">  <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</div><div class="line">    <span class="attr">test</span>:     <span class="regexp">/(\.vue|\.js)$/</span>,</div><div class="line">    <span class="attr">compress</span>: &#123;</div><div class="line">      <span class="attr">warnings</span>: <span class="literal">false</span></div><div class="line">    &#125;,</div><div class="line">  &#125;)</div><div class="line">)</div></pre></td></tr></table></figure>
<p>导入这个插件即可</p>
<p>另外还有 CSS 的压缩:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">test</span>:   <span class="regexp">/\.css$/</span>,</div><div class="line">    <span class="attr">loader</span>: ExtractTextPlugin.extract(&#123;</div><div class="line">      <span class="attr">loader</span>: [<span class="string">'css-loader?minimize'</span>, <span class="string">'postcss-loader'</span>]</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只要在 <code>css-loader</code> 后面加上 <code>?minimize</code> 就好了.</p>
<h2 id="提取-CSS"><a href="#提取-CSS" class="headerlink" title="提取 CSS"></a>提取 CSS</h2><p>就上面那段代码, 用到了 <code>ExtractTextPlugin</code> 这个插件, 它就是用来分离 CSS 代码的, 我们需要安装这个插件, 然后在 Webpack 中导入. 使用方法就上面这样, 但还要做一个配置:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">plugins.push(</div><div class="line">  <span class="keyword">new</span> ExtractTextPlugin(&#123;</div><div class="line">    <span class="attr">filename</span>:  isProduction() ? <span class="string">'style.[contenthash:4].css'</span> : <span class="string">'style.css'</span>,</div><div class="line">    <span class="attr">allChunks</span>: <span class="literal">true</span>,</div><div class="line">  &#125;)</div><div class="line">)</div></pre></td></tr></table></figure>
<p>导入这个插件, 并配置文件名. 之后他就会在我们的 output 处输出这个 CSS 文件.</p>
<p>我这里不仅仅是要处理 CSS 文件, 还要处理 <code>.vue</code> 中的 CSS 样式.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">test</span>:    <span class="regexp">/\.vue$/</span>,</div><div class="line">  <span class="attr">loader</span>:  <span class="string">'vue-loader'</span>,</div><div class="line">  <span class="attr">options</span>: &#123;</div><div class="line">    <span class="attr">loaders</span>: &#123;</div><div class="line">      <span class="attr">css</span>: ExtractTextPlugin.extract(&#123;</div><div class="line">            <span class="attr">loader</span>:         [<span class="string">'css-loader?minimize'</span>, <span class="string">'postcss-loader'</span>],</div><div class="line">            <span class="attr">fallbackLoader</span>: <span class="string">'vue-style-loader'</span></div><div class="line">          &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意 Webpack2 最新版本 API 想比 Webpack1 有较大变化. Webpack2 不支持在配置文件中插入其他东西, 如果你想对这个 loader 进行进一步配置, 需要在 options 中配置. 这里对 <code>vue-loader</code> 进行了进一步配置, 加入了 <code>postcss-loader</code> 和 <code>css-loader</code> .</p>
<p><code>postcss-loader</code> 也是一个比较坑的地方, 在 Webpack2 最新版本已经不支持使用 <code>postcss.config.js</code> 文件的配置, 你需要自己在 Webpack 中配置这个插件.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">plugins.push(</div><div class="line">  <span class="keyword">new</span> webpack.LoaderOptionsPlugin(&#123;</div><div class="line">    <span class="attr">options</span>: &#123;</div><div class="line">      <span class="attr">postcss</span>: [</div><div class="line">        <span class="built_in">require</span>(<span class="string">'postcss-nested'</span>),</div><div class="line">        <span class="built_in">require</span>(<span class="string">'postcss-cssnext'</span>)</div><div class="line">      ]</div><div class="line">    &#125;&#125;)</div><div class="line">)</div></pre></td></tr></table></figure>
<p>插入这个插件后后面才可以正常使用 <code>postcss-loader</code></p>
<p>我们同时处理了 <code>.css</code> 和 <code>.vue</code> 中的 css 并最终生成了一个 CSS 文件. 这里在生产环境会生成 <code>style.[contenthash:4].css</code> , <code>contenthash</code> 是根据文件内容生成的, 在文件名加入其哈希值后, 我们就可以大胆的最样式表进行长期缓存, 因为样式表内容一变化文件名也变了. </p>
<h2 id="文件名嵌入哈希值"><a href="#文件名嵌入哈希值" class="headerlink" title="文件名嵌入哈希值"></a>文件名嵌入哈希值</h2><p>除了 CSS 处理外, 我们还要对 JavaScript 进行处理, 这个是在 <code>output</code> 中配置的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">      output = &#123;</div><div class="line">        <span class="attr">path</span>:       path.resolve(__dirname, <span class="string">'./public/static/'</span>),</div><div class="line">        <span class="attr">publicPath</span>: <span class="string">'/static/'</span>,</div><div class="line">        <span class="attr">filename</span>:   <span class="string">'build.[chunkhash:4].js'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这里用的是 <code>chunkhash</code> , 我们在 CSS 中用的则是 <code>contenthash</code></p>
<p>最后我们就会生成如下的文件名:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">style.dd51.css</div><div class="line">build<span class="number">.84e5</span>.js</div></pre></td></tr></table></figure>
<p>但这样做是不够的, 我们不能每次都自己手动修改 <code>index.html</code> , 我们要让 <code>index.html</code> 中的文件哈希值也自动变化.</p>
<p>这个可以通过自定义插件来做, 我是直接参考了别人写的, 并没有深入去了解(仅供参考, 下面有说更好的方法)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">plugins.push(</div><div class="line">        <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.plugin(<span class="string">'done'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">statsData</span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> stats = statsData.toJson()</div><div class="line">                <span class="keyword">if</span> (!stats.errors.length) &#123;</div><div class="line">                    <span class="keyword">var</span> html = fs.readFileSync(<span class="string">'./public/index.html'</span>, <span class="string">'utf8'</span>)</div><div class="line">                    <span class="keyword">var</span> htmlOutput = html.replace(</div><div class="line">                        <span class="regexp">/static\/(.+?)"&gt;/g</span>,</div><div class="line">                        <span class="function"><span class="keyword">function</span> (<span class="params">word</span>) </span>&#123;</div><div class="line">                            <span class="keyword">let</span> filename = word.split(<span class="string">'/'</span>)[<span class="number">1</span>].split(<span class="string">'.'</span>)[<span class="number">0</span>]</div><div class="line">                            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; stats.assetsByChunkName.main.length; i++) &#123;</div><div class="line">                                <span class="keyword">if</span> (stats.assetsByChunkName.main[i].indexOf(filename) !== <span class="number">-1</span>) &#123;</div><div class="line">                                    <span class="keyword">return</span> <span class="string">'static/'</span> + stats.assetsByChunkName.main[i] + <span class="string">'"&gt;'</span></div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;)</div><div class="line">                    fs.writeFileSync(</div><div class="line">                        <span class="string">'./public/index.html'</span>,</div><div class="line">                        htmlOutput)</div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">        &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<p>这里的正则和路径都是根据自己项目的情况做出来的.</p>
<p>大致的意思就是监听插件的 <code>done</code> 事件, 然后传入 <code>statsData</code> 到这个插件的回调函数里, 如果没有出错, 那么获取得到 webpack 生成的文件名即上面说的文件名如 <code>style.dd51.css</code>, 即 <code>stats.assetsByChunkName.main</code> 这个数组. 这个数组保存着 webpack 生成的文件名, 接着我们获取 <code>index.html</code> 并用正则获取所有的 <code>script</code> 和 <code>style</code> , 我这里的处理措施是得到文件名如 <code>style</code> , 然后在 <code>stats.assetsByChunkName</code> 中查找包含这个串的输出文件名, 将这个文件名替换原来的即可.</p>
<p>// 2017.1.5 更新</p>
<p>其实还有更简便的方法, 使用 <code>HtmlWebpackPlugin</code> 插件, 然后进行下面的配置:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</div><div class="line">  <span class="attr">template</span>: <span class="string">'public/index.html'</span>,</div><div class="line">  <span class="attr">filename</span>: <span class="string">'../index.html'</span>,</div><div class="line">  <span class="attr">inject</span>: <span class="string">'head'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>Webpack 在运行过程提取出的 chunk, 自动输出到 <code>public/index.html</code> 的 <code>head</code> 中. 然后存储到 <code>output</code> 设置的 <code>publicPath</code> 中, 因为 <code>index.html</code> 通常存放在资源外面, 所以这里文件名进行了相对路劲的处理. </p>
<p>到这一步不得不感慨 Webpack 的强大, 上面我说的有点乱, 可以在<a href="https://github.com/ruiming/rss/blob/881a34c206b4bc7797c649a0226e7516686ec1c5/webpack.config.js" target="_blank" rel="external">这里</a>(最新的配置文件已经发生了改变)查看我的详细 webpack 配置. 这里没有细说每个配置的每个选项, 这些选项有些我自己也还搞不太明白, 最近还要再好好看下里面一些选项的细微区别.</p>
<p>总结下, 上面的 Webpack 帮我们做了这些事情:</p>
<ul>
<li><p>模块化</p>
<p>一切皆模块, 只要有 loader. 我们可以在我们的 JS 文件中导入 CSS, 图片等资源. Webpack 会自动帮我们做处理. 只要你想的话, 你还可以用 CSS in JS. 如果你单独分离 CSS, 那么最终生成的就是一个 JavaScript 文件.</p>
</li>
<li><p>使用 Babel 和 PostCSS</p>
<p>在 Webpack 中使用 <code>babel-loader</code> 处理 <code>.js</code> 和 <code>.vue</code> 文件, 我们就可以任性的写 ES6 和 ES7 了. 给 <code>.css</code> 和 <code>vue-loader</code> 加入 <code>post-loader</code> 后我们就可以任性的使用 cssnext 等特性了. 原本我是用 <code>sass-loader</code> 的, 但是我主要用的嵌套功能其实 <code>postcss-loader</code> 也可以处理, 并且我挺喜欢 <code>postcss-loader</code> 的丰富插件这个特性. 从此抛开 CSS 预处理器.</p>
</li>
<li><p>压缩合并 JS 和 CSS</p>
<p>不需要使用 Gulp 了. Webpack 对 JS 和 CSS 的压缩合并处理不能再简单了.</p>
</li>
<li><p>代理服务器</p>
<p>反向代理了我们的 API, 避免了端口修改和跨域的问题.</p>
</li>
<li><p>文件哈希名</p>
<p>给 CSS 和 JS 嵌入了哈希值, 并且自动替换 <code>index.html</code> 中的路径文件.</p>
</li>
</ul>
<p>恩, 不愧是前端模块化和自动化利器.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;老早的时候就听说了 Webpack 这个工具, 当时大概的印象就是类似 Gulp 这样的东西, 并且看起来好像挺复杂的. 直到学习 React 的时候才开始接触 Webpack, 才知道 Webpack 更多的是做模块化的工作. 不过当时也是乱配置一通能用就行=.=.&lt;/p&gt;
&lt;p&gt;现在 Vue 标配也是用 Webpack 了. Webpack 其实并没有想象中的那么复杂, 其实最核心的还是 loader 那一块. 这次就主要聊一聊 Webpack. 我用的是 Webpack 最新版本 2.1.0-beta.27.&lt;/p&gt;
&lt;img src=&quot;/2016/11/17/聊聊-Webpack-使用/what-is-webpack.png&quot; alt=&quot;what-is-webpack&quot; title=&quot;what-is-webpack&quot;&gt;
&lt;h2 id=&quot;Loader&quot;&gt;&lt;a href=&quot;#Loader&quot; class=&quot;headerlink&quot; title=&quot;Loader&quot;&gt;&lt;/a&gt;Loader&lt;/h2&gt;&lt;p&gt;Loader 是 Webpack 的核心, 它会自动查找项目中的我们指定的文件类型, 然后使用我们指定的 Loader 进行处理. 例如:&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;rules&lt;/span&gt;: [&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;test&lt;/span&gt;:    &lt;span class=&quot;regexp&quot;&gt;/\.vue$/&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;loader&lt;/span&gt;:  &lt;span class=&quot;string&quot;&gt;&#39;vue-loader&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;options&lt;/span&gt;: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;attr&quot;&gt;loaders&lt;/span&gt;: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;css&lt;/span&gt;: ExtractTextPlugin.extract(&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          &lt;span class=&quot;attr&quot;&gt;loader&lt;/span&gt;:         [&lt;span class=&quot;string&quot;&gt;&#39;css-loader?minimize&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;postcss-loader&#39;&lt;/span&gt;],&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          &lt;span class=&quot;attr&quot;&gt;fallbackLoader&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;vue-style-loader&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;, &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;test&lt;/span&gt;:    &lt;span class=&quot;regexp&quot;&gt;/\.js$/&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;loader&lt;/span&gt;:  &lt;span class=&quot;string&quot;&gt;&#39;babel-loader&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;exclude&lt;/span&gt;: &lt;span class=&quot;regexp&quot;&gt;/node_modules/&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;, &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;test&lt;/span&gt;:   &lt;span class=&quot;regexp&quot;&gt;/\.css$/&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;loader&lt;/span&gt;: ExtractTextPlugin.extract(&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;attr&quot;&gt;loader&lt;/span&gt;: [&lt;span class=&quot;string&quot;&gt;&#39;css-loader?minimize&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;postcss-loader&#39;&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;, &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;test&lt;/span&gt;:   &lt;span class=&quot;regexp&quot;&gt;/\.(eot|woff|woff2|ttf)([\?]?.*)$/&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;loader&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;file-loader&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;, &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;test&lt;/span&gt;:   &lt;span class=&quot;regexp&quot;&gt;/\.(png|jpg|gif|svg|ico)$/&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;loader&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;url-loader?limit=8192&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;,&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于 Vue 文件, 我们要让 &lt;code&gt;vue-loader&lt;/code&gt; 来处理, 这里可以先忽略 &lt;code&gt;ExtractTextPlugin&lt;/code&gt; 部分, 它作用是提取 CSS 这个在后面会提. 对于 &lt;code&gt;.js&lt;/code&gt; 文件, 我们使用 &lt;code&gt;babel-loader&lt;/code&gt; 来处理, 我们可以在项目配置一个 &lt;code&gt;.babelrc&lt;/code&gt; 文件来指定我们使用的 presets 和 plugins. &lt;/p&gt;
    
    </summary>
    
      <category term="Webpack" scheme="https://ruiming.github.io/categories/Webpack/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="Vue" scheme="https://ruiming.github.io/tags/Vue/"/>
    
      <category term="Webpack" scheme="https://ruiming.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>使用 Koa2 开发小结</title>
    <link href="https://ruiming.github.io/2016/11/15/%E4%BD%BF%E7%94%A8-Koa2-%E5%BC%80%E5%8F%91%E5%B0%8F%E7%BB%93/"/>
    <id>https://ruiming.github.io/2016/11/15/使用-Koa2-开发小结/</id>
    <published>2016-11-14T16:00:16.000Z</published>
    <updated>2016-11-17T05:30:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>RSS 订阅器项目是我最近花时间比较多的一个项目了. 在这个项目中我使用了大量的新技术, 很多技术都是我第一次使用. 后端是基于 Koa2 和 Mongoose 的 RESTful API.</p>
<p>在这个项目开展前, 我已经有半年多没接触后端了. 上一次后端还是用 PHP 以及 Laravel 框架开发的 LNMP 架构. 在动工前, 我也没有正式的使用过 Node 以及其部署, 对于 Koa2 的 async await 的异步书写方式也只是久仰大名而已.</p>
<p>这篇博客主要想说一说自己在使用 Node.js 和 Koa2 开发后端过程中的一些总结和收获.</p>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>Koa2 本身是一个非常轻的框架, 我们需要使用大量的中间件去完善它, 例如 <code>koa-bodyparser</code> , <code>koa-etag</code>, <code>koa-router</code>, <code>koa-sslify</code> 等等.</p>
<p>同时, 肯定免不了自己写中间件, 例如我自己就写了 7 个中间件, 分别是处理缓存, 处理 cookies, 强制 www, 配合前端 HTML5Mode, 错误处理, UA 判断, JWT 和 XSRF 处理.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">async</span>(ctx, next) =&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="regexp">/^\/(mark|square|feed|feeds|post|posts|me|search)/</span>.test(ctx.request.url)) &#123;</div><div class="line">            <span class="keyword">if</span> (ctx.mobile) &#123;</div><div class="line">                <span class="keyword">await</span> send(ctx, <span class="string">'./public/index.html'</span>)</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">await</span> send(ctx, <span class="string">'./public/pc.html'</span>)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">await</span> next()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述就是配合前端 HTML5Mode 以及根据 UA 指向不同入口文件的中间件.</p>
<a id="more"></a>
<p>Koa2 的错误处理非常友好, 可以通过以下这样一个中间件来统一处理错误, 我们可以在这里捕捉到代码运行的大部分错误, 包括异步过程中的错误, 以及自己在代码中抛出的错误, 然后在这里统一的进行处理.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">async</span>(ctx, next) =&gt; &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">await</span> next()</div><div class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line"> </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实中间件听起来高大上其实并没什么, 你也可以直接写到 Koa 的入口文件, 但是比较好的风格是把他们都提取出来, 然后入口文件导入这些中间件进行 use 即可.</p>
<h3 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h3><p>Koa2 使用 HTTP2 也非常简单.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">http.createServer(app.callback()).listen(config.PORT)</div><div class="line"></div><div class="line"><span class="comment">// Production Only</span></div><div class="line"><span class="keyword">if</span> (config.ENV === <span class="string">'production'</span>) &#123;</div><div class="line">    <span class="keyword">const</span> options = &#123;</div><div class="line">        <span class="attr">key</span>:  config.APP.SSL_KEY,</div><div class="line">        <span class="attr">cert</span>: config.APP.SSL_CERT,</div><div class="line">        <span class="attr">ca</span>:   config.APP.CA</div><div class="line">    &#125;</div><div class="line">    http2.createServer(options, app.callback()).listen(<span class="number">443</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以配置两个配置文件分别作用于生产环境和开发环境, 然后在入口文件根据不同的环境使用即可. </p>
<p>另外也可以很方便的通过使用 <code>koa-helmet</code> 来配置 HSTS</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>虽然, Node 的主流版本都支持 Promise 了, 但是似乎原生的 Promise 仍然比 Bluebird 慢并且更消耗内存. 所以推荐使用 Bluebird 替代原生 Promise. 具体原因可以查看 [<a href="http://softwareengineering.stackexchange.com/a/279003" target="_blank" rel="external">Why are native ES6 promises slower and more memory-intensive than bluebird?</a></p>
<p>可以把 mongoose 和全局的 promise 都换成 bluebird.</p>
<p>与此同时我们还获得了更加丰富的 Promise 方法如 promisify, 不用白不用.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mongoose.Promise = <span class="built_in">require</span>(<span class="string">'bluebird'</span>)</div><div class="line">global.Promise = <span class="built_in">require</span>(<span class="string">'bluebird'</span>)</div></pre></td></tr></table></figure>
<h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>JWT 已经在前面的博客中提到过了, 我认为 JWT 保存 cookie 并设置 httpOnly, 同时传输非 httpOnly 的 XSRF-TOKEN 这种认证方式是比较妥当的. 如果使用了 HTTPS, 还可以同时设置 secure.</p>
<h3 id="NPM-scripts"><a href="#NPM-scripts" class="headerlink" title="NPM scripts"></a>NPM scripts</h3><p>npm scripts 非常好用, 我们可以自定义很多命令在里面. 例如我在项目中常用的:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">"start": "pm2 start production.json",</div><div class="line">"dev": "pm2 start development.json",</div><div class="line">"angular": "pm2 start development.json",</div><div class="line">"vue": "webpack-dev-server --hot --open --inline --progress",</div><div class="line">"angular-dist": "gulp build",</div><div class="line">"vue-dist": "NODE_ENV=production webpack --progress",</div><div class="line">"build": "npm run angular-dist &amp; npm run vue-dist",</div><div class="line">"db": "mongod --dbpath='/root/db' --rest",</div><div class="line">"generatessl": "./certbot-auto certonly --webroot -w /root/rss -d enjoyrss.com -d www.enjoyrss.com",</div><div class="line">"updatessl": "./certbot-auto renew --quiet",</div><div class="line">"cron": "crontab ./utils/cron"</div></pre></td></tr></table></figure>
<p>在部署生成环境时运行 <code>npm run build</code> 构建最新版本, 运行 <code>npm run updatessl</code> 更新 SSL 证书, 运行<code>npm start</code> 来启动项目, 运行 <code>npm run db</code> 开启数据库.</p>
<h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p>用了 Babel 之后, 就可以随心所欲的书写 ES6 甚至 ES7 了.</p>
<p>我用的比较多的是 <code>import</code> , <code>for...of...</code> , <code>async</code> 以及解构赋值, 属性名表达式, 数组扩展符, 对象扩展符等等.</p>
<p>解构赋值和属性名表达式可以大大减少代码量, 写起来特别爽.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">exports.list = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</div><div class="line">    <span class="keyword">let</span> &#123;</div><div class="line">        order,</div><div class="line">        limit,</div><div class="line">        page,</div><div class="line">        per_page,</div><div class="line">        desc</div><div class="line">    &#125; = ctx.request.query</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> FeedModel.find()</div><div class="line">        .sort(&#123;</div><div class="line">            [order]: desc === <span class="string">'true'</span> ? <span class="string">'1'</span> : <span class="string">'-1'</span></div><div class="line">        &#125;)</div><div class="line">        .skip(+page * +per_page)</div><div class="line">        .limit(+per_page || +limit)</div><div class="line"></div><div class="line">    ctx.body = &#123;</div><div class="line">        <span class="attr">success</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">data</span>:    result</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>数组扩展符和对象扩展符也很方便, 不用再使用 Array.concat 和 Object.assign 方法了.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 数组扩展符</span></div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="keyword">var</span> b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line"><span class="keyword">var</span> c = [...a, <span class="number">4</span>, <span class="number">5</span>]	<span class="comment">// [1, 2, 3, 4, 5]</span></div><div class="line"><span class="keyword">var</span> d = [...a, ...b]	<span class="comment">// [1, 2, 3, 4, 5, 6]</span></div><div class="line"><span class="comment">// 对象扩展符</span></div><div class="line"><span class="keyword">var</span> feed = &#123;</div><div class="line">  <span class="attr">_id</span>:    <span class="number">123456</span>,</div><div class="line">  <span class="attr">title</span>:  <span class="string">'kkkk'</span>,</div><div class="line">  <span class="attr">unread</span>: <span class="number">6</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> result = &#123;</div><div class="line">  ...feed,</div><div class="line">  <span class="attr">feed_id</span>: <span class="number">111111</span>,</div><div class="line">  <span class="attr">unread</span>:  <span class="number">10</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// result: &#123; _id: 123456, title: 'kkkk', unread: 10, feed_id: 11111 &#125;</span></div></pre></td></tr></table></figure>
<p>Async 异步函数也不是万能的, 它无法处理多个异步函数的同步处理问题. 这时候就要借助 Promise.all 了.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">await</span> <span class="built_in">Promise</span>.all([</div><div class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="keyword">async</span> () =&gt; state = <span class="keyword">await</span> UserPostModel.findOne(&#123;</div><div class="line">    user_id,</div><div class="line">    <span class="attr">post_id</span>: item</div><div class="line">  &#125;)),</div><div class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="keyword">async</span> () =&gt; res = <span class="keyword">await</span> PostModel.findById(item))</div><div class="line">])</div></pre></td></tr></table></figure>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存在 Web 中非常重要</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; SHA256 &#125; <span class="keyword">from</span> <span class="string">'crypto-js'</span></div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next) =&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (ctx.request.method === <span class="string">'GET'</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="regexp">/js|css|favicon|image/</span>.test(ctx.path)) &#123;</div><div class="line">                ctx.cacheControl = &#123;</div><div class="line">                    <span class="attr">maxAge</span>: <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">180</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">await</span> next()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个中间件给图片和文件设置了长达 180 天的缓存时间, 其实这里永久存储都 OK 了. 因为我的 JS 和 CSS 文件变化的话文件名和路径都变了, 图片是稳定不变的即使变了它的文件名也会变化. 因此我可以大胆的这样使用.</p>
<p>大部分工作我是交给了 <code>koa-etag</code> 和 <code>koa-cache-control</code> 这两个中间件来处理了. 现在项目我除了后端做好缓存之外, 前端也是进行了 JavaScript 的内存缓存和自动更新从而减少了请求数. 这样就大大减少了服务器的压力以及提升了用户的访问速度和体验.</p>
<h3 id="PM2"><a href="#PM2" class="headerlink" title="PM2"></a>PM2</h3><p>PM2 是一个带有负载均衡功能的应用进程管理器. 我们可以用它来管理我们的 Node 进程, 它的用法也很简单. 使用 PM2 可以充分发挥服务器多核的特性(如果有的话), 并且实现0秒重载以及进程信息监控等. PM2 是比较通用的 Node 部署方式.</p>
<img src="/2016/11/15/使用-Koa2-开发小结/pm2.png" alt="pm2.png" title="pm2.png">
<h3 id="代码共用"><a href="#代码共用" class="headerlink" title="代码共用"></a>代码共用</h3><p>由于前后端都是使用 JavaScript 这门语言, 不仅包管理统一, 大量的包如 Underscore 也可以前后端共用, 最方便的是大部分的工具函数也可以前后端一起使用, 例如检测邮箱和密码格式我们在前端做检测的同时, 后端也可以直接调用过来. 例如下面这个文件就可以同时在前端 Vue, Angular 以及后端中同时使用.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> help = &#123;</div><div class="line">        <span class="comment">// 检测 URL 是否合法</span></div><div class="line">        checkUrl(url) &#123;</div><div class="line">            <span class="keyword">let</span> re = <span class="regexp">/https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]&#123;2,256&#125;\.[a-z]&#123;2,6&#125;\b([-a-zA-Z0-9@:%_\+.~#?&amp;//=]*)/</span></div><div class="line">            <span class="keyword">return</span> re.test(url)</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 检测邮箱是否合法</span></div><div class="line">        validateEmail(email) &#123;</div><div class="line">            <span class="keyword">let</span> re = <span class="regexp">/\S+@\S+\.\S+/</span></div><div class="line">            <span class="keyword">return</span> re.test(email)</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 检验密码是否合法</span></div><div class="line">        validatePassword(password) &#123;</div><div class="line">            <span class="keyword">let</span> re = <span class="regexp">/\w&#123;6,18&#125;/</span></div><div class="line">            <span class="keyword">return</span> re.test(password)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// In angular, the module name is app.tools, and the factory name is tools.</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">module</span>.exports) &#123;</div><div class="line">        <span class="built_in">module</span>.exports = help</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        angular.module(<span class="string">'app.tools'</span>, []).factory(<span class="string">'tools'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> help</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;())</div></pre></td></tr></table></figure>
<p>其实写 Node 相比起写前端要简单好多好多, 没有什么 Gulp, Webpack, 不用考虑文件体积和大小, 不用考虑模块化组件化之类的问题, 不用考虑客户端浏览器类型和浏览器版本, 不用追求各种极限速度(现在的自动雪碧图处理, 文件懒加载和前端框架的服务端渲染真的是没谁了…).</p>
<p>在 LNMP 架构中, 我们要使用 Nginx 来帮我们处理静态文件, 配置 PHP-FPM 来处理 PHP 请求. Gzip 和 HTTPS 等等都是在 Nginx 中配置. 其实这些事情 Node 都可以做了. 但并不意味着 Node 可以取代 Nginx, Nginx 不仅是一个 Web 服务器也是一个反向代理服务器. 必要的时候我们还是要使用 Nginx 来做一个反向代理.</p>
<p>以上.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RSS 订阅器项目是我最近花时间比较多的一个项目了. 在这个项目中我使用了大量的新技术, 很多技术都是我第一次使用. 后端是基于 Koa2 和 Mongoose 的 RESTful API.&lt;/p&gt;
&lt;p&gt;在这个项目开展前, 我已经有半年多没接触后端了. 上一次后端还是用 PHP 以及 Laravel 框架开发的 LNMP 架构. 在动工前, 我也没有正式的使用过 Node 以及其部署, 对于 Koa2 的 async await 的异步书写方式也只是久仰大名而已.&lt;/p&gt;
&lt;p&gt;这篇博客主要想说一说自己在使用 Node.js 和 Koa2 开发后端过程中的一些总结和收获.&lt;/p&gt;
&lt;h3 id=&quot;中间件&quot;&gt;&lt;a href=&quot;#中间件&quot; class=&quot;headerlink&quot; title=&quot;中间件&quot;&gt;&lt;/a&gt;中间件&lt;/h3&gt;&lt;p&gt;Koa2 本身是一个非常轻的框架, 我们需要使用大量的中间件去完善它, 例如 &lt;code&gt;koa-bodyparser&lt;/code&gt; , &lt;code&gt;koa-etag&lt;/code&gt;, &lt;code&gt;koa-router&lt;/code&gt;, &lt;code&gt;koa-sslify&lt;/code&gt; 等等.&lt;/p&gt;
&lt;p&gt;同时, 肯定免不了自己写中间件, 例如我自己就写了 7 个中间件, 分别是处理缓存, 处理 cookies, 强制 www, 配合前端 HTML5Mode, 错误处理, UA 判断, JWT 和 XSRF 处理.&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt;(ctx, next) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;regexp&quot;&gt;/^\/(mark|square|feed|feeds|post|posts|me|search)/&lt;/span&gt;.test(ctx.request.url)) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ctx.mobile) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; send(ctx, &lt;span class=&quot;string&quot;&gt;&#39;./public/index.html&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; send(ctx, &lt;span class=&quot;string&quot;&gt;&#39;./public/pc.html&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; next()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述就是配合前端 HTML5Mode 以及根据 UA 指向不同入口文件的中间件.&lt;/p&gt;
    
    </summary>
    
      <category term="Node" scheme="https://ruiming.github.io/categories/Node/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="Koa" scheme="https://ruiming.github.io/tags/Koa/"/>
    
      <category term="Node" scheme="https://ruiming.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>使用 ESLint 规范你的代码</title>
    <link href="https://ruiming.github.io/2016/11/08/%E4%BD%BF%E7%94%A8-ESLint-%E8%A7%84%E8%8C%83%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
    <id>https://ruiming.github.io/2016/11/08/使用-ESLint-规范你的代码/</id>
    <published>2016-11-08T04:57:39.000Z</published>
    <updated>2016-11-09T04:22:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>在一些多人参与的项目开发中, 每个人代码习惯不同, 对于缩进, 有人习惯 TAB, 有人习惯两个空格, 有人习惯四个空格. 对于分号, 有人不加, 有人习惯加, 而习惯加分号的人又会经常漏加分号. 试想一个项目代码如果由各种群魔乱舞的风格组成, 这必然会带来一定的视觉障碍(强迫症的人看了受不了=.=), 并且显得代码质量低下.</p>
<p>即使是个人, 偶尔也会写出一些不太规范的代码, 比如变量声明了未使用, 比如使用了 <code>==</code> 等等, 更不要说各种代码格式如操作符左右空格, <code>if ... else</code> 的格式, 末行换行等等. 特别是像有强迫症的我, 有时候写的过程可能会不小心遗漏或写错, 但发现的时候又会去改过来. 如果能在书写过程中检查出不规范的地方提示岂不是最好?</p>
<p>ESLint 是一个插件化的 JavaScript 代码检查工具, 可以用于检查常见的 JavaScript 代码错误, 规范 JavaScript 代码的书写, 可以有效控制代码的质量. </p>
<img src="/2016/11/08/使用-ESLint-规范你的代码/eslint.jpg" alt="eslint.jpg" title="eslint.jpg">
<h2 id="ESLint-规则"><a href="#ESLint-规则" class="headerlink" title="ESLint 规则"></a>ESLint 规则</h2><p>ESLint 使用非常简单, 安装好 ESLint 后, 可以自定义一套规则文件或者使用开源的代码风格规范, 像 Google, Airbnb 都有开源的 JavaScript 代码书写规范. 可以直接使用它们的, 也可以自己配置.</p>
<p>具体的用法可以参考官方文档, 其实蛮简单的.</p>
<p><a href="http://eslint.cn/docs/rules/" target="_blank" rel="external">这里</a>列出了 ESLint 的各种规则, 可以参考下这里的说明.</p>
<p>以下是我个人配置的规则</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"env"</span>: &#123;</div><div class="line">        <span class="string">"browser"</span>: <span class="literal">true</span>,</div><div class="line">        <span class="string">"commonjs"</span>: <span class="literal">true</span>,</div><div class="line">        <span class="string">"es6"</span>: <span class="literal">true</span>,</div><div class="line">        <span class="string">"node"</span>: <span class="literal">true</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">"parser"</span>: <span class="string">"babel-eslint"</span>,</div><div class="line">    <span class="string">"extends"</span>: <span class="string">"eslint:recommended"</span>,</div><div class="line">    <span class="string">"plugins"</span>: [</div><div class="line">        <span class="string">"babel"</span></div><div class="line">    ],</div><div class="line">    <span class="string">"parserOptions"</span>: &#123;</div><div class="line">        <span class="string">"sourceType"</span>: <span class="string">"module"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">"globals"</span>: &#123;</div><div class="line">        <span class="string">"angular"</span>: <span class="literal">true</span>,</div><div class="line">        <span class="string">"d3"</span>: <span class="literal">true</span>,</div><div class="line">        <span class="string">"ga"</span>: <span class="literal">true</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">"rules"</span>: &#123;</div><div class="line">        <span class="comment">// 4空格缩进 auto</span></div><div class="line">        <span class="string">"indent"</span>: [</div><div class="line">            <span class="string">"error"</span>,</div><div class="line">            <span class="number">4</span></div><div class="line">        ],</div><div class="line">        <span class="comment">// unix 换行风格 auto</span></div><div class="line">        <span class="string">"linebreak-style"</span>: [</div><div class="line">            <span class="string">"error"</span>,</div><div class="line">            <span class="string">"unix"</span></div><div class="line">        ],</div><div class="line">        <span class="comment">// 强制单引号 auto</span></div><div class="line">        <span class="string">"quotes"</span>: [</div><div class="line">            <span class="string">"error"</span>,</div><div class="line">            <span class="string">"single"</span></div><div class="line">        ],</div><div class="line">        <span class="comment">// 禁止分号 auto</span></div><div class="line">        <span class="string">"semi"</span>: [</div><div class="line">            <span class="string">"error"</span>,</div><div class="line">            <span class="string">"never"</span></div><div class="line">        ],</div><div class="line">        <span class="comment">// 变量定义或参数声明未使用</span></div><div class="line">        <span class="string">"no-cond-assign"</span>: [</div><div class="line">            <span class="string">"warn"</span></div><div class="line">        ],</div><div class="line">        <span class="comment">// 强制 !== 和 ===, 和 null 或 undefined 比较例外</span></div><div class="line">        <span class="string">"eqeqeq"</span>: [</div><div class="line">            <span class="string">"error"</span>,</div><div class="line">            <span class="string">"allow-null"</span></div><div class="line">        ],</div><div class="line">        <span class="comment">// 强制大括号风格 auto</span></div><div class="line">        <span class="string">"curly"</span>: [</div><div class="line">            <span class="string">"error"</span>,</div><div class="line">            <span class="string">"all"</span></div><div class="line">        ],</div><div class="line">        <span class="comment">// 强制末尾换行 auto</span></div><div class="line">        <span class="string">"eol-last"</span>: [</div><div class="line">            <span class="string">"error"</span></div><div class="line">        ],</div><div class="line">        <span class="comment">// 关键字空格 auto</span></div><div class="line">        <span class="string">"keyword-spacing"</span>: [</div><div class="line">            <span class="string">"error"</span>,</div><div class="line">            &#123;</div><div class="line">                <span class="string">"before"</span>: <span class="literal">true</span>,</div><div class="line">                <span class="string">"after"</span>: <span class="literal">true</span></div><div class="line">            &#125;</div><div class="line">        ],</div><div class="line">        <span class="comment">// 强制单行代码块中使用空格 auto</span></div><div class="line">        <span class="string">"block-spacing"</span>: [</div><div class="line">            <span class="string">"error"</span>,</div><div class="line">            <span class="string">"always"</span></div><div class="line">        ],</div><div class="line">        <span class="comment">// 逗号前面不能由空格, 后面要空格 auto</span></div><div class="line">        <span class="string">"comma-spacing"</span>: [</div><div class="line">            <span class="string">"error"</span>,</div><div class="line">            &#123;</div><div class="line">                <span class="string">"before"</span>: <span class="literal">false</span>,</div><div class="line">                <span class="string">"after"</span>: <span class="literal">true</span> </div><div class="line">            &#125;</div><div class="line">        ],</div><div class="line">        <span class="comment">// 冒号前面不能有空格, 后面必须有空格, 键值需水平对齐 auto</span></div><div class="line">        <span class="string">"key-spacing"</span>: [</div><div class="line">            <span class="string">"error"</span>,</div><div class="line">            &#123;</div><div class="line">                <span class="string">"beforeColon"</span>: <span class="literal">false</span>,</div><div class="line">                <span class="string">"afterColon"</span>: <span class="literal">true</span>,</div><div class="line">                <span class="string">"align"</span>: <span class="string">"value"</span></div><div class="line">            &#125;</div><div class="line">        ],</div><div class="line">        <span class="comment">// 参数未使用提示</span></div><div class="line">        <span class="string">"no-unused-vars"</span>: [</div><div class="line">            <span class="string">"warn"</span>,</div><div class="line">            &#123;</div><div class="line">                <span class="string">"var"</span>: <span class="string">"all"</span>,</div><div class="line">                <span class="string">"all"</span>: <span class="string">"all"</span></div><div class="line">            &#125;</div><div class="line">        ],</div><div class="line">        <span class="comment">// 禁用行尾空格 auto</span></div><div class="line">        <span class="string">"no-trailing-spaces"</span>: [</div><div class="line">            <span class="string">"error"</span>, </div><div class="line">            &#123; </div><div class="line">                <span class="string">"skipBlankLines"</span>: <span class="literal">true</span> </div><div class="line">            &#125;</div><div class="line">        ],</div><div class="line">        <span class="comment">// 函数左括号左边不能有空格 auto</span></div><div class="line">        <span class="string">"space-before-function-paren"</span>: [</div><div class="line">            <span class="string">"error"</span>,</div><div class="line">            &#123;</div><div class="line">                <span class="string">"anonymous"</span>: <span class="string">"always"</span>, </div><div class="line">                <span class="string">"named"</span>: <span class="string">"never"</span></div><div class="line">            &#125;</div><div class="line">        ],</div><div class="line">        <span class="comment">// 操作符周围有空格 auto</span></div><div class="line">        <span class="string">"space-infix-ops"</span>: [</div><div class="line">            <span class="string">"error"</span>, </div><div class="line">            &#123;</div><div class="line">                <span class="string">"int32Hint"</span>: <span class="literal">false</span></div><div class="line">            &#125;</div><div class="line">        ],</div><div class="line">        <span class="string">"babel/generator-star-spacing"</span>: <span class="number">1</span>,</div><div class="line">        <span class="string">"babel/new-cap"</span>: <span class="number">1</span>,</div><div class="line">        <span class="string">"babel/array-bracket-spacing"</span>: <span class="number">1</span>,</div><div class="line">        <span class="string">"babel/object-shorthand"</span>: <span class="number">1</span>,</div><div class="line">        <span class="string">"babel/no-await-in-loop"</span>: <span class="number">1</span>,</div><div class="line">        <span class="string">"babel/flow-object-type"</span>: <span class="number">1</span>,</div><div class="line">        <span class="string">"babel/func-params-comma-dangle"</span>: <span class="number">1</span>,</div><div class="line">        <span class="string">"no-console"</span>: <span class="string">"off"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>建议 parser 换成 babel-eslint, 并加入了 <code>babel</code> 这个插件, 为的是可以解析 ES6 和 ES7 的一些语法. 这里使用的是默认的规则文件 <code>eslint:recommended</code>. 这样对代码的约束比较少, 有更多的灵活性. 默认的规则是禁止代码内出现 <code>console.log</code> 的, 需要用的可以通过 <code>&quot;no-console&quot;: &quot;off&quot;</code> 关闭.</p>
<p>举几个例子说明下:</p>
<ul>
<li><p><code>qutoes</code> 我习惯在 JavaScript 的字符串中使用单引号, 这个也看个人了, 单引号比双引号容易打</p>
</li>
<li><p><code>semi</code> JavaScript 中分号是没必要的, 因为经常会漏加分号, 并且好像不用分号看起来更简洁好看些, 所以干脆就都不加了</p>
</li>
<li><p><code>no-cond-assign</code> 变量定义或参数声明后未使用, 这是不太规范的, 但我这里使用的 warn 而不是 error</p>
</li>
<li><p><code>eqeqeq</code> 强制 <code>!==</code> 和 <code>==</code> , 除了和 <code>null</code> 与 <code>undefined</code> 比较外, 因为 <code>null == undefined</code>, 对于判断一个变量是否为 null 或 undefined 时 <code>==</code> 比较好用</p>
</li>
<li><p><code>curly</code> 强制大括号风格, 即要求控制语句不能省略大括号, 我喜欢统一的大括号, 不喜欢一会写一会不写的样子</p>
</li>
<li><p><code>eol-last</code> 强制末尾换行, 习惯了, 但有时候也会忘记或者空了好几行, 加这个约束一下</p>
</li>
<li><p><code>keyword-spacing</code> 我设置了关键字前后都要有空格, 按我设置的使用规则后, 就会有以下约束</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// true</span></div><div class="line"><span class="keyword">if</span> (foo) &#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (bar) &#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// false</span></div><div class="line"><span class="keyword">if</span>(foo) &#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(bar) &#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>comma-spacing</code> 逗号前面不能有空格, 逗号后面要接空格</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// true</span></div><div class="line"><span class="keyword">const</span> a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></div><div class="line"><span class="comment">// false</span></div><div class="line"><span class="keyword">const</span> a,b,c = <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>key-spacing</code> 冒号前面不能有空格, 后面必须有空格, 键值水平对齐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// true</span></div><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'kkk'</span>,</div><div class="line">  <span class="attr">id</span>:   <span class="number">2014210</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// false</span></div><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  <span class="attr">name</span>:<span class="string">'kkk'</span>,</div><div class="line">  <span class="attr">id</span> : <span class="string">'uuu'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="结合-VSCode"><a href="#结合-VSCode" class="headerlink" title="结合 VSCode"></a>结合 VSCode</h2><p>VSCode 内置了 ESLint 的支持</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// Controls whether eslint is enabled for JavaScript files or not.</div><div class="line">"eslint.enable": true,</div><div class="line"></div><div class="line">// A path added to NODE_PATH when resolving the eslint module.</div><div class="line">"eslint.nodePath": null,</div><div class="line"></div><div class="line">// Uses the legacy module resolving.</div><div class="line">"eslint._legacyModuleResolve": false,</div><div class="line"></div><div class="line">// The eslint options object to provide args normally passed to eslint when executed from a command line.</div><div class="line">"eslint.options": &#123;&#125;,</div><div class="line"></div><div class="line">// Traces the communication between VSCode and the eslint linter service.</div><div class="line">"eslint.trace.server": "off",</div><div class="line"></div><div class="line">// Run the linter on save (onSave) or on type (onType)</div><div class="line">"eslint.run": "onType",</div><div class="line"></div><div class="line">// Turns auto fix on save on or off.</div><div class="line">"eslint.autoFixOnSave": false,</div></pre></td></tr></table></figure>
<p>可以开启 ESLint 检查, 同时在项目目录创建配置文件即可, 之后 ESLint 会自动运行进行检查. 你还可以设置保存时自动修复, 我前面那段配置中注释写明 <code>auto</code> 的表示可以自动修复. 怎么样, 是不是很强大.</p>
<p>不过美中不足的是 VSCode 的 ESLint 貌似还不能检查 HTML 文件中的 JavaScript 代码, 导致我的 vue 文件不能被检查到, 希望后续更新的版本可以解决这个问题吧.</p>
<p>前段时间使用了一阵子 VIM, VIM 快捷键在熟悉了之后用起来确实方便很多, 并且 VIM 插件也非常强大, 占用内存也低. 以前用 WebStorm 写代码动不动 1G 内存以上…</p>
<p>现在用的比较多的就是 VSCode 了, VSCode 还自带了 TypeScript 的支持, 不过目前还没有学习 TypeScript 的打算, 感觉 VSCode 就是微软为前端开发而专门准备的, 不负众望真心好用.</p>
<p>前后端语言统一, 带来了包统一, 比如前后端都可以使用 underscore 等类库, 代码统一, 比如前后端可以共用一段输入检测代码, 工具链统一, 比如前后端都可以使用 ESLint 进行代码风格检查. 真的是非常棒的一种体验.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一些多人参与的项目开发中, 每个人代码习惯不同, 对于缩进, 有人习惯 TAB, 有人习惯两个空格, 有人习惯四个空格. 对于分号, 有人不加, 有人习惯加, 而习惯加分号的人又会经常漏加分号. 试想一个项目代码如果由各种群魔乱舞的风格组成, 这必然会带来一定的视觉障碍(强迫症的人看了受不了=.=), 并且显得代码质量低下.&lt;/p&gt;
&lt;p&gt;即使是个人, 偶尔也会写出一些不太规范的代码, 比如变量声明了未使用, 比如使用了 &lt;code&gt;==&lt;/code&gt; 等等, 更不要说各种代码格式如操作符左右空格, &lt;code&gt;if ... else&lt;/code&gt; 的格式, 末行换行等等. 特别是像有强迫症的我, 有时候写的过程可能会不小心遗漏或写错, 但发现的时候又会去改过来. 如果能在书写过程中检查出不规范的地方提示岂不是最好?&lt;/p&gt;
&lt;p&gt;ESLint 是一个插件化的 JavaScript 代码检查工具, 可以用于检查常见的 JavaScript 代码错误, 规范 JavaScript 代码的书写, 可以有效控制代码的质量. &lt;/p&gt;
&lt;img src=&quot;/2016/11/08/使用-ESLint-规范你的代码/eslint.jpg&quot; alt=&quot;eslint.jpg&quot; title=&quot;eslint.jpg&quot;&gt;
&lt;h2 id=&quot;ESLint-规则&quot;&gt;&lt;a href=&quot;#ESLint-规则&quot; class=&quot;headerlink&quot; title=&quot;ESLint 规则&quot;&gt;&lt;/a&gt;ESLint 规则&lt;/h2&gt;&lt;p&gt;ESLint 使用非常简单, 安装好 ESLint 后, 可以自定义一套规则文件或者使用开源的代码风格规范, 像 Google, Airbnb 都有开源的 JavaScript 代码书写规范. 可以直接使用它们的, 也可以自己配置.&lt;/p&gt;
&lt;p&gt;具体的用法可以参考官方文档, 其实蛮简单的.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://eslint.cn/docs/rules/&quot;&gt;这里&lt;/a&gt;列出了 ESLint 的各种规则, 可以参考下这里的说明.&lt;/p&gt;
&lt;p&gt;以下是我个人配置的规则&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://ruiming.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="ESlint" scheme="https://ruiming.github.io/tags/ESlint/"/>
    
  </entry>
  
  <entry>
    <title>拥抱 vue 和 vuex</title>
    <link href="https://ruiming.github.io/2016/11/05/%E6%8B%A5%E6%8A%B1%20vue%20%E5%92%8C%20vuex/"/>
    <id>https://ruiming.github.io/2016/11/05/拥抱 vue 和 vuex/</id>
    <published>2016-11-05T15:18:43.000Z</published>
    <updated>2016-11-05T15:32:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近一段时间写了两个玩意, 一个是基于 PEG.js 的 XML Parser, 前面有一条博客说了 PEG.js 这东西, 事后自己也模仿着写出了这个 XML 解析器, 感觉并不难, 写着玩玩而已.</p>
<p>另外, 最近花时间特别多的另一件事就是写了一个 RSS 订阅器. 一开始写这个订阅器, 心想上一个项目代码不忍直视, 感觉自己需要写一些能拿出手的代码, 加上学校课程刚好要求做一些东西, 以及自己最近迷上了使用 RSS 订阅器这个东西(这么多理由=.=), 于是就自己动工开搞.</p>
<p>目前订阅器已经基本完工了, RSS 订阅器的网址是 <a href="https://www.enjoyrss.com" target="_blank" rel="external">www.enjoyrss.com</a>, 项目开源在 <a href="https://github.com/ruiming/rss" target="_blank" rel="external">Github</a> 上面, 对于对 RSS 有兴趣或者想学习 Vue2, Vuex 或 Angular1 的人可能会有一些帮助. 额对了, 还有就是后端用的是 Koa2, 前后端鉴权专门在上一篇博客提了下, 想了解 Koa2 的人也可以看下.</p>
<h2 id="数据流动问题"><a href="#数据流动问题" class="headerlink" title="数据流动问题"></a>数据流动问题</h2><p>其实每次做一个新的东西的时候, 我都会尽量尝试去使用各种新的技术和用法. 这样才能学到更多的东西. 在这个 RSS 订阅器中, 一开始我只是把自己认为的各种 Angular 最佳实践在项目中都运用了下, 想写出能够体现自己 Angular 水平的代码, 为此前面还写了一篇博客说一些我认为的哪些算是最佳实践. 但其实, 对 Angular 使用已经相当熟悉的我, 并没有在这一次中收获什么新的知识. 要说有, 大概就是前面那博客提到的一些 Angular 最新版本的一些新特性例如 Component 之类的吧, 然而自己并没有花时间去看.</p>
<p>在这个项目中, 另外的一点感受就是 Angular 的跨组件通信难题. 确切的说我觉得这个项目并不适合使用 Angular 来写. 例如</p>
<img src="/2016/11/05/拥抱%20vue%20和%20vuex/website.png" alt="website.png" title="website.png">
<p>左边有一个订阅源栏, 它的未读数量要相应右侧的点击文章, 标记全部已读等事件. 它的订阅源列表也要对右侧的订阅和取消订阅事件做出相应. 为了缩减频繁的跨组件通信, 我将下方状态栏直接拆分成三条, 由各自的组件提供其状态栏覆盖原默认只有背景色的状态栏. 但跨组件通信仍然存在, 单单左侧面板就存在着五个事件监听.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$scope.$on(<span class="string">'EXPAND'</span>, () =&gt; vm.expand = !vm.expand)</div><div class="line">$scope.$on(<span class="string">'FOLD'</span>, () =&gt; vm.expand = <span class="literal">false</span>)</div><div class="line">$scope.$on(<span class="string">'ADD_FEED'</span>, (event, data) =&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (vm.feeds.default) &#123;</div><div class="line">    vm.feeds.default.push(data)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    vm.feeds[<span class="string">'default'</span>] = [data]</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">$scope.$on(<span class="string">'DELETE_FEED'</span>, (event, data) =&gt; &#123;</div><div class="line">  vm.feeds = _.mapObject(vm.feeds, feeds =&gt; feeds = _.filter(feeds, feed =&gt; feed.feed_id !== data.feed_id))</div><div class="line">&#125;)</div><div class="line">$scope.$on(<span class="string">'READ_POST'</span>, (event, data) =&gt; &#123;</div><div class="line">  vm.feeds = _.mapObject(vm.feeds, feeds =&gt; _.each(feeds, feed =&gt; feed.feed_id === data ? feed.unread-- : <span class="string">''</span>))</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>我需要监听折叠事件, 这个动作在其他组件被触发. 需要监听添加订阅源和取消订阅源事件, 并修改订阅源列表. 需要监听已读事件, 并对相应订阅源的未读文章数做减1操作…</p>
<p>在有些应用场景, 存在着需要大量父子组件通信, 兄弟组件通信, 以及没有父子和兄弟关系的组件之间的通信的行为, 这种时候, Angular 虽然也能解决, 但是不得不说 Angular 这种频繁的跨组件通信很容易产生问题, 特别是当一个组件可以被多个组件修改的时候.</p>
<a id="more"></a>
<p>Angular 是双向数据绑定, 现在也有一种叫单向数据流的思想很火.</p>
<img src="/2016/11/05/拥抱%20vue%20和%20vuex/flow.png" alt="flow.png" title="flow.png">
<p>当多个视图依赖同一份状态, 一个状态可能受到多个视图的动作改变的时候, 数据流动就会开始变得混乱起来, 而在这个单向数据流里面, <code>state</code> 是我们的数据, <code>view</code> 是我们的视图, <code>actions</code> 是触发数据更改的可能方式. 试想, 如果我们把整个应用的数据都提取出来存放在一棵树里面, 组件的数据从该树获得, 而这个组件想要修改数据时, 就得通过另外一个东西即 <code>actions</code> 来触发 <code>state</code> 的更改, 而 <code>state</code> 的更改又自动同步的影响组件的数据. 这样的话, 上面我们说的那些问题会变得非常容易解决起来, 如果你还理解不了的话, 可以看下我后面怎么说的.</p>
<h2 id="Angular-的应用场景"><a href="#Angular-的应用场景" class="headerlink" title="Angular 的应用场景"></a>Angular 的应用场景</h2><p>既然有 Angular 做不太来的事, 那么 Angular 到底适合用来做什么, 不适合做什么呢? 关于这点, 由于我没有接触真正的项目开发, 我只能谈谈自己的一些个人看法</p>
<h3 id="Angular-的适用场景"><a href="#Angular-的适用场景" class="headerlink" title="Angular 的适用场景"></a>Angular 的适用场景</h3><p>首先, 结论是 Angular 最适合用来做 CRUD 类型的针对桌面浏览器端的单页面应用(SPA)</p>
<h4 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h4><p>CRUD 即 Create, Read, Update, Delete. CRUD 类型, 即应用涉及的数据查询更改较为频繁的应用. 得益于双向绑定机制, 我们不需要做任何处理就可以实现 View 和 ViewModel 的同步, 我们只要在 View 层使用 <code>ngModel</code> 绑定变量, 就可以在控制器里直接使用它而无需担心它的值是否是我们需要的最新的值. 在 CRUD 应用中我们使用 Angular 这一类 MVVM 框架开发就会非常舒畅. 如果你不能感受到, 那么你可以试试用 React 去写一个表单的管理, 你需要监听每个 input 上面的 onChange 事件, 然后通过 setState 来修改, 并最终在该组件中更新修改. 相比起来, <code>ngModel</code> 简单得不能再简单了. 另外, 我们可以直接在 HTML 中使用诸如 <code>ng-show</code>, <code>ng-repeat</code> 等一类指令, 简单粗暴. 数据的变化和显示都变得非常简单.</p>
<h4 id="桌面浏览器端"><a href="#桌面浏览器端" class="headerlink" title="桌面浏览器端"></a>桌面浏览器端</h4><p>之所以要特别提着一点, 是因为 Angular 体积不小. 这个 RSS 订阅器我桌面浏览器端用 Angular1 开发, 移动端用 Vue2 开发, 都做了打包压缩操作, 开启了 Gzip, 最后情况是 Angular 需要加载的 JS 以及各种辅助类库加起来在 250KB 左右. </p>
<img src="/2016/11/05/拥抱%20vue%20和%20vuex/Angular.png" alt="Angular.png" title="Angular.png">
<p>而 Vue 只要 100KB 左右(图中的 build.js 文件合并了CSS文件), 不到 Angular 一半的大小.</p>
<img src="/2016/11/05/拥抱%20vue%20和%20vuex/vue.png" alt="vue.png" title="vue.png">
<p>当然, Angular 体积大是有原因的, 它本身就是一套大而全的框架, 拿体积和 Vue 说事是不太合适的. Vue 非常轻, 专注于 View 这一层, 而 Angular 自带了路由, 内置了 HTTP 的处理模块, 内置了 promise, 还集成了一个简化版的 jq… 如果你刚好 Angular 这些东西你都要用到, 那么 Angular 也是一个不错的选择了, 但如果你只是用到它的一部分或一点点功能并且你追求文件大小, 那么你可能要考虑一下.</p>
<h4 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h4><p>这点没什么好说的, Angular 就是为这个而生的. Angular1 目前在全球中还是有很多的市场, 并且由于 Angular1 已经相当成熟稳定, 社区支持活跃, 而且是 Google 在维护, 估计未来几年仍然会由较大规模的应用, 目前国内有饿了么移动端, 微信网页版以及七牛, Coding 等在使用,</p>
<p>感觉说了一通废话, 还是看看 Google 怎么说的吧.</p>
<p>Google 在 AngularJS 下批注的是 “HTML enhanced for web apps!”</p>
<img src="/2016/11/05/拥抱%20vue%20和%20vuex/AngularJS.png" alt="AngularJS.png" title="AngularJS.png">
<p>下方有说明 Why AngularJS?</p>
<blockquote>
<p>HTML is great for declaring static documents, but it falters when we try to use it for declaring dynamic views in web-applications. AngularJS lets you extend HTML vocabulary for your application. The resulting environment is extraordinarily expressive, readable, and quick to develop.</p>
</blockquote>
<p>其实感觉还不如我说的明白 =.=</p>
<h3 id="Angular-的不适用场景"><a href="#Angular-的不适用场景" class="headerlink" title="Angular 的不适用场景"></a>Angular 的不适用场景</h3><p>个人认为, Angular 在下面几点场景中不合适</p>
<ul>
<li><p>移动端</p>
<p>其实 Angular 开发起移动端的 Webapp 很合适, 就是 Angular 的体积不太合适… 过去的可能要考虑迁移的成本以及必要性, 新的可能需要考虑下更合适的选项比如 Vue. 感觉在未来的移动端 Webapp 上面, Angular 的市场会逐渐降低</p>
</li>
<li><p>跨组件通信频繁</p>
<p>当你写的 Angular 应用中涉及较多的跨组件通信的时候, 你就应该考虑这个用 Angular 是不是真的合适了. 当然其实这个事情应该在最开始的时候就该考虑清楚了. 跨组件通信的问题在 Flux 中并不存在, Flux 能够轻松应对这种问题</p>
</li>
</ul>
<h3 id="谈谈-Vue-js"><a href="#谈谈-Vue-js" class="headerlink" title="谈谈 Vue.js"></a>谈谈 Vue.js</h3><p>订阅器移动端我用 Vue.js 来做. 接触了 Angular, 学起 Vue 也特别轻松, 三两下就搞定了 Vue 和 Vue-resource. Vue 和 Angular 的相似度比我想象的还要高, 像 vue-resource 这个和 ngresource 用起来没啥区别.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ng-resource</span></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    angular</div><div class="line">        .module(<span class="string">'app'</span>)</div><div class="line">        .factory(<span class="string">'User'</span>, $resource =&gt; &#123;</div><div class="line">            <span class="keyword">return</span> $resource(<span class="string">'/api/user'</span>, &#123;&#125;, &#123;</div><div class="line">                <span class="attr">update</span>: &#123;</div><div class="line">                    <span class="attr">method</span>: <span class="string">'PUT'</span></div><div class="line">                &#125;,</div><div class="line">                <span class="attr">logout</span>: &#123;</div><div class="line">                    <span class="attr">method</span>: <span class="string">'POST'</span>,</div><div class="line">                    <span class="attr">url</span>:    <span class="string">'/auth/logout'</span></div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">        &#125;)</div><div class="line">&#125;())</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// vue-resource</span></div><div class="line"><span class="keyword">const</span> User = Vue.resource(<span class="string">'/api/user'</span>, &#123;&#125;, &#123;</div><div class="line">    <span class="attr">update</span>: &#123;</div><div class="line">        <span class="attr">method</span>: <span class="string">'PUT'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">logout</span>: &#123;</div><div class="line">        <span class="attr">method</span>: <span class="string">'POST'</span>,</div><div class="line">        <span class="attr">url</span>:    <span class="string">'/auth/logout'</span></div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">export</span> User</div></pre></td></tr></table></figure>
<p>(⊙o⊙)… 我直接复制粘贴过去都 OK 了…</p>
<p>另外, 像 <code>v-show</code> 和 <code>ng-show</code> ,<code>v-for</code> 和 <code>ng-for</code> 之类的就更不用多说了.</p>
<p>但是, 不得不说一点, Vue 做的更好.</p>
<p>例如, Vue 可以把 <code>v-for</code> 提出来</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; item.msg &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"divider"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line">&lt;<span class="regexp">/ul&gt;</span></div></pre></td></tr></table></figure>
<p>例如, Vue 可以使用 <code>v-else</code> </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;div v-if="Math.random() &gt; 0.5"&gt;</div><div class="line">  Sorry</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;div v-else&gt;</div><div class="line">  Not sorry</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>虽然 Angular 也可以做这些事, 但是我说了, Vue 做的更好.</p>
<p>当然了, Vue 不完全是在 Angular 上面重造轮子, Vue2 引入了虚拟 DOM, 又轻又快, 虽然 Vue 可以像 Angular 一样写 MVVM 应用. 但我个人更喜欢 Vuex 即 Flux 的写法, 这个后面我会说.</p>
<p>在使用 Vue 的过程中, 有几点感受特别深.</p>
<p>例如, 在 Vue 中, 当我在 <code>/post/123</code> 中跳到 <code>/post/456</code> 时, 我发现虽然路径变化了, 但是页面根本没重新渲染. 这对于从 Angular 过来或者说第一次接触 Vue 的人来说应该感觉一脸懵逼.</p>
<p>当然, 很快就查找到了答案, Vue 要求我们手动去更新数据. 至于为什么这么做, 是因为 Vue 可以在我们获取新数据后在原 DOM 上面做最小的修改, 这种修改的成本自然会比整个页面的销毁和重绘要节能和迅速的多. Vue 配合虚拟 DOM 技术可以比对找出最小的修改, 使得 DOM 的修改成本降到最低, 这大概就是 React 和 Vue 在视图上面更新之高效的秘诀了.</p>
<p>不过可能有人会问了, 这样不会很麻烦吗, 要手动监听路由变化然后重新获取数据. 感觉也还好其实, 例如下面这个例子, 这个例子在后面会进行分析.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    <span class="attr">computed</span>: mapGetters(&#123;</div><div class="line">        <span class="attr">post</span>: <span class="string">'post'</span></div><div class="line">    &#125;),</div><div class="line"></div><div class="line">    <span class="keyword">async</span> beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</div><div class="line">        <span class="keyword">await</span> store.dispatch(<span class="string">'getPost'</span>, to.params.id)</div><div class="line">        <span class="keyword">await</span> store.dispatch(<span class="string">'read'</span>)</div><div class="line">        next()</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">watch</span>: &#123;</div><div class="line">        <span class="keyword">async</span> <span class="string">'$route'</span> (to, <span class="keyword">from</span>) &#123;</div><div class="line">            <span class="keyword">await</span> store.dispatch(<span class="string">'getPost'</span>, to.params.id)</div><div class="line">            <span class="keyword">await</span> store.dispatch(<span class="string">'read'</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    </div><div class="line">    <span class="attr">components</span>: &#123;</div><div class="line">        headbar, postOption</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到 watch 的部分和 beforeRoute 的部分重复了, Vue 给的说法好像是封装为一个函数来执行, 我感觉还好, 就这样子算了…</p>
<p>上面都是 Vuex 的写法, 其实最开始我还是按 MVVM 那一套写法写的, 写完了之后才开始改到 Vuex 上面去.</p>
<p>另外, Vue 的动画和过渡效果虽然和 Angular 也是很像, 但比 Angular 强大很多. 再者 Vue 支持服务端渲染, 服务端渲染好不好用我不知道, 但确实解决了一些问题.</p>
<p>另外, 还有很多很不错的一些技巧啊, 比如 slot 这个超实用感觉. 不过我只是简单的用了下而已.</p>
<p>例如我定义了这样一个组件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"head"</span> <span class="attr">v-bind:class</span>=<span class="string">"&#123;expand2: expand&#125;"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-paragraph-left"</span> <span class="attr">v-on:click</span>=<span class="string">"move()"</span> &gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">slot</span>&gt;</span>主页<span class="tag">&lt;/<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="keyword">import</span> &#123; mapGetters, mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    <span class="attr">computed</span>: mapGetters(&#123;</div><div class="line">        <span class="attr">expand</span>: <span class="string">'expand'</span>,</div><div class="line">        <span class="attr">user</span>: <span class="string">'user'</span></div><div class="line">    &#125;),</div><div class="line">    </div><div class="line">    <span class="attr">methods</span>: &#123;</div><div class="line">        <span class="attr">move</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.expand) &#123;</div><div class="line">                <span class="keyword">this</span>.$store.commit(<span class="string">'COLLAPSE'</span>)</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">this</span>.$store.commit(<span class="string">'EXPAND'</span>)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"sass"</span>&gt;</span><span class="undefined"></span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这里省去 CSS 样式, 反正放出来也没用, 做好这样一个组件之后, 下面这样用的结果</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- src --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">headbar</span>&gt;</span>文章<span class="tag">&lt;/<span class="name">headbar</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- dist --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-paragraph-left"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>文章<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果 <code>headbar</code> 里面不加任何东西, 那就会使用默认的值主页. slot 可以使用多个, 可以编号. 具体的用法可以查看官方文档, 貌似 Angular 也有类似的东西, 没了解过…</p>
<p>上面的例子中你可能注意到了, 我把 CSS, HTML, JavaScript 都写到了一起去了, 这就是 Vue 的 vue 单文件写法. 比起 Angular 里面我要建立一个文件夹, 文件夹里面放模板, 控制器, 样式表的做法, 我更喜欢 Vue 的做法, 特别好用, 当然了 vue 文件的编译依赖于 webpack. 我们还可以在 vue 文件中使用 pug 来书写 html, 使用 ts 来书写 vue, 使用 sass 来书写 css, 好用到爆.</p>
<p>估计再也回不去 Angular 了…</p>
<h3 id="谈谈-Vuex"><a href="#谈谈-Vuex" class="headerlink" title="谈谈 Vuex"></a>谈谈 Vuex</h3><p>我要单独把 Vuex 拿出来说一说, 因为它真的太好用了.</p>
<p>首先, 什么是 Vuex?</p>
<blockquote>
<p>Vuex 是一个专门为 Vue.js 应用设计的 <strong>状态管理模型 + 库</strong>。它为应用内的所有组件提供集中式存储服务，其中的规则确保状态只能按预期方式变更。它可以与 Vue 官方<a href="https://github.com/vuejs/vue-devtools" target="_blank" rel="external">开发工具扩展(devtools extension)</a> 集成，提供高级特征，比如 零配置时空旅行般（基于时间轴）调试，以及状态快照 导出/导入。</p>
</blockquote>
<p>可以看看<a href="https://vuex.vuejs.org/en/intro.html" target="_blank" rel="external">官方文档</a>的说明</p>
<p>Vuex 和 Flux 类似, 大概可以用下面这个图来表示</p>
<img src="/2016/11/05/拥抱%20vue%20和%20vuex/vuex.png" alt="vuex.png" title="vuex.png">
<p>一次完整的 vuex 数据流动大概如下:</p>
<ul>
<li><p>vue 组件通过 dispatch 一个 actions 或者直接 commit 一次 mutations 来间接修改 state. </p>
<p>通常我们在进入一个页面的时候, 需要获取一些请求资源, 我们可以通过 beforeRouteEnter 钩子在路由进入前获取数据, 例如(省去了部分代码):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// post.vue</span></div><div class="line"><span class="keyword">async</span> beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</div><div class="line">  <span class="keyword">await</span> store.dispatch(<span class="string">'getPost'</span>, to.params.id)</div><div class="line">  <span class="keyword">await</span> store.dispatch(<span class="string">'read'</span>)</div><div class="line">  next()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在路由进入前, 触发了一个 <code>getPost</code> 事件.</p>
</li>
<li><p>actions 处理数据逻辑</p>
<p>专门定义一个文件负责处理 actions, 在 Vue 中, actions 是用来处理异步的, 例如这个 getPost 事件:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// actions.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> getPost = <span class="function">(<span class="params">&#123; commit &#125;, id</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> Post.get(&#123;</div><div class="line">        id</div><div class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</div><div class="line">        commit(types.RECEIVE_POST, res.data.data)</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取到数据后, commit 一次修改, 这里使用了常量名, 其实对应的就是 <code>RECEIVE_POST</code> 这个字符串, 我们新建一个类型文件专门处理 mutations 的常量名和字符串的映射. 这主要是为了书写方便和重构方便吧我猜, 其实在 Redux 我们也是类似的处理.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// mutation-types.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> RECEIVE_POST = <span class="string">'RECEIVE_POST'</span></div></pre></td></tr></table></figure>
</li>
<li><p>module 接收 mutation 并处理</p>
<p>module 是为了更合理的划分 store, 这点和 redux 一样. 其用法和 redux 也是很相像的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// post.js</span></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> types <span class="keyword">from</span> <span class="string">'../mutation-types'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> state = &#123;</div><div class="line">    <span class="attr">post</span>: &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> mutations = &#123;</div><div class="line">    <span class="comment">// 获取文章信息</span></div><div class="line">    [types.RECEIVE_POST](state, post) &#123;</div><div class="line">        state.post = post</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    state,</div><div class="line">    mutations</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自此, 我们就完成了一次更新 state 操作.</p>
</li>
<li><p>通过 getters 获取数据</p>
<p>那数据更新是更新了, 怎么用呢, 这时候就要依靠 getters 了.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// getters.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> post = <span class="function"><span class="params">state</span> =&gt;</span> state.post.post</div></pre></td></tr></table></figure>
<p>就一句话就可以了, 但这只是简单的获取数据而已, 你也可以在里面对数据进行一些处理, 比如过滤, 排序之类的, 但要注意, 不能修改原 state 上面的数据. 这点和 redux 又是一致的.</p>
</li>
</ul>
<p>最后完整的一个组件的 JS 部分就是这样:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Post &#125; <span class="keyword">from</span> <span class="string">'../resource/resource.js'</span></div><div class="line"><span class="keyword">import</span> headbar <span class="keyword">from</span> <span class="string">'../components/headbar.vue'</span></div><div class="line"><span class="keyword">import</span> postOption <span class="keyword">from</span> <span class="string">'../components/post-option.vue'</span></div><div class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'../store'</span></div><div class="line"><span class="keyword">import</span> &#123; mapGetters, mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    <span class="attr">computed</span>: mapGetters(&#123;</div><div class="line">        <span class="attr">post</span>: <span class="string">'post'</span></div><div class="line">    &#125;),</div><div class="line"></div><div class="line">    <span class="keyword">async</span> beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</div><div class="line">        <span class="keyword">await</span> store.dispatch(<span class="string">'getPost'</span>, to.params.id)</div><div class="line">        <span class="keyword">await</span> store.dispatch(<span class="string">'read'</span>)</div><div class="line">        next()</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">watch</span>: &#123;</div><div class="line">        <span class="keyword">async</span> <span class="string">'$route'</span> (to, <span class="keyword">from</span>) &#123;</div><div class="line">            <span class="keyword">await</span> store.dispatch(<span class="string">'getPost'</span>, to.params.id)</div><div class="line">            <span class="keyword">await</span> store.dispatch(<span class="string">'read'</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    </div><div class="line">    <span class="attr">components</span>: &#123;</div><div class="line">        headbar, postOption</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过 mapGetters 和 mapActions 我们可以很方便的绑定 acitons 和 getters.</p>
<p>上面还有个地方没说的就是 read 这个事件, 它还有一个和 getPost 事件很大区别的地方, 在于它会触发多个 state 的修改.</p>
<p>结合 vuex, 我已经轻松的实现了最近未读文章, 订阅源列表, 收藏文章, 广场热门订阅源的缓存自动更新从而实现了这四个页面只要一次请求. 可以访问<a href="https://www.enjoyrss.png" target="_blank" rel="external">网站</a>体验下.</p>
<img src="/2016/11/05/拥抱%20vue%20和%20vuex/enjoyrss.png" alt="enjoyrss.png" title="enjoyrss.png">
<p>就未读而言, 首屏这里就由未读信息的显示了, 当我们进入一篇文章时, 触发了 read 这个 actions, 这个 action 只是做一个异步的 http 请求操作, 然后触发一个 mutation. 关键的地方是我们需要在 posts.js 这个文件中也监听这个 mutation , 然后对其 state 进行操作. 注意这里说的是 posts.js 而不是 post.js.</p>
<p>再换个例子, 取消订阅, 当用户在一个订阅源处点击取消订阅时, 由 action 发出的 mutation, 我们需要最近未读那里移除这个订阅源, 需要订阅源列表也移除这个订阅源, 需要广场那里热门订阅源的这个订阅源的订阅人数减一. 并且要注意的是, 这些对象是分开的. 在 vuex 中, 我们只要注意 payload 即 muitations 的传递数据以及在对应需要修改的 module 中监听 mutation 就好了. 这是非常自然的事情. 换做 Angular, 各种 on 和 emit 以及 broadcast 的能忍? 并且 vuex 提供了状态管理, 但是 angular 没有, 我们要自己缓存数据, 然后要去修改缓存, 这些在 angular 里面写起来特别不优雅.</p>
<p>本来还想对比以下 vuex 和 redux, 但由于篇幅有限, 加之我经验还不足, 且 redux 已经忘得差不多且没有重拾欲望, 想要了解下 redux 可以看看我这篇<a href="https://ruiming.github.io/2016/08/01/%E8%B0%88%E8%B0%88React%E5%92%8CRedux/">博客</a>. vuex 也是 flux 的实现, 而且也是和 redux 一样采用单一的一棵状态管理, 因此两者自然由很多相似之处.</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>昨晚班游轰趴, 才睡了三个多钟, 中午补了四个小时觉, 写了这么多我感觉已经快撑不下去了, 其实我个人一直都认为要多做少说, 我不喜欢和人争论技术, 因为我觉得自己很菜很容易说错话, 虽然意识到错误了我可以去学习这是一种提升, 但那也只是在对方意识到你错的时候, 不然就很容易误导别人了, 博客也一样, 我写博客更多就是为了记录一下, 可能也存在很多错误的地方.</p>
<p>用了 Vue 之后, 感觉再也不会去用 Angular 了, 至于 Angular2, 额, 还是再看吧 =.=</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一段时间写了两个玩意, 一个是基于 PEG.js 的 XML Parser, 前面有一条博客说了 PEG.js 这东西, 事后自己也模仿着写出了这个 XML 解析器, 感觉并不难, 写着玩玩而已.&lt;/p&gt;
&lt;p&gt;另外, 最近花时间特别多的另一件事就是写了一个 RSS 订阅器. 一开始写这个订阅器, 心想上一个项目代码不忍直视, 感觉自己需要写一些能拿出手的代码, 加上学校课程刚好要求做一些东西, 以及自己最近迷上了使用 RSS 订阅器这个东西(这么多理由=.=), 于是就自己动工开搞.&lt;/p&gt;
&lt;p&gt;目前订阅器已经基本完工了, RSS 订阅器的网址是 &lt;a href=&quot;https://www.enjoyrss.com&quot;&gt;www.enjoyrss.com&lt;/a&gt;, 项目开源在 &lt;a href=&quot;https://github.com/ruiming/rss&quot;&gt;Github&lt;/a&gt; 上面, 对于对 RSS 有兴趣或者想学习 Vue2, Vuex 或 Angular1 的人可能会有一些帮助. 额对了, 还有就是后端用的是 Koa2, 前后端鉴权专门在上一篇博客提了下, 想了解 Koa2 的人也可以看下.&lt;/p&gt;
&lt;h2 id=&quot;数据流动问题&quot;&gt;&lt;a href=&quot;#数据流动问题&quot; class=&quot;headerlink&quot; title=&quot;数据流动问题&quot;&gt;&lt;/a&gt;数据流动问题&lt;/h2&gt;&lt;p&gt;其实每次做一个新的东西的时候, 我都会尽量尝试去使用各种新的技术和用法. 这样才能学到更多的东西. 在这个 RSS 订阅器中, 一开始我只是把自己认为的各种 Angular 最佳实践在项目中都运用了下, 想写出能够体现自己 Angular 水平的代码, 为此前面还写了一篇博客说一些我认为的哪些算是最佳实践. 但其实, 对 Angular 使用已经相当熟悉的我, 并没有在这一次中收获什么新的知识. 要说有, 大概就是前面那博客提到的一些 Angular 最新版本的一些新特性例如 Component 之类的吧, 然而自己并没有花时间去看.&lt;/p&gt;
&lt;p&gt;在这个项目中, 另外的一点感受就是 Angular 的跨组件通信难题. 确切的说我觉得这个项目并不适合使用 Angular 来写. 例如&lt;/p&gt;
&lt;img src=&quot;/2016/11/05/拥抱%20vue%20和%20vuex/website.png&quot; alt=&quot;website.png&quot; title=&quot;website.png&quot;&gt;
&lt;p&gt;左边有一个订阅源栏, 它的未读数量要相应右侧的点击文章, 标记全部已读等事件. 它的订阅源列表也要对右侧的订阅和取消订阅事件做出相应. 为了缩减频繁的跨组件通信, 我将下方状态栏直接拆分成三条, 由各自的组件提供其状态栏覆盖原默认只有背景色的状态栏. 但跨组件通信仍然存在, 单单左侧面板就存在着五个事件监听.&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$scope.$on(&lt;span class=&quot;string&quot;&gt;&#39;EXPAND&#39;&lt;/span&gt;, () =&amp;gt; vm.expand = !vm.expand)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$scope.$on(&lt;span class=&quot;string&quot;&gt;&#39;FOLD&#39;&lt;/span&gt;, () =&amp;gt; vm.expand = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$scope.$on(&lt;span class=&quot;string&quot;&gt;&#39;ADD_FEED&#39;&lt;/span&gt;, (event, data) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (vm.feeds.default) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    vm.feeds.default.push(data)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    vm.feeds[&lt;span class=&quot;string&quot;&gt;&#39;default&#39;&lt;/span&gt;] = [data]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$scope.$on(&lt;span class=&quot;string&quot;&gt;&#39;DELETE_FEED&#39;&lt;/span&gt;, (event, data) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  vm.feeds = _.mapObject(vm.feeds, feeds =&amp;gt; feeds = _.filter(feeds, feed =&amp;gt; feed.feed_id !== data.feed_id))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$scope.$on(&lt;span class=&quot;string&quot;&gt;&#39;READ_POST&#39;&lt;/span&gt;, (event, data) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  vm.feeds = _.mapObject(vm.feeds, feeds =&amp;gt; _.each(feeds, feed =&amp;gt; feed.feed_id === data ? feed.unread-- : &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我需要监听折叠事件, 这个动作在其他组件被触发. 需要监听添加订阅源和取消订阅源事件, 并修改订阅源列表. 需要监听已读事件, 并对相应订阅源的未读文章数做减1操作…&lt;/p&gt;
&lt;p&gt;在有些应用场景, 存在着需要大量父子组件通信, 兄弟组件通信, 以及没有父子和兄弟关系的组件之间的通信的行为, 这种时候, Angular 虽然也能解决, 但是不得不说 Angular 这种频繁的跨组件通信很容易产生问题, 特别是当一个组件可以被多个组件修改的时候.&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://ruiming.github.io/categories/Vue/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="Koa" scheme="https://ruiming.github.io/tags/Koa/"/>
    
      <category term="Vue" scheme="https://ruiming.github.io/tags/Vue/"/>
    
      <category term="Vuex" scheme="https://ruiming.github.io/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>关于前后端分离鉴权的思考</title>
    <link href="https://ruiming.github.io/2016/10/14/%E5%85%B3%E4%BA%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%89%B4%E6%9D%83%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://ruiming.github.io/2016/10/14/关于前后端分离鉴权的思考/</id>
    <published>2016-10-14T11:29:05.000Z</published>
    <updated>2016-11-16T16:04:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>前后端分离项目的 Token 存储问题由来已久，有的人存 Cookie 有的人存 LocalStorage 或 SessionStorage，最近刚把 RSS 订阅器项目的鉴权问题做好，感觉算是目前比较稳妥安全的方案了，分享一下经验。</p>
<p>前端用的是 Angular，后端用的是 Koa，登录注册界面由 Koa 负责，由 Koa 根据用户是否登录来决定首页跳转。我不会一开始就讲我的做法，而是循序渐进的从传统的存储方式逐渐过渡到我的做法当中来。</p>
<h2 id="如何安全的传输用户-token"><a href="#如何安全的传输用户-token" class="headerlink" title="如何安全的传输用户 token"></a>如何安全的传输用户 token</h2><p>这是最传统也是最简单的方式了，前端登录，后端根据用户信息生成一个 token，并保存这个 token 和对应的用户 id，接着把 token 传给用户，存入浏览器 cookie，之后浏览器请求带上这个 cookie，后端根据这个 cookie 来标识用户。</p>
<img src="/2016/10/14/关于前后端分离鉴权的思考/flow-cookie-session.jpg" alt="flow-cookie-session" title="flow-cookie-session">
<p>但这样做问题就很多，如果我们的页面出现了 XSS 漏洞，由于 cookie 可以被 JavaScript 读取，XSS 漏洞会导致用户 token 泄露，而作为后端识别用户的标识，cookie 的泄露意味着用户信息不再安全。</p>
<p>尽管我们通过转义输出内容，使用 CDN 等可以尽量避免 XSS 注入，但谁也不能保证在大型的项目中不会出现这个问题。另外，后端每次都需要根据 token 查出用户 id，这就增加了数据库的查询和存储开销。</p>
<p>在设置 cookie 的时候，其实你还可以设置 httpOnly 以及 secure 项。设置 httpOnly 后 cookie 将不能被 JS 读取，浏览器会自动的把它加在请求的 header 当中，设置 secure 的话，cookie 就只允许通过 HTTPS 传输。</p>
<p>secure 选项可以过滤掉一些使用 HTTP 协议的 XSS 注入，但并不能完全阻止。</p>
<p>httpOnly 选项使得 JS 不能读取到 cookie，那么 XSS 注入的问题也基本不用担心了。但设置 httpOnly 就带来了另一个问题，就是很容易的被 XSRF，即跨站请求伪造。当你浏览器开着这个页面的时候，另一个页面可以很容易的跨站请求这个页面的内容。因为 cookie 默认被发了出去。</p>
<img src="/2016/10/14/关于前后端分离鉴权的思考/CSRF.jpg" alt="CSRF" title="CSRF">
<p>看起来我们不能兼顾。确实，光依靠这一个 token 我们没办法兼顾这两点。既然一个不够，那就两个。于是有了 XSRF-TOKEN，它和作为用户令牌的 token 类似，也是服务器生成的一个散列值。我们把 token 通过 httpOnly 发回去，把 XSRF-TOKEN 直接发回去。我们可以无视 httpOnly 的 cookie 因为我们没法操纵它，但对于这个 XSRF-TOKEN，我们就可以在我们网站的每个请求中都加入到 header 里面去。而服务端就需要检查这个 header 的 XSRF-TOKEN 是否真实有效。</p>
<a id="more"></a>
<p>由于 XSRF-TOKEN 以非 httpOnly 的形式存储在 cookie 中，正常情况下只有我们自己的网站可以获取到该 XSRF-TOKEN。这样 XSRF 攻击就变得不太可能了。另外由于用户 token 是通过 httpOnly 形式存储，JS 不可获取，这样也保证了用户 token 的安全。XSS 注入最多只能获取到 XSRF-TOKEN。</p>
<p>但还是有一种可能，XSS 注入取得 XSRF-TOKEN 后在当前页面发送请求出去。本文并不打算讨论 XSRF 和 XSS，明白这两个真正危害的地方就可以知道，这种 XSS 注入取得 XSRF-TOKEN 后发送请求其实并没有带来什么危害。不过呢，还是要看具体情况吧，如果我们的网站有一个投票 XXX 的接口，这个接口的链接被用在 XSS 注入中，那么当所有人打开这个页面的时候，都会自动的朝 XXX 投了一票。</p>
<p>不同于 XSRF， XSRF 可以从其他网站执行该段脚本，而这里只能注入到我们的网站中来执行。因为我们的 JS 也是这样子做的，取出 XSRF-TOKEN 放入请求头部然后发送请求出去，所以这就无法避免了。事实上，由于我们的前端代码都是公开的，无论 JS 层面绕多少个弯，XSS 注入还是可以照着做过来。但好在这种方式其实造成的影响相当有限，并不会比我们常说的 XSS 注入和 XSRF 攻击的危害大，要知道 XSS 注入危害的 cookie 的泄露，但其实这里并没有 cookie 的泄露。</p>
<p>我们再讨论另一个问题，前面也说了，服务器要经常去查询这个 token 对应的是哪一个用户。其实可不可以不要服务器去查询呢？如果我们生成 token 遵循一定的规律，比如我们使用对称加密算法来加密用户 id 形成 token，那么服务端以后其实只要解密该 token 就可以知道用户的 id 是什么了。不过呢，我只是举个例子而已，要是真这么做，只要你的对称加密算法泄露了，所有用户信息都不再安全了。恩，那用非对称加密算法来做呢，由公钥加密生成 token，私钥来解密 token，这样做就安全多了。其实现在有个规范就是这样做的，就是我们接下来要介绍的 JWT。</p>
<h2 id="Json-Web-Token"><a href="#Json-Web-Token" class="headerlink" title="Json Web Token"></a>Json Web Token</h2><p>接下来我们就简单介绍 JWT 这个东西，全称叫 Json Web Token。</p>
<h3 id="JWT-简介"><a href="#JWT-简介" class="headerlink" title="JWT 简介"></a>JWT 简介</h3><p>JWT 是一个开放标准(<a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="external">RFC 7519</a>)，它定义了一种用于简洁，自包含的用于通信双方之间以 JSON 对象的形式安全传递信息的方法。JWT 可以使用 HMAC 算法或者是 RSA 的公钥密钥对进行签名。它具备两个特点：</p>
<ul>
<li><p>简洁(Compact) </p>
<p>可以通过URL, POST 参数或者在 HTTP header 发送，因为数据量小，传输速度快</p>
</li>
<li><p>自包含(Self-contained)</p>
<p>负载中包含了所有用户所需要的信息，避免了多次查询数据库</p>
</li>
</ul>
<h3 id="JWT-组成"><a href="#JWT-组成" class="headerlink" title="JWT 组成"></a>JWT 组成</h3><p>JWT 由 Header, Payload, Signature 三部分组成，即头部，负载，签名，长这样：</p>
<img src="/2016/10/14/关于前后端分离鉴权的思考/jwt.jpeg" alt="jwt" title="jwt">
<ul>
<li><p>Header 头部</p>
<p>头部包含了两部分，token 类型和采用的加密算法</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</div><div class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它会使用 Base64Url 编码组成 JWT 结构的第一部分</p>
</li>
<li><p>Payload</p>
<p>这部分就是我们存放信息的地方了，你可以把用户 ID 等信息放在这里，JWT 规范里面对这部分有进行了比较详细的介绍，常用的由 iss（签发者），exp（过期时间），sub（面向的用户），aud（接收方），iat（签发时间）。这些我们应该规范的使用，因为他们可能是在校验中使用到了（猜测，表示我一个也没用到 =.= ）</p>
<p>例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</div><div class="line">  <span class="attr">"admin"</span>: <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样的，它会使用 Base64Url 编码组成 JWT 结构的第二部分</p>
</li>
<li><p>Signature</p>
<p>前面两部分都是使用 Base64Url 进行编码的，即客户端可以解开知道里面的信息。Signature 需要使用编码后的 header 和 payload 以及我们提供的一个密钥，然后使用 header 中指定的签名算法进行签名。签名的作用是保证 JWT 没有被篡改过。</p>
</li>
</ul>
<p>三个部分通过 <code>.</code> 连接在一起就是我们的 JWT 了，它可能长这个样子：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eyJhbGciOiJIUzI<span class="number">1</span><span class="symbol">NiIsInR5</span>cCI<span class="number">6</span>IkpX<span class="attr">VCJ9</span>.eyJpZCI<span class="number">6</span>IjU<span class="number">3</span>ZmVmMTY<span class="number">0</span>ZTU<span class="number">0</span>YWY<span class="number">2</span><span class="symbol">NGZmYzUzZGJkNSIsInhzcmYiOiI0</span>ZWE<span class="number">1</span>YzUwOGE<span class="number">2</span><span class="symbol">NTY2</span>ZTc<span class="number">2</span>MjQw<span class="symbol">NTQzZjhmZWIwNmZkNDU3</span><span class="symbol">Nzc3</span>YmUzOTU<span class="number">0</span>OW<span class="name">M0</span>MDE<span class="number">2</span><span class="symbol">NDM2</span>YWZkYTY<span class="number">1</span>ZDIzMzBlIiwiaWF<span class="number">0</span>Ijox<span class="symbol">NDc2</span><span class="symbol">NDI3</span>OTMzfQ.PA<span class="number">3</span>QjeyZSUh<span class="number">7</span>H<span class="number">0</span>GfE<span class="number">0</span>vJaKW<span class="number">4</span>LjKJuC<span class="number">3</span>dVLQiY<span class="number">4</span>hii<span class="number">8</span>s</div></pre></td></tr></table></figure>
<p>长度貌似和你的加密算法和私钥有关系。其实到这一步可能就有人会想了，HTTP 请求总会带上 token，这样这个 token 传来传去占用不必要的带宽啊。如果你这么想了，那你可以去了解下 HTTP2，HTTP2 对头部进行了压缩，相信也解决了这个问题。</p>
<h3 id="JWT-使用"><a href="#JWT-使用" class="headerlink" title="JWT 使用"></a>JWT 使用</h3><p>JWT 生成了，怎么使用就看你了，不过还是有一点要求的。当访问需要 JWT 验证的 API 时，需要把该 JWT 放入头部的 Authorization 中</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">Authorization:</span> Bearer <span class="params">&lt;token&gt;</span></div></pre></td></tr></table></figure>
<p>注意 <code>Bearer</code> 是必须的，中间有一个空格，后面跟着 JWT，这样服务端就可以从 Authorization 取出来用了。当然了，你也可以完全爱怎么来就怎么来。但是按照规范你可以省很多事情。</p>
<p>简单的 JWT 流程是这样的，不带 XSRF 的，没有找到带 XSRF 的图 =.=</p>
<img src="/2016/10/14/关于前后端分离鉴权的思考/tokens-new.png" alt="tokens-new" title="tokens-new">
<h2 id="JWT-实践"><a href="#JWT-实践" class="headerlink" title="JWT 实践"></a>JWT 实践</h2><p>刚才前面也说了，前端用的是 Angular，后端用的是 Koa，登录注册界面由 Koa 负责，由 Koa 根据用户是否登录来决定首页跳转。首先要强调下，下面说的不是唯一的方式，也不是最好的方式，而只是我自己这么用了并且我认为挺稳妥的。我在 Koa 中使用了两个模块，<a href="https://github.com/auth0/node-jsonwebtoken" target="_blank" rel="external">jsonwebtoken</a> 和 <a href="https://github.com/koajs/jwt/tree/koa-v2" target="_blank" rel="external">koa-jwt</a>。我以登录为例简单说下整个流程。</p>
<h3 id="登录，生成-JWT"><a href="#登录，生成-JWT" class="headerlink" title="登录，生成 JWT"></a>登录，生成 JWT</h3><p>在说登录的处理之前，我想先强调这个登录页面还是后端(ejs)来渲染的，而不是前端来渲染。这个其实也会影响到我们存储 token 的考虑。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">router.get([<span class="string">'/'</span>, <span class="string">'/login'</span>], <span class="keyword">async</span> (ctx, next) =&gt; &#123;</div><div class="line">    <span class="keyword">if</span>(ctx.cookies.get(<span class="string">'jwt'</span>)) &#123;</div><div class="line">        <span class="keyword">let</span> token = jwt.decode(ctx.cookies.get(<span class="string">'jwt'</span>));</div><div class="line">        <span class="keyword">if</span>(token.id) &#123;</div><div class="line">            <span class="keyword">let</span> result = <span class="keyword">await</span> UserModel.findById(token.id);</div><div class="line">            <span class="keyword">if</span>(result &amp;&amp; result._id) <span class="keyword">await</span> send(ctx, <span class="string">'./public/index.html'</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ctx.cookies.set(<span class="string">'jwt'</span>, <span class="literal">null</span>, &#123;<span class="attr">overwrite</span>: <span class="literal">true</span>, <span class="attr">expires</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;);</div><div class="line">            ctx.render(<span class="string">'login.ejs'</span>, &#123;<span class="attr">err</span>: <span class="string">'JWT 验证失败'</span>&#125;);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">await</span> ctx.render(<span class="string">'login.ejs'</span>);  </div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当用户访问网站主页或者登录页面的时候，首先要先判断下是否已经有效登录了，如果是，那么跳转到 Angular 中去，否则跳转到登录页面。因为我想法是做一个主页，这个主页不需要加载太多类库，只是简单的展示页面和登录注册页面，用户登录或注册成功后在跳转到 Angular 的入口文件去。</p>
<p>接下来就是真正的登录接口了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">exports.login = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</div><div class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> UserModel.findOne(&#123;</div><div class="line">        <span class="attr">email</span>: ctx.request.body.email, </div><div class="line">        <span class="attr">password</span>: SHA256(ctx.request.body.password).toString()&#125;);</div><div class="line">    <span class="keyword">let</span> xsrf = SHA256(_.random(<span class="number">999999999</span>)).toString();</div><div class="line">    <span class="keyword">if</span>(result &amp;&amp; result._id) &#123;</div><div class="line">        <span class="keyword">let</span> token = jwt.sign(&#123;<span class="attr">id</span>: result._id, <span class="attr">xsrf</span>: xsrf&#125;, config.app.secretKey);</div><div class="line">        ctx.cookies.set(<span class="string">"XSRF-TOKEN"</span>, xsrf, &#123;<span class="attr">httpOnly</span>: <span class="literal">false</span>, <span class="attr">overwrite</span>: <span class="literal">true</span>, <span class="attr">expires</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() + <span class="number">5184000000</span>)&#125;);</div><div class="line">        ctx.cookies.set(<span class="string">"jwt"</span>, token, &#123;<span class="attr">httpOnly</span>: <span class="literal">true</span>, <span class="attr">overwrite</span>: <span class="literal">true</span>, <span class="attr">expires</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() + <span class="number">5184000000</span>)&#125;);</div><div class="line">        <span class="keyword">await</span> ctx.redirect(<span class="string">'/'</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">let</span> exist = <span class="keyword">await</span> UserModel.findOne(&#123;<span class="attr">email</span>: ctx.request.body.email&#125;);</div><div class="line">        <span class="keyword">if</span>(exist &amp;&amp; exist._id)  ctx.throw(<span class="number">401</span>, <span class="string">'密码错误'</span>);</div><div class="line">        <span class="keyword">else</span> ctx.throw(<span class="number">401</span>, <span class="string">'邮箱未注册'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>恩，熟悉 Node 的应该看懂没啥问题。这里有个变量 <code>xsrf</code> ，作用前面我们已经说了，还有变量 <code>token</code> 就是 JWT 了。然后我们把他设置到 cookie 中，注意 <code>xsrf</code> 不能设置 <code>httpOnly</code> 而 <code>token</code> 需要设置为 <code>httpOnly</code>，不要忘了把 <code>xsrf</code> 也放入 JWT 的 payload 部分中去，这里 payload 存储了用户 id 和当前的 <code>xsrf</code>。</p>
<h3 id="请求带上-XSRF"><a href="#请求带上-XSRF" class="headerlink" title="请求带上 XSRF"></a>请求带上 XSRF</h3><p>我们需要在以后的每个请求都带上 XSRF-TOKEN，具体操作就是把 cookie 中的 XSRF-TOKEN 取出来，放入请求的 X-XSRF-TOKEN 头部中，然后发送出去就好了。如果你用的是 Angular，其实你什么都不需要做了，因为这一步 Angular 已经帮你做好了，前提是你的 xsrf 必须放到 cookie 中的 XSRF-TOKEN 这个里面。如果你用的不是 Angular，那你就自己查下怎么做吧，这一步并不难做到。</p>
<h3 id="设置-header-和校验-XSRF"><a href="#设置-header-和校验-XSRF" class="headerlink" title="设置 header 和校验 XSRF"></a>设置 header 和校验 XSRF</h3><p>前面说了，我们需要把 JWT 放到请求的 <code>Authorization</code> 头部中，但是由于我们对 JWT 设置了 <code>httpOnly</code> ，所以这个操作几乎就不太可能了。但别忘了我们可以在服务端做这一步，与此同时我们也可以把校验 <code>XSRF</code> 也做了，这里先不需要校验 JWT。</p>
<p>如果熟悉 Koa 的话就清楚 Koa 的中间件思路。我们在较顶层的位置写入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// XSRF 检测，处理客户端未授权问题</span></div><div class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</div><div class="line">    <span class="keyword">let</span> token = ctx.cookies.get(<span class="string">'jwt'</span>), xsrf = ctx.request.headers[<span class="string">'x-xsrf-token'</span>];</div><div class="line">    ctx.request.header.authorization = <span class="string">'Bearer '</span> + token;</div><div class="line">    <span class="comment">// 当 JWT 存在且访问 API 时，检测 XSRF </span></div><div class="line">    <span class="keyword">if</span>(token !== <span class="keyword">void</span> <span class="number">0</span> &amp;&amp; <span class="regexp">/^\/api\//</span>.test(ctx.url)) &#123;;</div><div class="line">        <span class="keyword">let</span> verify = <span class="built_in">Promise</span>.promisify(jwt.verify);</div><div class="line">        <span class="keyword">await</span> verify(token, config.app.secretKey).then(<span class="keyword">async</span> (data) =&gt; &#123;</div><div class="line">            <span class="keyword">if</span>(xsrf !== data.xsrf) &#123;</div><div class="line">                ctx.cookies.set(<span class="string">"XSRF-TOKEN"</span>, <span class="literal">null</span>, &#123;<span class="attr">overwrite</span>: <span class="literal">true</span>, <span class="attr">expires</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;);</div><div class="line">                ctx.cookies.set(<span class="string">"jwt"</span>, <span class="literal">null</span>, &#123;<span class="attr">overwrite</span>: <span class="literal">true</span>, <span class="attr">expires</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;);</div><div class="line">                ctx.status = <span class="number">401</span>;</div><div class="line">                ctx.body =  &#123; <span class="attr">success</span>: <span class="literal">false</span>, <span class="attr">message</span>: <span class="string">'用户验证失败'</span>&#125;;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">await</span> next();</div><div class="line">            &#125;</div><div class="line">        &#125;, err =&gt; &#123;</div><div class="line">            ctx.cookies.set(<span class="string">"XSRF-TOKEN"</span>, <span class="literal">null</span>, &#123;<span class="attr">overwrite</span>: <span class="literal">true</span>, <span class="attr">expires</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;);</div><div class="line">            ctx.cookies.set(<span class="string">"jwt"</span>, <span class="literal">null</span>, &#123;<span class="attr">overwrite</span>: <span class="literal">true</span>, <span class="attr">expires</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;)</div><div class="line">            ctx.status = <span class="number">401</span>;</div><div class="line">            ctx.body = &#123; <span class="attr">success</span>: <span class="literal">false</span>, <span class="attr">message</span>: <span class="string">'用户验证失败'</span>&#125;;</div><div class="line">        &#125;);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">await</span> next();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>最前面几行就是设置 header，可以看到非常简单。if 语句进来就是检验 <code>XSRF</code> 了，我的逻辑是只有用户请求 API 的时候并且 JWT 存在的时候才做检测。我们后面有对 JWT 的检测所以这里不需要做，如果 JWT 不存在或者方位的不是 API 直接 next 就好了。</p>
<p>这里调用了 <code>jwt.verify</code> 方法取出了 payload 的内容，这个方法是 <code>jsonwebtoken</code> 这个模块提供的。</p>
<h3 id="检验-JWT"><a href="#检验-JWT" class="headerlink" title="检验 JWT"></a>检验 JWT</h3><p>有一点需要注意的是，有些资源我们允许用户无需登录就进行访问。例如我们前面的登录注册界面，还要像静态资源等等。使用 <code>koa-jwt</code> 可以很方便的做这件事情。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">app.use(handel.routes())</div><div class="line">   .use(handel.allowedMethods());</div><div class="line"></div><div class="line">app.use(jwt(&#123; <span class="attr">secret</span>: config.app.secretKey, <span class="attr">algorithm</span>: <span class="string">'RS256'</span> &#125;).unless(&#123; <span class="attr">path</span>: [<span class="regexp">/^\/css|js|img|fonts/</span>] &#125;));</div><div class="line"></div><div class="line">app.use(api.routes())</div><div class="line">   .use(api.allowedMethods());</div></pre></td></tr></table></figure>
<p><code>handel</code> 这个路由是我的登录注册页面和接口这些，而 <code>api</code> 就是 Angular 中需要用到的一系列接口。中间我们加入了一句话。这里的 <code>jwt</code> 是 <code>koa-jwt</code> 模块。</p>
<p>这些顺序不能乱，koa 中间件的加载是按自顶向下的顺序的，所以我们 <code>handel</code> 这里并不要 jwt 检测，而后面则需要。而我们前面说的 xsrf 检测和 header 处理自然是要放在更前的位置了。这里的 <code>path</code> 你可以根据需要修改。具体的用法参考文档就好了。</p>
<p>整个流程就完了，这个就实现了我们前面探讨的成果。既保护了 token 的安全，又防止了 XSRF 攻击。当然了我不敢说绝对安全，根本就没有绝对安全的东西。但目前这样的鉴权系统应该算马马虎虎了。</p>
<p>如果你的登录注册也是放在前端（比如由 Angular 来做），那你也可以像我上面说的这么做，或者可以把 jwt 作为登录请求的 response 返回，不过我不觉得这是一种安全的方式，关于其他的存储方式参考我后面给的链接吧，我就不多介绍了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实关于 JWT 存放到哪里一直由很多讨论，有人说存放到本地存储，有人说存 cookie。但我觉得上面我说的这种方式是挺稳妥的，如果你有什么意见和看法欢迎提出。参考资料也附出了比较热门的关于 jwt 存储位置的讨论文章，可以看下。</p>
<hr>
<p>参考资料：</p>
<ul>
<li><a href="https://jwt.io/introduction/" target="_blank" rel="external">jwt.io</a></li>
<li><a href="https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage" target="_blank" rel="external">Where to Store your JWTs – Cookies vs HTML5 Web Storage</a></li>
<li><a href="http://stackoverflow.com/questions/27067251/where-to-store-jwt-in-browser-how-to-protect-against-csrf" target="_blank" rel="external">Where to store JWT in browser? How to protect against CSRF?</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前后端分离项目的 Token 存储问题由来已久，有的人存 Cookie 有的人存 LocalStorage 或 SessionStorage，最近刚把 RSS 订阅器项目的鉴权问题做好，感觉算是目前比较稳妥安全的方案了，分享一下经验。&lt;/p&gt;
&lt;p&gt;前端用的是 Angular，后端用的是 Koa，登录注册界面由 Koa 负责，由 Koa 根据用户是否登录来决定首页跳转。我不会一开始就讲我的做法，而是循序渐进的从传统的存储方式逐渐过渡到我的做法当中来。&lt;/p&gt;
&lt;h2 id=&quot;如何安全的传输用户-token&quot;&gt;&lt;a href=&quot;#如何安全的传输用户-token&quot; class=&quot;headerlink&quot; title=&quot;如何安全的传输用户 token&quot;&gt;&lt;/a&gt;如何安全的传输用户 token&lt;/h2&gt;&lt;p&gt;这是最传统也是最简单的方式了，前端登录，后端根据用户信息生成一个 token，并保存这个 token 和对应的用户 id，接着把 token 传给用户，存入浏览器 cookie，之后浏览器请求带上这个 cookie，后端根据这个 cookie 来标识用户。&lt;/p&gt;
&lt;img src=&quot;/2016/10/14/关于前后端分离鉴权的思考/flow-cookie-session.jpg&quot; alt=&quot;flow-cookie-session&quot; title=&quot;flow-cookie-session&quot;&gt;
&lt;p&gt;但这样做问题就很多，如果我们的页面出现了 XSS 漏洞，由于 cookie 可以被 JavaScript 读取，XSS 漏洞会导致用户 token 泄露，而作为后端识别用户的标识，cookie 的泄露意味着用户信息不再安全。&lt;/p&gt;
&lt;p&gt;尽管我们通过转义输出内容，使用 CDN 等可以尽量避免 XSS 注入，但谁也不能保证在大型的项目中不会出现这个问题。另外，后端每次都需要根据 token 查出用户 id，这就增加了数据库的查询和存储开销。&lt;/p&gt;
&lt;p&gt;在设置 cookie 的时候，其实你还可以设置 httpOnly 以及 secure 项。设置 httpOnly 后 cookie 将不能被 JS 读取，浏览器会自动的把它加在请求的 header 当中，设置 secure 的话，cookie 就只允许通过 HTTPS 传输。&lt;/p&gt;
&lt;p&gt;secure 选项可以过滤掉一些使用 HTTP 协议的 XSS 注入，但并不能完全阻止。&lt;/p&gt;
&lt;p&gt;httpOnly 选项使得 JS 不能读取到 cookie，那么 XSS 注入的问题也基本不用担心了。但设置 httpOnly 就带来了另一个问题，就是很容易的被 XSRF，即跨站请求伪造。当你浏览器开着这个页面的时候，另一个页面可以很容易的跨站请求这个页面的内容。因为 cookie 默认被发了出去。&lt;/p&gt;
&lt;img src=&quot;/2016/10/14/关于前后端分离鉴权的思考/CSRF.jpg&quot; alt=&quot;CSRF&quot; title=&quot;CSRF&quot;&gt;
&lt;p&gt;看起来我们不能兼顾。确实，光依靠这一个 token 我们没办法兼顾这两点。既然一个不够，那就两个。于是有了 XSRF-TOKEN，它和作为用户令牌的 token 类似，也是服务器生成的一个散列值。我们把 token 通过 httpOnly 发回去，把 XSRF-TOKEN 直接发回去。我们可以无视 httpOnly 的 cookie 因为我们没法操纵它，但对于这个 XSRF-TOKEN，我们就可以在我们网站的每个请求中都加入到 header 里面去。而服务端就需要检查这个 header 的 XSRF-TOKEN 是否真实有效。&lt;/p&gt;
    
    </summary>
    
      <category term="安全" scheme="https://ruiming.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Angular" scheme="https://ruiming.github.io/tags/Angular/"/>
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="Koa" scheme="https://ruiming.github.io/tags/Koa/"/>
    
      <category term="JWT" scheme="https://ruiming.github.io/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>编译原理与PEG.js</title>
    <link href="https://ruiming.github.io/2016/10/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%8EPEG-js/"/>
    <id>https://ruiming.github.io/2016/10/07/编译原理与PEG-js/</id>
    <published>2016-10-07T08:54:32.000Z</published>
    <updated>2016-11-16T16:06:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><p>这学期开始上编译原理这门课，比较纳闷的一点是老师要求用 Java。作为一个想学好编译原理的 Java 黑，自然要寻找另一门可以进行实践的语言，编译在 JavaScript 中应用非常广泛，几乎所有主流的语言都可以编译到 JavaScript，Babel 编译 ES6 到 ES5，以及 CofferScript, TypeScript, JSX 等等编译为 JavaScript。另外，JavaScript 作为一门函数第一公民的语言，我想用来做编译也是特别方便的。一开始看了 Jison，感觉还是挺简单的，不过现在貌似流行 PEG.js，老实说我并不知道他们区别，我还只是一个初学者，或者初学者也算不上，因为最近一个月根本没好好听课 =.=</p>
<h1 id="解析表达式"><a href="#解析表达式" class="headerlink" title="解析表达式"></a>解析表达式</h1><p>在了解 PEG.js 之前有必要先了解下 <a href="https://zh.wikipedia.org/wiki/%E8%A7%A3%E6%9E%90%E8%A1%A8%E8%BE%BE%E6%96%87%E6%B3%95" target="_blank" rel="external">PEG</a>（解析表达文法），以及它与 CFG（上下文无关文法）的区别。以下摘选<a href="https://zh.wikipedia.org/wiki/%E8%A7%A3%E6%9E%90%E8%A1%A8%E8%BE%BE%E6%96%87%E6%B3%95" target="_blank" rel="external">维基百科</a>上面关于解析表达式的解释</p>
<a id="more"></a>
<blockquote>
<p>解析表达文法里面的每一个非终结符本质上表示递归下降解析器里面的一个解析<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0" target="_blank" rel="external">函数</a>，其对应的解析表达式展示了这个函数包含的代码内容。概念上，每一个解析函数接受一个输入字符串作为参数，返回以下其中一个结果:</p>
<ul>
<li>成功，函数可能向前移动或者“消耗”一个或多个输入字符串的字符</li>
<li>失败，不消耗任何字符</li>
</ul>
<p>一个<strong>非终结符</strong>有可能成功但是不消耗任何输入字符，这也是一种不同于失败的结果。</p>
<p>只由一个<strong>终结符</strong>组成的原子解析表达式：成功，如果输入字符串的第一个字符就是定义中的终结符，这种情况下消耗这个输入字符；否之失败。由空字符串组成的原子解析表达式总是成功并且不消耗任何输入。只由一个非终结符A组成的原子解析表达式表示对非终结符A的解析函数的<a href="https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92" target="_blank" rel="external">递归</a>调用。</p>
<p><strong>序列</strong>操作符 <em>e</em>1<em>e</em>2 首先调用 <em>e</em>1， 如果 <em>e</em>1成功， 接着对 <em>e</em>1 消耗剩下的输入字符串调用 <em>e</em>2， 最后返回结果。如果 <em>e</em>1 或者 <em>e</em>2 失败，那么序列表达式 <em>e</em>1<em>e</em>2 失败。</p>
<p><strong>选择</strong>操作符 <em>e</em>1 / <em>e</em>2 首先调用 <em>e</em>1， 如果 <em>e</em>1成功， 立刻返回结果。否则如果 <em>e</em>1 失败，选择操作符<a href="https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BA%AF" target="_blank" rel="external">回溯</a>到输入字符串匹配 <em>e</em>1 的原始位置，调用 <em>e</em>2， 最后返回 <em>e</em>2 结果。</p>
<p><strong>零个或多个</strong>，<strong>一个或多个</strong>，和<strong>可选</strong>操作符分别消耗零个或多个，一个或多个，或者零个或一个连续重复的子表达式e。与上下文无关文法和正则表达式不同的 是，尽管如此，在PEG里这些操作符总是执行贪婪的行为，那就是消耗尽可能多的输入，而且绝对不回溯。（正则表达式一开始执行贪婪匹配，但是如果整个正则表达式失败后，会回退并尝试短一些的匹配。）例如，解析表达式a<em>总是尽可能多的消耗输入字符串中连续出现的a，解析表达式(a</em> a)则必然会失败因为前半部分a*绝对不会留下一丁点a给后半部分去匹配。</p>
<p>最后，肯定断言和否定断言实现了句法断言。&amp;e 表达式调用子表达式e，如果e成功，则返回成功；否则返回失败。无论结果如何都不消耗任何字符。反之，当e失败时！e 表达式成功，e成功时！e 表达式失败， 同样无论结果如何都不消耗任何字符。因为向前判断的子表达式e 可以任意的复杂，所以断言表达式提供了强大的句法向前判断和去除二义性的能力。</p>
</blockquote>
<h1 id="PEG-js"><a href="#PEG-js" class="headerlink" title="PEG.js"></a>PEG.js</h1><p>PEG.js 是一个基于 JavaScript 的简单的解析器生成器，它用来生成一个快速且具备完善错误报告的解析器。你可以用它来处理复杂的数据或计算机语言，已经轻松的构造变换器，解释器，编译器以及其他的工具。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>简单和具有表现力的语法符号</li>
<li>集成了词法分析( lexcial )和语义分析( syntactical )</li>
<li>具备优良的错误报告</li>
<li>基于解析表达式语法的形式，比传统的 LL(k) 和 LR(k) 解析器更强大</li>
<li>可以用于浏览器，命令行，或者通过 JavaScript 的 API</li>
</ul>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p><a href="http://pegjs.org/online" target="_blank" rel="external">在线版本</a> 是生成一个解析器最简单的方式，只要输入你定义的语法，尝试解析少量的输入，下载生成的解析后的代码。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>如果要使用 <code>pegj</code> 命令，全局安装 PEG.js</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g pegjs</div></pre></td></tr></table></figure>
<p>如果要使用 JavaScript 的 API，本地安装 PEG.js</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install pegjs</div></pre></td></tr></table></figure>
<p>如果你两者都需要，那么两种方式都安装即可</p>
<h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p><a href="http://pegjs.org/#download" target="_blank" rel="external">下载</a> PEG.js 库(普通或者压缩的版本) 或者通过 Bower 安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bower install pegjs</div></pre></td></tr></table></figure>
<h2 id="生成一个解析器"><a href="#生成一个解析器" class="headerlink" title="生成一个解析器"></a>生成一个解析器</h2><p>PEG.js 根据一个你希望解析的输入的语法以及你指定的返回结果(对匹配的进行语义分析)生成解析器。最后生成解析器本质上只是一个带有一些简单 API 的 JavaScript 对象。</p>
<h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p>想要根据你的语法生成一个解析器，使用 <code>pegjs</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pegjs arithmetics.pegjs</div></pre></td></tr></table></figure>
<p>这将会把解析器代码写入一个以 ‘.js’ 为扩展名的相同文件名文件中， 你也可以自己指定输出：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">pegjs</span> <span class="selector-tag">-o</span> <span class="selector-tag">arithmetics-parser</span><span class="selector-class">.js</span> <span class="selector-tag">arithmetics</span><span class="selector-class">.pegjs</span></div></pre></td></tr></table></figure>
<p>如果你省略了输入和输出文件，那么将会使用标准的输入输出</p>
<p>默认下，解析器的生成采用了 Node.js 的模块格式，你可以使用 <code>--format</code> 选项来覆盖。</p>
<p>你可以调整一下几个选项：</p>
<ul>
<li><code>--allowed-start-rules</code> – 逗号相隔的会被用来解析的规则（默认为第一个规则）</li>
<li><code>--cache</code> – 让解析器缓存结果，避免在极端情况下出现了指数级的解析时间而降低解析器速度</li>
<li><code>--dependency</code> – 给解析器指定依赖（可以多次指定）</li>
<li><code>--export-var</code> – 指定一个全局变量名称，当没有进行模块到处时，解析器对象会以该名称命名</li>
<li><code>--extra-options</code> – 其他的传递给 <code>peg.generate</code> 的选项（JSON 格式）</li>
<li><code>--extra-options-file</code> – 同上，只不过选项保存在文件里面</li>
<li><code>--format</code> – 指定解析器的到导出格式，如 <code>amd</code>， <code>commonjs</code>，<code>globals</code>，<code>umd</code>（默认: <code>commonjs</code>）</li>
<li><code>--optimize</code> – 在优化解析速度（<code>speed</code>）和代码大小（<code>size</code>）之间进行选择（默认：<code>speed</code>）</li>
<li><code>--plugin</code> – 让 PEG.js 使用一个指定的插件（可以多次指定）</li>
<li><code>--trace</code> – 让解析器跟踪其运行情况</li>
</ul>
<h3 id="JavaScript-API"><a href="#JavaScript-API" class="headerlink" title="JavaScript API"></a>JavaScript API</h3><p>在 Node.js 中，需要引入 PEG.js 这个模块</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> peg = <span class="built_in">require</span>(<span class="string">'pegjs'</span>);</div></pre></td></tr></table></figure>
<p>在浏览器中，通过 <code>&lt;script&gt;</code> 标签引入 PEG.js 库到你的网页中。如果 PEG.js 使用 AMD 模块化方案，它会把模块定义在一个变量上面，否则他的 API 将会挂载在全局对象 <code>peg</code> 中</p>
<p>为了生成一个解析器，调用 <code>peg.generate</code> 方法并把你的语法作为参数传递进去</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> parser = peg.generate(<span class="string">"start = ('a'/'b')+"</span>);</div></pre></td></tr></table></figure>
<p>这个方法会返回解析器对象或者返回源码（取决于你的 <code>output</code> 参数 – 参见下文）。如果语法非法它将抛出错误，错误会包含 <code>message</code> 属性，它携带更详细的错误信息</p>
<p>你可以传入以下选项组成的对象作为 <code>peg.generate</code> 的第二个参数，以下选项是受支持的：</p>
<ul>
<li><code>allowedStartRules</code> – 指定解析器从哪个规则开始解析（默认：语法中的第一个规则）</li>
<li><code>cache</code> – 如果为 <code>true</code>，解析器会缓存结果以避免指数级的解析时间影响解析器效率（默认：<code>false</code>）</li>
<li><code>dependencies</code> – 解析需要的依赖，它的值为一个变量与依赖模块映射的对象。解析器通过这些变量来使用那些模块。只有当 <code>format</code> 被设置为 <code>amd</code>，<code>commonjs</code> 或者 <code>umd</code> （默认：<code>{}</code>）时才有效。</li>
<li><code>exportVar</code> – 一个全局对象名，当没有进行模块导出时，解析器对象会以该名称命名</li>
<li><code>format</code> – 生成的解析器的导出格式（”amd”，”bare”，”commonjs”，”globals”，”umd”），只有当 <code>output</code> 设置为 <code>source</code> 时（默认：<code>null</code>）才有效</li>
<li><code>optimize</code> – 在优化解析速度（<code>speed</code>）和代码大小（<code>size</code>）之间进行选择（默认：<code>speed</code>）</li>
<li><code>output</code> – 如果设置为 <code>parser</code>，这个方法将返回解析器对象；如果设置为 <code>source</code>，它会以字符串的形式返回生成的解析器的源码（默认：<code>parser</code>）</li>
<li><code>plugin</code> – 让 PEG.js 使用一个指定的插件（可以多次指定）</li>
<li><code>trace</code> – 让解析器跟踪其运行情况</li>
</ul>
<h2 id="使用解析器"><a href="#使用解析器" class="headerlink" title="使用解析器"></a>使用解析器</h2><p>使用生成的解析器的方法十分简单，只要调用它的 <code>parse</code> 方法并把参数作为一个字符串传入即可。该方法会返回解析的结果（确切的值取决于你的生成该解析器的语法）或者抛出错误（如果你的输入非法）。抛出的错误信息带有 <code>location</code>，<code>expected</code>，<code>found</code> 以及包含更多错误信息的 <code>message</code> </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">parser.parse(<span class="string">"abba"</span>);		<span class="comment">// returns ["a", "b", "b", "a"]</span></div><div class="line">parser.parse(<span class="string">"abcd"</span>);		<span class="comment">// throws an exception</span></div></pre></td></tr></table></figure>
<p>你还可以通过传入第二个参数来调整解析行为，该参数是一个支持以下可选项的对象：</p>
<ul>
<li><code>startRule</code> – 从这个规则开始解析</li>
<li><code>tracer</code> – 追踪解析行为</li>
</ul>
<p>解析器也支持你自定义的选项</p>
<h2 id="句法和语义"><a href="#句法和语义" class="headerlink" title="句法和语义"></a>句法和语义</h2><p>PEG.js 的句法不是面向行的，并且会忽略标记（token）之间的空白，这一点和 JavaScript 相似。你也可以使用 JavaScript 风格的注释（<code>//...</code> 和 <code>/*...*/</code>）</p>
<p>让我们看一个简单的可以识别形如 <code>2*(3+4)</code> 这样的表达式的语法。根据这个语法生成的解析器可以计算该表达式的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">start</div><div class="line">  = additive</div><div class="line"></div><div class="line">additive</div><div class="line">  = left:multiplicative <span class="string">"+"</span> right:additive &#123; <span class="keyword">return</span> left + right; &#125;</div><div class="line">  / multiplicative</div><div class="line"></div><div class="line">multiplicative</div><div class="line">  = left:primary <span class="string">"*"</span> right:multiplicative &#123; <span class="keyword">return</span> left * right; &#125;</div><div class="line">  / primary</div><div class="line"></div><div class="line">primary</div><div class="line">  = integer</div><div class="line">  / <span class="string">"("</span> additive:additive <span class="string">")"</span> &#123; <span class="keyword">return</span> additive; &#125;</div><div class="line"></div><div class="line">integer <span class="string">"integer"</span></div><div class="line">  = digits:[<span class="number">0</span><span class="number">-9</span>]+ &#123; <span class="keyword">return</span> <span class="built_in">parseInt</span>(digits.join(<span class="string">""</span>), <span class="number">10</span>); &#125;</div></pre></td></tr></table></figure>
<p>在顶层，语法包含了规则（在我们的例子中，有五条规则）。每条规则都由一个名字（例如 <code>integer</code>）来区分它们，并且还有一个解析表达式（例如 <code>digits:[0-9]+ { return parseInt(digits.join(&quot;&quot;), 10); }</code>）来定义一个对输入文本的匹配，你还可以在其中包含你的 JavaScript 代码来处理被成功匹配到的文本。规则可以包含别名以便于错误提示（例如上面的例子中，只有 <code>integer</code> 规则具有别名）。解析将从第一条规则，这条规则也叫作 <em>start rule</em></p>
<p>一个规则名必须是一个 JavaScript 标识符，它后面跟着一个 <code>=</code> 和解析表达式。如果这个规则名有一个别名，它作为一个 JavaScript 字符串书写在规则名和 <code>=</code> 之间。规则之间需要用空格分割开，但在解析表达式后面跟着 <code>;</code> 也是可以的。</p>
<p>你可以在第一个规则前初始化一些用 <code>{}</code> 闭合的 JavaScript 代码。这些代码会在解析器开始解析之前先执行。在初始化操作中定义的变量名和函数可以在规则操作和语义谓词中直接使用，同时他们也可以直接访问通过 <code>options</code> 传递进来的对象。初始化过程中括号必须严格闭合。比如我们来看一个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">makeInteger</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(o.join(<span class="string">""</span>), <span class="number">10</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">start</div><div class="line">  = additive</div><div class="line"></div><div class="line">additive</div><div class="line">  = left:multiplicative <span class="string">"+"</span> right:additive &#123; <span class="keyword">return</span> left + right; &#125;</div><div class="line">  / multiplicative</div><div class="line"></div><div class="line">multiplicative</div><div class="line">  = left:primary <span class="string">"*"</span> right:multiplicative &#123; <span class="keyword">return</span> left * right; &#125;</div><div class="line">  / primary</div><div class="line"></div><div class="line">primary</div><div class="line">  = integer</div><div class="line">  / <span class="string">"("</span> additive:additive <span class="string">")"</span> &#123; <span class="keyword">return</span> additive; &#125;</div><div class="line"></div><div class="line">integer <span class="string">"integer"</span></div><div class="line">  = digits:[<span class="number">0</span><span class="number">-9</span>]+ &#123; <span class="keyword">return</span> makeInteger(digits); &#125;</div></pre></td></tr></table></figure>
<p>规则的解析表达式用来匹配输入的文本。这里由好几种类型的表达式 – 匹配字符或字符类，显示可选部分和重复等等。表达式中也可以包含其他规则的引用。详细介绍见下文。</p>
<p>如果一个表达式成功的匹配到了一个输入流的部分文本，它会产生一个匹配结果，这是一个 JavaScript 值。例如：</p>
<ul>
<li>一个匹配字符串的表达式生成一个包含被匹配串的 JavaScript 字符串</li>
<li>一个匹配包含子表达式的字符串的表达式生成一个含有全部被匹配项的 JavaScript 数组</li>
</ul>
<p>当在表达式中使用规则名时，它将递归的解析下去并最终返回全部解析完成的结果</p>
<p>一个特殊的情况是解析表达式是一个解析行为 – 一段 JavaScript 代码包含在 <code>{}</code> 里面。它会处理匹配到的文本串并返回处理的结果，这个值是也被认为是表达式匹配的结果（换句话说，解析行为是对被匹配文本的一个变换器）</p>
<p>在我们的算术例子中由几个解析行为。比如这个表达式 <code>digits:[0-9] + { return parseInt(digits.join(&quot;&quot;), 10); }</code>，它处理 [0-9]+ 匹配的结果，这个结果是一个包含匹配的数字字符串组成的数组，它作为参数传入到该后面的行为被拼接成为一个 JavaScript <code>number</code> 对象后返回</p>
<h2 id="解析表达式类型"><a href="#解析表达式类型" class="headerlink" title="解析表达式类型"></a>解析表达式类型</h2><p>解析表达式有好几种类型，他们当中可能有些还包含子表达式从而形成一个递归结构</p>
<p>“<em>literal</em>“</p>
<p>‘<em>literal</em>‘</p>
<p>解析表达式会精确匹配字符串并返回，该字符串的句法和 JavaScript 一样。在字符串后面追加 <code>i</code> 使得匹配区分大小写</p>
<p><em>.</em></p>
<p>匹配一个字符并作为一个字符串返回</p>
<p><em>[characters]</em></p>
<p>从一个集合中匹配一个字符并作为一个字符串返回。集合中的字符可以以和 JavaScript 字符串相同的方式进行转义处理。集合中的字符也可以包含范围（例如 [a-z] 表示匹配一个小写字母）。在字符前面加上 <code>^</code> 表示取反（例如：<code>[^a-z]</code> 表示匹配一个非小写字母）。在右括号后面添加 <code>i</code> 可以让匹配区分大小写</p>
<p><em>rule</em></p>
<p>递归的匹配一个解析表达式规则并返回匹配的结果</p>
<p><em>( expression )</em></p>
<p>匹配一个子表达式并返回匹配的结果</p>
<p><em>expression *</em></p>
<p>匹配表达式零次或多次并以数组的形式返回匹配结果。这个匹配是贪婪匹配，即解析器会尽可能的进行多次匹配。不像正则表达式，解析表达式没有回溯</p>
<p><em>expression +</em></p>
<p>匹配表达式一次或多次并以数组的形式返回匹配结果。这个匹配是贪婪匹配，即解析器会尽可能的进行多次匹配。不像正则表达式，解析表达式没有回溯</p>
<p><em>expression ?</em></p>
<p>尝试匹配表达式，如果匹配成功，返回匹配的结果，否则返回 <code>null</code>。不像正则表达式，解析表达式没有回溯</p>
<p><em>&amp; expression</em></p>
<p>尝试匹配表达式，如果匹配成功，只返回 <code>undefined</code> 并且不消耗任何输入，否则认为匹配是失败的</p>
<p><em>! expression</em></p>
<p>尝试匹配表达式，如果匹配不成功，只返回 <code>undefined</code> 并且不消耗任何输入，否则认为匹配是失败的</p>
<p><code>&amp; { predicate }</code></p>
<p><code>predicate</code> 是一段 JavaScript 代码，可以理解为是它是在一个函数里面等待执行。它会把前面表达式匹配得到的结果作为它的参数。它通过 <code>return</code> 来返回 JavaScript 值。If the returned value evaluates to <code>true</code> in boolean context，返回 <code>undefined</code> 并且不消耗任何输入，否则认为匹配是失败的</p>
<p>在 <code>predicate</code> 中的代码可以访问初始化时定义的变量和方法</p>
<p>在 <code>predicate</code> 中的代码可以通过调用 <code>location</code> 函数来访问当前位置信息，它会返回一个像下面这样的对象：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  start: &#123; offset: 23, line: 5, column: 6 &#125;,</div><div class="line">  end: &#123; offset: 23, line: 5, colume: 6&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>start</code> 和 <code>end</code> 都指向当前解析的位置，<code>offset</code> 为一个从 0 开始的偏移值，<code>line</code> 和 <code>column</code> 为从 1 开始的行号和列号</p>
<p>在 <code>pedicate</code> 中的代码可以通过 <code>options</code> 变量来访问解析器被调用时传递进来的选项对象</p>
<p>注意括号必须严格闭合</p>
<p><em>! { predicate }</em></p>
<p><code>predicate</code> 是一段 JavaScript 代码，可以理解为是它是在一个函数里面等待执行。它会把前面表达式匹配得到的结果作为它的参数。它通过 <code>return</code> 来返回 JavaScript 值。If the returned value evaluates to <code>false</code> in boolean context，返回 <code>undefined</code> 并且不消耗任何输入，否则认为匹配是失败的</p>
<p>在 <code>predicate</code> 中的代码可以访问初始化时定义的变量和方法</p>
<p>在 <code>predicate</code> 中的代码可以通过调用 <code>location</code> 函数来访问当前位置信息，它会返回一个像下面这样的对象：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  start: &#123; offset: 23, line: 5, column: 6 &#125;,</div><div class="line">  end: &#123; offset: 23, line: 5, colume: 6&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>start</code> 和 <code>end</code> 都指向当前解析的位置，<code>offset</code> 为一个从 0 开始的偏移值，<code>line</code> 和 <code>column</code> 为从 1 开始的行号和列号</p>
<p>在 <code>pedicate</code> 中的代码可以通过 <code>options</code> 变量来访问解析器被调用时传递进来的选项对象</p>
<p>注意括号必须严格闭合</p>
<p><em>$ expression</em></p>
<p>尝试匹配表达式，如果匹配成功，返回匹配的文本而不是匹配的结果</p>
<p><em>label: expression</em></p>
<p>匹配表达式并使用 <code>label</code> 来保存匹配结果，<code>label</code> 必须是一个 JavaScript 符号</p>
<p>符号表达式通常和解析行为一起使用，表达式匹配结果保存在符号中，解析行为通过符号来访问匹配结果</p>
<p><em>expression_1</em> <em>expression_2</em> … <em>expression_n</em></p>
<p>匹配一连串表达式并把匹配结果作为一个数组返回</p>
<p><em>expression { action }</em></p>
<p>匹配表达式，如果匹配成功，则执行表达式，否则认为匹配是失败的</p>
<p><code>action</code> 是一段 JavaScript 代码，可以理解为是它是在一个函数里面等待执行。它会把前面表达式匹配得到的结果作为它的参数。它通过 <code>return</code> 来返回 JavaScript 值。返回值是匹配的结果。</p>
<p>为了便于查错，<code>action</code> 里面可以调用 <code>expected</code> 函数来让解析器抛出一个错误。这个函数有两个参数，一个描述当前位置预期的结果和可选的当前位置的信息（默认为 <code>location</code> 函数调用返回的结果 – 见下文）。这个描述会作为抛出错误信息的一部分</p>
<p><code>action</code> 里面也可以调用 <code>error</code> 函数，同样也会让编译器抛出错误。这个函数也由两个参数 – 错误信息和可选的位置信息（默认为 <code>location</code> 函数调用返回的结果 – 见下文）。错误信息将被抛出的错误所使用</p>
<p><code>action</code> 里面的代码也可以访问语法初始化时的定义的变量和方法。注意必须严格括号闭合</p>
<p><code>action</code> 里面的代码也可以通过 <code>text</code> 函数来访问前面表达式匹配的字符串</p>
<p><code>action</code> 里面的代码也可以通过调用 <code>location</code> 函数来访问当前位置信息，它会返回一个像下面这样的对象：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  start: &#123; offset: 23, line: 5, column: 6 &#125;,</div><div class="line">  end: &#123; offset: 25, line: 5, colume: 8&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>start</code> 执行表达式开始的位置，而 <code>end</code> 指向表达式结束的位置。<code>offset</code> 是从 0 开始的偏移值，<code>line</code> 和 <code>column</code> 是从 1 开始的行数和列数</p>
<p><code>action</code> 里面的代码可以通过 <code>options</code> 变量来访问解析器被调用时传递进来的选项对象</p>
<p>注意括号必须严格闭合</p>
<p><em>expression_1 / expression_2 / … / expression_n</em></p>
<p>尝试匹配第一个表达式，如果没有匹配到，则尝试第二个，以此类推。最后返回第一个匹配成功的表达式匹配的结果。如果没有成功匹配的表达式，则认为匹配失败。</p>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>解析器生成器和生成的解析器都可以在以下环境中运行：</p>
<ul>
<li>Node.js 4+</li>
<li>Internet Explorer 8+</li>
<li>Edge</li>
<li>Firefox</li>
<li>Chrome</li>
<li>Safari</li>
<li>Opera</li>
</ul>
<h2 id="Development"><a href="#Development" class="headerlink" title="Development"></a>Development</h2><ul>
<li><a href="http://pegjs.org/" target="_blank" rel="external">Project website</a></li>
<li><a href="https://github.com/pegjs/pegjs/wiki" target="_blank" rel="external">Wiki</a></li>
<li><a href="https://github.com/pegjs/pegjs" target="_blank" rel="external">Source code</a></li>
<li><a href="https://github.com/pegjs/pegjs/issues" target="_blank" rel="external">Issue tracker</a></li>
<li><a href="http://groups.google.com/group/pegjs" target="_blank" rel="external">Google Group</a></li>
<li><a href="http://twitter.com/peg_js" target="_blank" rel="external">Twitter</a></li>
</ul>
<p>PEG.js is developed by <a href="http://majda.cz/" target="_blank" rel="external">David Majda</a> (<a href="http://twitter.com/dmajda" target="_blank" rel="external">@dmajda</a>). The <a href="https://github.com/pegjs/bower" target="_blank" rel="external">Bower package</a> is maintained by <a href="http://www.michel-kraemer.com/" target="_blank" rel="external">Michel Krämer</a> (<a href="https://twitter.com/michelkraemer" target="_blank" rel="external">@michelkraemer</a>).</p>
<p>You are welcome to contribute code. Unless your contribution is really trivial you should get in touch with me first — this can prevent wasted effort on both sides. You can send code both as a patch or a GitHub pull request.</p>
<p>Note that PEG.js is still very much work in progress. There are no compatibility guarantees until version 1.0.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;编译原理&quot;&gt;&lt;a href=&quot;#编译原理&quot; class=&quot;headerlink&quot; title=&quot;编译原理&quot;&gt;&lt;/a&gt;编译原理&lt;/h1&gt;&lt;p&gt;这学期开始上编译原理这门课，比较纳闷的一点是老师要求用 Java。作为一个想学好编译原理的 Java 黑，自然要寻找另一门可以进行实践的语言，编译在 JavaScript 中应用非常广泛，几乎所有主流的语言都可以编译到 JavaScript，Babel 编译 ES6 到 ES5，以及 CofferScript, TypeScript, JSX 等等编译为 JavaScript。另外，JavaScript 作为一门函数第一公民的语言，我想用来做编译也是特别方便的。一开始看了 Jison，感觉还是挺简单的，不过现在貌似流行 PEG.js，老实说我并不知道他们区别，我还只是一个初学者，或者初学者也算不上，因为最近一个月根本没好好听课 =.=&lt;/p&gt;
&lt;h1 id=&quot;解析表达式&quot;&gt;&lt;a href=&quot;#解析表达式&quot; class=&quot;headerlink&quot; title=&quot;解析表达式&quot;&gt;&lt;/a&gt;解析表达式&lt;/h1&gt;&lt;p&gt;在了解 PEG.js 之前有必要先了解下 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%A7%A3%E6%9E%90%E8%A1%A8%E8%BE%BE%E6%96%87%E6%B3%95&quot;&gt;PEG&lt;/a&gt;（解析表达文法），以及它与 CFG（上下文无关文法）的区别。以下摘选&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%A7%A3%E6%9E%90%E8%A1%A8%E8%BE%BE%E6%96%87%E6%B3%95&quot;&gt;维基百科&lt;/a&gt;上面关于解析表达式的解释&lt;/p&gt;
    
    </summary>
    
      <category term="PEG" scheme="https://ruiming.github.io/categories/PEG/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="Compiler" scheme="https://ruiming.github.io/tags/Compiler/"/>
    
      <category term="PEG.js" scheme="https://ruiming.github.io/tags/PEG-js/"/>
    
  </entry>
  
  <entry>
    <title>Angular 最佳实践总结 (一)</title>
    <link href="https://ruiming.github.io/2016/09/29/Angular%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%20(%E4%B8%80)/"/>
    <id>https://ruiming.github.io/2016/09/29/Angular 最佳实践总结 (一)/</id>
    <published>2016-09-29T06:45:13.000Z</published>
    <updated>2016-11-16T16:07:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>搞了快一年的 Angular，Angular 真的是一个非常强大非常齐全非常好用的框架，而且拥有强大的社区支持，虽然踩了很多坑，但是仍然无悔学习了这样一个框架。Angular 2 已经正式发布了，我也打算学 Angular2 去了，现在手头上还有一个用 Angular 的项目，这个项目我是想把我学到的很多 Angular 的最佳实践都用进去，借此我就想干脆也写几篇博客总结下好了，我写的比较散，想到什么就说什么。</p>
<h2 id="使用单次绑定或单向绑定"><a href="#使用单次绑定或单向绑定" class="headerlink" title="使用单次绑定或单向绑定"></a>使用单次绑定或单向绑定</h2><p>从 Angular 1.3 开始就有了 once-time binding，Angular 1.5 开始支持了指令和组件的 one-way binding。看看他们的用法：</p>
<p>单次绑定很简单，加上<code>::</code> 就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;p&gt;&#123;&#123;::vm.title&#125;&#125;&lt;<span class="regexp">/p&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>An expression that starts with <code>::</code> is considered a one-time expression. One-time expressions will stop recalculating once they are stable, which happens after the first digest if the expression result is a non-undefined value (see value stabilization algorithm below).</p>
</blockquote>
<p>当 digest 结束之后并且单次绑定的值不为 undefined 时，这个值将不再被监听。官方称这个算法为 <code>Value stabilization algorithm</code> 还解释了一下。看到这个，再想起 Angular 源码那注释，觉得真的业界良心啊。想具体了解下单次绑定，出门右转 -&gt; <a href="https://docs.angularjs.org/guide/expression" target="_blank" rel="external">docs.angularjs</a></p>
<p>在视图进行单向绑定也很简单，使用 <code>ng-bind</code> 就可以了，这里主要说的是指令和组件中的单向绑定。</p>
<p>其实 Angular1 还是不断再发展，现在最新的是 1.5.9，加了很多新的东西，也做了很多性能优化。单向绑定也是 1.5 之后才引入的新东西。1.5 也引入了一个新的东西叫 component，和 directive 差不多，具体我没用过我也不太了解，不过写法简洁了很多。单向绑定主要就是用于 component 和 directive 的。</p>
<p>随便找个比较简单的例子来说下，</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="meta">  'use strict'</span>;</div><div class="line">  <span class="keyword">var</span> app = angular.module(<span class="string">'app'</span>);</div><div class="line"></div><div class="line">  app.component(<span class="string">'menuBar'</span>, &#123;</div><div class="line">    <span class="comment">// defines a two way binding in and out of the component</span></div><div class="line">    bindings: &#123;</div><div class="line">      <span class="attr">brand</span>:<span class="string">'&lt;'</span></div><div class="line">     &#125;,</div><div class="line">    <span class="comment">// Load the template</span></div><div class="line">    templateUrl: <span class="string">'/js/components/appComponent.html'</span>,</div><div class="line">    <span class="attr">controller</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// A list of menus</span></div><div class="line">      <span class="keyword">this</span>.menu = [&#123;</div><div class="line">        <span class="attr">name</span>: <span class="string">"Home"</span>,</div><div class="line">        <span class="attr">component</span>: <span class="string">"home"</span></div><div class="line">      &#125;, &#123;</div><div class="line">        <span class="attr">name</span>: <span class="string">"About"</span>,</div><div class="line">        <span class="attr">component</span>: <span class="string">"about"</span></div><div class="line">      &#125;, &#123;</div><div class="line">        <span class="attr">name</span>: <span class="string">"Contact"</span>,</div><div class="line">        <span class="attr">component</span>: <span class="string">"contact"</span></div><div class="line">      &#125;];</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>单向绑定就上面的 <code>&lt;</code> ，我们知道一般有 <code>@</code>, <code>=</code>, <code>&amp;</code> 三种方式，分别表示绑定字面量，绑定表达式，绑定事件，而新增的 <code>&lt;</code> 是用来实现单向绑定的。上面这段代码是从别的地方找来的，由于我自己没有使用过，所以暂时不过多介绍，晚点搞清楚了再补充下。</p>
<h2 id="谨慎使用-interval"><a href="#谨慎使用-interval" class="headerlink" title="谨慎使用 $interval"></a>谨慎使用 $interval</h2><p>如果我们要实现实时显示当前时间的效果，可以有下面三种方式:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">vm.time = <span class="built_in">Date</span>.now();</div><div class="line"></div><div class="line"><span class="comment">// 方式一</span></div><div class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  vm.time = <span class="built_in">Date</span>.now();</div><div class="line">  $scope.$digest();</div><div class="line">&#125;, <span class="number">1000</span>);</div><div class="line"></div><div class="line"><span class="comment">// 方式二</span></div><div class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  $scope.$apply(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    vm.time = <span class="built_in">Date</span>.now();</div><div class="line">  &#125;)</div><div class="line">&#125;, <span class="number">1000</span>);</div><div class="line"></div><div class="line"><span class="comment">// 方式三</span></div><div class="line">$interval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  vm.time = <span class="built_in">Date</span>.now();</div><div class="line">&#125;, <span class="number">1000</span>);</div></pre></td></tr></table></figure>
<p>考虑到页面还有其他双向绑定量，你觉得上面三种方式哪种性能消耗会小一点？</p>
<p>我这边测试了下，三种方式导致当前 digest 所执行的 watcher 表达式数量分别是　方式一 (34) &lt; 方式二 (140) = 方式三 (140)。</p>
<img src="/2016/09/29/Angular%20最佳实践总结%20(一)/方式一.png" alt="方式一" title="方式一">
<img src="/2016/09/29/Angular%20最佳实践总结%20(一)/方式二.png" alt="方式二" title="方式二">
<img src="/2016/09/29/Angular%20最佳实践总结%20(一)/方式三.png" alt="方式三" title="方式三">
<p>我感觉有种被骗的感觉，我记得大家都说不要手动调用 <code>$digest</code> 啊要用 <code>$apply</code> 啊… 但事实是这里的方式一是性能最好的，如果要说原因，那是因为<code>$scope.$digest()</code> 只会触发当前 scope 进行 digest，而其余的就会从 <code>$rootScope</code> 下来整个都进行 digest，对于我们这里只是想要实现时间变化的需求来说就显得有点多于了，这种情况下还是方式一合适些。当然了你也可以用原生 JS 来写，但这样就使用不了 Angular 的日期格式化功能了~</p>
<p>不少人认为 Angular 脏检查是轮询，如果不加限制使用 <code>$interval</code>，不就和轮询没区别了。所以能少用就少用，这里不用 <code>$interval</code> 是因为它会在每次循环结束自动调用 <code>$rootScope</code> 上面的 digest，因此使用 setInterval，如果你不触发 digest，那么这个数据的变化是不会同步到视图中的，所以我们手动的触发了当前作用于的 digest。</p>
<h2 id="ng-repeat-使用-trackby-优化"><a href="#ng-repeat-使用-trackby-优化" class="headerlink" title="ng-repeat 使用 trackby 优化"></a>ng-repeat 使用 trackby 优化</h2><p>Angular 会为每个 watch 变量生成一个 <code>hashkey</code>，并使用他来跟踪其值的变化，当我们使用 ng-repeat 时，如果数组的内容发生了变化，Angular 不会重新销毁和渲染整个 DOM，而是找出变化的一部分做出修改，由于 <code>hashkey</code> 是根据节点内容产生的，这意味着我们的数组中不能有完全一样的两个节点存在。并且当数组的子项为对象时，用一个类似的新的数组覆盖它会导致 Angular 销毁并重新渲染整个 DOM。我们试一试便知。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 不使用 track by --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">ng-repeat</span>=<span class="string">"item in items"</span>&gt;</span></div><div class="line">  &#123;&#123;item.value&#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 使用 track by --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">ng-repeat</span>=<span class="string">"item in vm.items track by item.key"</span>&gt;</span></div><div class="line">  &#123;&#123;item.value&#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure>
<p>我们在控制器里面这样写看下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vm.items = [&#123;<span class="attr">key</span>: <span class="number">1</span>, <span class="attr">value</span>: <span class="number">2</span>&#125;, &#123;<span class="attr">key</span>: <span class="number">3</span>, <span class="attr">value</span>: <span class="number">4</span>&#125;, &#123;<span class="attr">key</span>: <span class="number">5</span>, <span class="attr">value</span>: <span class="number">6</span>&#125;];</div><div class="line">$timeout(<span class="function"><span class="params">()</span> =&gt;</span> vm.items = [&#123;<span class="attr">key</span>: <span class="number">1</span>, <span class="attr">value</span>: <span class="number">2</span>&#125;, &#123;<span class="attr">key</span>: <span class="number">3</span>, <span class="attr">value</span>: <span class="number">4</span>&#125;, &#123;<span class="attr">key</span>: <span class="number">5</span>, <span class="attr">value</span>: <span class="number">6</span>&#125;], <span class="number">2000</span>);</div><div class="line">$timeout(<span class="function"><span class="params">()</span> =&gt;</span> vm.items.push(&#123;<span class="attr">key</span>: <span class="number">7</span>, <span class="attr">value</span>: <span class="number">8</span>&#125;), <span class="number">3000</span>);</div></pre></td></tr></table></figure>
<p>可以自己试一试，然后调出开发者工具查看下 DOM 的变化</p>
<p>结果是：</p>
<ul>
<li><p>不使用 track by</p>
<p>2 秒后重新渲染全部子节点，3 秒后添加渲染了一个新节点。</p>
</li>
<li><p>使用 track by</p>
<p>2 秒后没变化，3秒后添加渲染了一个新节点。</p>
</li>
</ul>
<p>他们的区别就在数组重新赋值上面，还有就是数组必须是一个由对象组成的数组。在有些情况下，我们可能需要使用一个新的数组覆盖旧的数组，而他们之间可能有部分是相同的，如果我们使用 trackBy，Angular 就可以利用这一部分已经渲染好的 DOM，从而达到了优化的目的。</p>
<p>如果没有特别的唯一标识可以指定，也可以直接使用 <code>track by $index</code>，也可以起到一样的作用。</p>
<h2 id="关闭调试信息"><a href="#关闭调试信息" class="headerlink" title="关闭调试信息"></a>关闭调试信息</h2><p>据说这个方法很多人都不知道？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$compileProvider.debugInfoEnabled(<span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p>这样就可以关闭 Angular 插在视图里面的任何辅助调试信息例如 <code>ng-if</code> 和 <code>ng-repeat</code> 等注释以及 <code>ng-binding</code> 等 CSS 类。上线的时候关掉会比较好一点。</p>
<h2 id="使用超级强大的-interceptors"><a href="#使用超级强大的-interceptors" class="headerlink" title="使用超级强大的 interceptors"></a>使用超级强大的 interceptors</h2><p>这个在做全局请求和相应处理时特别强大，通过它我们可以实现统一修改每个请求的 header，对返回的结果进行处理，全局 HTTP 错误响应处理等等。用法也相当简单：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$httpProvider.interceptors.push(function($q) &#123;</div><div class="line">  return &#123;</div><div class="line">    'request': function(config) &#123;</div><div class="line">      </div><div class="line">    &#125;,</div><div class="line">    'requestError': function(rejection) &#123;</div><div class="line">      </div><div class="line">    &#125;,</div><div class="line">    ‘response': function(response) &#123;</div><div class="line">      </div><div class="line">    &#125;,</div><div class="line">    'responseError': function(rejection) &#123;</div><div class="line">      </div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>额，举个粟子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    angular</div><div class="line">        .module(<span class="string">'app'</span>)</div><div class="line">        .factory(<span class="string">'tokenInjector'</span>, tokenInjector);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">tokenInjector</span>(<span class="params">$injector, $q, $cookies, $cacheFactory, $timeout</span>) </span>&#123;</div><div class="line">        <span class="keyword">let</span> jwt = <span class="literal">undefined</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">request</span>: <span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</div><div class="line">                <span class="keyword">if</span>(<span class="keyword">void</span> <span class="number">0</span> === jwt) &#123;</div><div class="line">                    jwt = $cookies.get(<span class="string">'jwt'</span>);</div><div class="line">                &#125;</div><div class="line">                config.headers[<span class="string">'Authorization'</span>] = <span class="string">"Bearer "</span> + jwt;</div><div class="line">                <span class="keyword">return</span> $q.when(config);</div><div class="line">            &#125;,</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<p>上面新建了一个 <code>tokenInjector</code>，之后我们这样使用就可以了:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$httpProvider.interceptors.push(tokenInjector);</div></pre></td></tr></table></figure>
<p>作用就是实现每次请求都自动把 token 添加到 header 的 Aturhorization 中。除此之外还可以做好多好多东西，这里就不详细介绍下去了。</p>
<h2 id="使用-ui-router-替代-ngRoute"><a href="#使用-ui-router-替代-ngRoute" class="headerlink" title="使用 ui-router 替代 ngRoute"></a>使用 ui-router 替代 ngRoute</h2><p>自从用了 ui-router 就再也回不去 ngRoute 了，ui-router 使用状态来进行转移，支持多视图和嵌套视图，使用方法更加灵活，并且也有更加丰富的 API。多视图，嵌套视图你知道意味什么吧，这些 ngRoute 做不到，官方现在也是主推 ui-router，前段时间 ui-router 已经出了新的 1.0 版本，相信大部分开发者还是在用老版本吧，可以考虑迁移了，想要了解新版本的迁移事项看<a href="https://ui-router.github.io/guide/ng1/migrate-to-1_0" target="_blank" rel="external">这里</a>。</p>
<p>对于还在使用 ngRoute 的童鞋，我也强烈建议你去使用 ui-router。</p>
<p>多视图和嵌套视图就不多说了，除此之外还有比较强大实用的地方就是 ui-router 提供的生命周期钩子即 <code>$stateChangeStart</code>, <code>$stateChangeSuccess</code>, <code>$stateChangeError</code>，ngRoute 不知道有没有，没有去了解过。下面举个粟子说下用法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">$rootScope.$on(<span class="string">"$stateChangeStart"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event, toState, toStateParams, fromState, fromStateParams</span>) </span>&#123;</div><div class="line">    $rootScope.loading = <span class="literal">true</span>;</div><div class="line">&#125;);</div><div class="line">$rootScope.$on(<span class="string">"$stateChangeSuccess"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event, toState, toStateParams, fromState, fromParams</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(ga) &#123;</div><div class="line">    <span class="keyword">let</span> re = <span class="regexp">/\&#123;(.*?)&#125;/g</span>, url;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">Object</span>.keys(toStateParams).length &gt; <span class="number">0</span>) &#123;</div><div class="line">      url = toState.url.replace(re, <span class="built_in">Object</span>.values(toStateParams).reduce(<span class="function">(<span class="params">pre, curr</span>) =&gt;</span> curr));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      url = toState.url;</div><div class="line">    &#125;</div><div class="line">    ga(<span class="string">'send'</span>, <span class="string">'pageview'</span>, url);</div><div class="line">  &#125;</div><div class="line">  $rootScope.loading = <span class="literal">false</span>;</div><div class="line">&#125;);</div><div class="line">$rootScope.$on(<span class="string">"$stateChangeError"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event, toState, toStateParams, fromState, fromParams, error</span>) </span>&#123;</div><div class="line">  $rootScope.loading = <span class="literal">false</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>其实上面应该时比较 tricky 的做法，作用就是全局视图切换动画以及让 google analysis 工作，从 <code>stateChangeStart</code> 开始，<code>isLoading</code> 变为 true 直到 <code>stateChangeSuccess</code> 的时候变为 false。我们把 <code>isLoading</code> 挂在 <code>$rootScope</code> 上面方便使用，用这个变量就可以判断是否加载一个 Loading 的 DOM。</p>
<p>其次，由于单页应用特性，google analysis 只被加载一次从而无法实时反馈用户当前所访问的页面，我们可以手动进行调用，上面就是用法了，也是每次在成功状态变化之后发送当前 url。</p>
<p>不过遗憾的是这个 API 在 ui-router 1.0 版本废弃了，不过 ui-router 1.0 目录下带了另一个文件，引入这个文件即可以继续使用。我猜测 ui-router 1.0 应该是有更好的解决方案来替代它，详细的可以自己去了解下。</p>
<p>另外还想说的一个地方就是 ui-router 的 resolve 功能，允许我们在控制器初始化之前先获取和处理数据，如果 resolve 的东西是一个 promise，如果 promise 状态为 rejected，那么视图就不会被成功切换。基于此我们可以把视图需要的一些 HTTP 请求放到 ui-router 的 resolve 上面来做，然后再注入到控制器给控制器使用，并且这样还可以避免数据未到达时视图的数据显示问题以及数据请求失败后的问题。举个粟子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">.state(<span class="string">'posts'</span>, &#123;</div><div class="line">  <span class="attr">url</span>: <span class="string">'/posts/:type'</span>,</div><div class="line">  <span class="attr">templateUrl</span>: <span class="string">'posts/posts_tpl.html'</span>,</div><div class="line">  <span class="attr">controller</span>: <span class="string">'PostsController as vm'</span>,</div><div class="line">  <span class="attr">resolve</span>: &#123;</div><div class="line">    <span class="attr">posts</span>: <span class="function"><span class="keyword">function</span>(<span class="params">Posts, $stateParams, $q</span>) </span>&#123;</div><div class="line">      <span class="keyword">let</span> defer = $q.defer();</div><div class="line">      <span class="keyword">if</span>([<span class="string">'unread'</span>, <span class="string">'mark'</span>].indexOf($stateParams.type) !== <span class="number">-1</span>) &#123;</div><div class="line">        defer.resolve(Posts.get(&#123;<span class="attr">type</span>: $stateParams.type&#125;).$promise);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        defer.reject(<span class="string">'参数不正确'</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> defer.promise;</div><div class="line">    &#125;,</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这是一个路由的状态，这里应用了 promise 的反模式，其实我自己也不是特别了解，之前看到一篇文章再批评这个。我回去学习下再补充。</p>
<p>这个地方的作用就是判断 state 传进的参数是否符合要求，如果不符合要求则无法加载，符合要求的话就会去请求资源，如果请求失败的话视图也不会被加载，即状态不会切换成功，如果请求成功我们可以再控制器依赖注入 <code>posts</code> 取得返回结果。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;搞了快一年的 Angular，Angular 真的是一个非常强大非常齐全非常好用的框架，而且拥有强大的社区支持，虽然踩了很多坑，但是仍然无悔学习了这样一个框架。Angular 2 已经正式发布了，我也打算学 Angular2 去了，现在手头上还有一个用 Angular 的项目，这个项目我是想把我学到的很多 Angular 的最佳实践都用进去，借此我就想干脆也写几篇博客总结下好了，我写的比较散，想到什么就说什么。&lt;/p&gt;
&lt;h2 id=&quot;使用单次绑定或单向绑定&quot;&gt;&lt;a href=&quot;#使用单次绑定或单向绑定&quot; class=&quot;headerlink&quot; title=&quot;使用单次绑定或单向绑定&quot;&gt;&lt;/a&gt;使用单次绑定或单向绑定&lt;/h2&gt;&lt;p&gt;从 Angular 1.3 开始就有了 once-time binding，Angular 1.5 开始支持了指令和组件的 one-way binding。看看他们的用法：&lt;/p&gt;
&lt;p&gt;单次绑定很简单，加上&lt;code&gt;::&lt;/code&gt; 就可以了。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;p&amp;gt;&amp;#123;&amp;#123;::vm.title&amp;#125;&amp;#125;&amp;lt;&lt;span class=&quot;regexp&quot;&gt;/p&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;An expression that starts with &lt;code&gt;::&lt;/code&gt; is considered a one-time expression. One-time expressions will stop recalculating once they are stable, which happens after the first digest if the expression result is a non-undefined value (see value stabilization algorithm below).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当 digest 结束之后并且单次绑定的值不为 undefined 时，这个值将不再被监听。官方称这个算法为 &lt;code&gt;Value stabilization algorithm&lt;/code&gt; 还解释了一下。看到这个，再想起 Angular 源码那注释，觉得真的业界良心啊。想具体了解下单次绑定，出门右转 -&amp;gt; &lt;a href=&quot;https://docs.angularjs.org/guide/expression&quot;&gt;docs.angularjs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在视图进行单向绑定也很简单，使用 &lt;code&gt;ng-bind&lt;/code&gt; 就可以了，这里主要说的是指令和组件中的单向绑定。&lt;/p&gt;
&lt;p&gt;其实 Angular1 还是不断再发展，现在最新的是 1.5.9，加了很多新的东西，也做了很多性能优化。单向绑定也是 1.5 之后才引入的新东西。1.5 也引入了一个新的东西叫 component，和 directive 差不多，具体我没用过我也不太了解，不过写法简洁了很多。单向绑定主要就是用于 component 和 directive 的。&lt;/p&gt;
&lt;p&gt;随便找个比较简单的例子来说下，&lt;/p&gt;
    
    </summary>
    
      <category term="Angular" scheme="https://ruiming.github.io/categories/Angular/"/>
    
    
      <category term="Angular" scheme="https://ruiming.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>Angular1之折腾记</title>
    <link href="https://ruiming.github.io/2016/09/24/Angular1%E4%B9%8B%E6%8A%98%E8%85%BE%E8%AE%B0/"/>
    <id>https://ruiming.github.io/2016/09/24/Angular1之折腾记/</id>
    <published>2016-09-24T15:40:50.000Z</published>
    <updated>2016-11-16T16:08:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>前几天 Angular2 正式发布了，虽然他也在我的学习计划里面，但我并没有把他应用在我最近开展的一个项目中。最近在写一个 Rss 订阅器，基于 Angular1 和 Koa2(总感觉两个有点不搭 =.= )，主要是不想在这个项目花太长时间，再者我还想集我目前掌握的所有技术之大成写一个能拿的出手的项目，所以就没有选择 Angular2 了。至于 Koa2，其实很早就想学了，只是之前一直在忙别的。</p>
<h2 id="angular-resource-介绍"><a href="#angular-resource-介绍" class="headerlink" title="angular-resource 介绍"></a>angular-resource 介绍</h2><p>今天捣鼓 Angular 的 Resource 功能，前端后端都掌握在自己的手上时去用 Angular 的 Resource 特别舒服，大大减少了代码量，特么强大。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    angular</div><div class="line">        .module(<span class="string">'app'</span>)</div><div class="line">        .factory(<span class="string">'Post'</span>, $resource =&gt; &#123;</div><div class="line">            <span class="keyword">return</span> $resource(<span class="string">'/api/feed/:feed_id/post/:id'</span>, &#123;<span class="attr">id</span>: <span class="string">'@_id'</span>&#125;, &#123;</div><div class="line">                <span class="attr">update</span>: &#123;<span class="attr">method</span>: <span class="string">'PUT'</span>&#125;,</div><div class="line">                <span class="attr">get</span>: &#123;<span class="attr">method</span>: <span class="string">'GET'</span>, <span class="attr">cache</span>: <span class="literal">true</span>&#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;)</div><div class="line">&#125;());</div></pre></td></tr></table></figure></p>
<p>在上面我定义了一个 <code>Post</code> 资源，一旦创建完成后，他就自动拥有了以下方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="string">'get'</span>: &#123;<span class="attr">method</span>: <span class="string">'GET'</span>&#125;,</div><div class="line">	<span class="string">'save'</span>: &#123;<span class="attr">method</span>: <span class="string">'POST'</span>&#125;,</div><div class="line">	<span class="string">'query'</span>: &#123;<span class="attr">method</span>: <span class="string">'GET'</span>, <span class="attr">isArray</span>: <span class="literal">true</span>&#125;,</div><div class="line">	<span class="string">'remove'</span>: &#123;<span class="attr">method</span>: <span class="string">'DELETE'</span>&#125;,</div><div class="line">	<span class="string">'delete'</span>: &#123;<span class="attr">method</span>: <span class="string">'DELETE'</span>&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有些 IE 浏览器可能不支持 <code>delete</code>，这时候可以使用 <code>remove</code>。<br>我们还可以自定义或者修改里面的方法，比如我上面中就自定义了一个 <code>update</code> 方法以及给 <code>get</code> 方法开启了缓存。</p>
<a id="more"></a>
<p>那怎么使用呢？也很简单，如果对 <code>restfulAPI</code> 比较熟悉应该很容易理解。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$stateProvider</div><div class="line">	.state(<span class="string">'feed.post'</span>, &#123;</div><div class="line">	      <span class="attr">url</span>: <span class="string">'/post/:post_id'</span>,</div><div class="line">	      <span class="attr">templateUrl</span>: <span class="string">'post/post_tpl.html'</span>,</div><div class="line">	      <span class="attr">controller</span>: <span class="string">'PostController as vm'</span>,</div><div class="line">	      <span class="attr">resolve</span>: &#123;</div><div class="line">	          <span class="attr">post</span>: <span class="function"><span class="keyword">function</span>(<span class="params">Post, $stateParams, $state</span>) </span>&#123;</div><div class="line">	              <span class="keyword">return</span> Post.get(&#123;<span class="attr">feed_id</span>: $stateParams.id, <span class="attr">id</span>: $stateParams.post_id&#125;).$promise;</div><div class="line">	          &#125;</div><div class="line">	      &#125;</div><div class="line">	  &#125;)</div></pre></td></tr></table></figure>
<p>这里就调用了 <code>get</code> 方法，同时把参数传入，这样就好了。其他方法其实一样的。<br><code>resource</code> 也有很多功能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$resource(url, [paramDefaults], [actions], options);</div></pre></td></tr></table></figure>
<p>第二个参数设置默认参数用，比如我们发起了一个 <code>get</code> 请求得到数据，这条数据有一个 <code>_id</code> 属性，我们可以把他绑定为默认的 <code>id</code> 参数，这样在之后执行该资源的其他方法时我们可以不指定 <code>id</code>。<br>第三个参数就是自定义方法的地方了，前面我给 <code>get</code> 方法升级了下，是这样的，这个也就是第三个参数了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$resource(<span class="string">'/api/feed/:feed_id/post/:id'</span>, &#123;<span class="attr">id</span>: <span class="string">'@_id'</span>&#125;, &#123;</div><div class="line">    <span class="attr">update</span>: &#123;<span class="attr">method</span>: <span class="string">'PUT'</span>&#125;,</div><div class="line">    <span class="attr">get</span>: &#123;<span class="attr">method</span>: <span class="string">'GET'</span>, <span class="attr">cache</span>: <span class="literal">true</span>&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>格式是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="attr">action1</span>: &#123;<span class="attr">method</span>:?, <span class="attr">params</span>:?, <span class="attr">isArray</span>:?, <span class="attr">headers</span>:?, ...&#125;,</div><div class="line"> <span class="attr">action2</span>: &#123;<span class="attr">method</span>:?, <span class="attr">params</span>:?, <span class="attr">isArray</span>:?, <span class="attr">headers</span>:?, ...&#125;,</div><div class="line"> ...&#125;</div></pre></td></tr></table></figure>
<p>更多说明参考<a href="https://docs.angularjs.org/api/ngResource/service/$resource" target="_blank" rel="external">官方文档</a>咯。<br>第四个参数没看明白，可以自己看下官方文档。</p>
<h2 id="angular-resource-缓存问题"><a href="#angular-resource-缓存问题" class="headerlink" title="angular-resource 缓存问题"></a>angular-resource 缓存问题</h2><p>上一个项目没有用 angular-resource 的时候，我就在 factory 里面缓存 response，下次请求时直接返回该 response。由于用户所操作的和所缓存的都是同一个对象，因此在进行一些对该 response 的修改时比如，用户进行点赞操作，那么我除了发出一个请求之外，我还要将 response 里的是否点赞的值修改过来，这样视图才能反映出来，由于和缓存是同一份东西，因此实现了缓存的同步变化。<br>但不知道是不是这种方式容易导致缓存被破坏还是怎么样，我看了下 angular 以及 angular-resource 的部分源码，发现 angular 在处理 http 缓存时对数据进行了 serialize 操作，而且第一次返回给用户的并不是缓存的结果，而是自己 resource 里面的东西，下次访问时才从缓存取出来后 deserialize 后返回。<br>关于这个问题其实老早就有人发出 issue 了，但官方并没有回应，目前比较好的解决方案就是在修改资源时，删除缓存。可以这样操作:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $httpDefaultCache = $cacheFactory.get(<span class="string">'$http'</span>);</div><div class="line">$httpDefaultCache.remove(key)；</div><div class="line"><span class="comment">// The cache key is the request URL including search parameters;</span></div></pre></td></tr></table></figure>
<p>那有没有更好的办法呢，其实我也想过，有想到用缓存数据替代返回到控制器的数据，然而从这个尝试开始就发现了很多很坑的地方。<br>我在 httpInjector 里面拦截 response 加入了这么一段代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">     <span class="comment">// 只对 resource 的 cache 进行处理</span></div><div class="line">     <span class="keyword">if</span>(config.config &amp;&amp; config.config.cache === <span class="literal">true</span>) &#123;</div><div class="line">         <span class="keyword">let</span> url = config.config.url;</div><div class="line">         $cacheFactory.get(<span class="string">'$http'</span>).get(url)[<span class="number">1</span>] = angular.fromJson($cacheFactory.get(<span class="string">'$http'</span>).get(url)[<span class="number">1</span>]);</div><div class="line">         config.resource.data = $cacheFactory.get(<span class="string">'$http'</span>).get(url)[<span class="number">1</span>].data;</div><div class="line">         config.config.data = $cacheFactory.get(<span class="string">'$http'</span>).get(url)[<span class="number">1</span>].data;</div><div class="line">         config.data = $cacheFactory.get(<span class="string">'$http'</span>).get(url)[<span class="number">1</span>].data;</div><div class="line">         <span class="built_in">console</span>.log($cacheFactory.get(<span class="string">'$http'</span>).get(url));</div><div class="line">     &#125;</div><div class="line"> &#125;);</div></pre></td></tr></table></figure></p>
<p>作用就时强制 serialize 缓存的数据，然后讲全部数据都替换成缓存中的数据，由于在这一阶段并没有开始缓存，所以要设置 setTimeout 推迟操作。<br>这样做了之后，对第一次加载仍然没有什么影响，但第二次加载时就开始起作用了，更改会同步变化到缓存，其实就是之后用的就直接是缓存的对象，而不再是 deserialize 化后的数据，这一步应该归功于我修改了缓存中数据的存储形式。<br>由于第一次返回给控制器的数据并不是从缓存取出来的，而是从 resource 里面取出来的即上面的 <code>config.resource.data</code>，所以我也把他改到缓存中的对象去。为了更好说明问题，我把控制器代码也贴上来。我的目的就是进行 mark 操作后缓存也会自动同步过来。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    angular</div><div class="line">        .module(<span class="string">'app'</span>)</div><div class="line">        .controller(<span class="string">'PostController'</span>, PostController);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">PostController</span>(<span class="params">$state, post, Post, $scope, _, $rootScope, $timeout, $cacheFactory</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> vm = <span class="keyword">this</span>;</div><div class="line">        vm.post = post;</div><div class="line">		</div><div class="line">		vm.mark = mark;</div><div class="line">		</div><div class="line">        vm.currentPost = post.data.result;</div><div class="line">        vm.currentPostDetail = post.data.detail;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">mark</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            vm.currentPostDetail.mark = !vm.currentPostDetail.mark;</div><div class="line">            Post.update(&#123;<span class="attr">feed_id</span>: vm.currentPost.feed_id[<span class="number">0</span>], <span class="attr">id</span>: vm.currentPost._id&#125;, &#123;<span class="attr">type</span>: <span class="string">'mark'</span>&#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;());</div></pre></td></tr></table></figure></p>
<p>按理说，控制器初始化的时候 <code>post</code> 是一个 resource 对象，我在 <code>setTimeout</code> 中修改了 resource 内部的数据，指向到缓存中被 serialize 化的数据。而 <code>vm.currentPost</code> 和 <code>vm.currentPostDetail</code> 又是分别指向 <code>post.data.result</code> 和 <code>post.data.detail</code>，应该我在 <code>vm</code> 上面的操作可以影响到缓存才对，然而并不能。试试看修改 <code>mark</code> 方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mark</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    vm.currentPostDetail.mark = !vm.currentPostDetail.mark;</div><div class="line">    post.data.detail.mark = !post.data.detail.mark;</div><div class="line">    Post.update(&#123;<span class="attr">feed_id</span>: vm.currentPost.feed_id[<span class="number">0</span>], <span class="attr">id</span>: vm.currentPost._id&#125;, &#123;<span class="attr">type</span>: <span class="string">'mark'</span>, <span class="attr">revert</span>: <span class="literal">true</span>&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也就是加了一句话，更改 <code>post</code> 中的数据。结果是工作了！这说明 post 确实此时是指向缓存的。那 <code>vm.currentPostDetail</code> 也是指向 <code>post.data.detail</code> 的，为什么它不工作？<br>其实这不是 angular 的锅，console 试试下面就知道了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">pre = &#123;<span class="attr">status</span>: <span class="number">200</span>, <span class="attr">result</span>: &#123;<span class="attr">detail</span>: &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;, <span class="attr">result</span>: &#123;<span class="attr">b</span>:<span class="number">2</span>&#125;&#125;&#125;;</div><div class="line">ctrl = pre.result.detail;		<span class="comment">// &#123;a:1&#125;</span></div><div class="line">cache = &#123;<span class="attr">status</span>: <span class="number">200</span>, <span class="attr">result</span>: &#123;<span class="attr">detail</span>: &#123;<span class="attr">a</span>:<span class="number">2</span>&#125;, <span class="attr">result</span>: &#123;<span class="attr">b</span>:<span class="number">3</span>&#125;&#125;&#125;;</div><div class="line">pre = cache;</div><div class="line"><span class="built_in">console</span>.log(ctrl);				<span class="comment">// &#123;a:1&#125;</span></div></pre></td></tr></table></figure></p>
<p>应该不止我一个人会认为最后结果应该是 <code>{a: 2}</code> 吧…其实上面还可以再简化成这样<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</div><div class="line">b = a;</div><div class="line">a = &#123;<span class="attr">a</span>:<span class="number">2</span>&#125;;</div><div class="line"><span class="built_in">console</span>.log(b);		<span class="comment">// &#123;a:1&#125;</span></div></pre></td></tr></table></figure></p>
<p>画一个图的话是这样子的。<br><img src="/2016/09/24/Angular1之折腾记/object.png" alt="object" title="object"><br>这样应该就明了了，所以由于控制器第一次取到的 response 一定是 resource 内部的结果，而 httpInjector 是在返回 response 前进行修改，因此我们无法通过 httpInjector 来达到目的。唯一能做到的方法就是让控制器接受到的结果与缓存指向同一内存，假设 $cacheFactory 缓存 http 的结果没有被序列化，那么将 resource 中的数据加入缓存，同时把这个数据返回给控制器，就实现了控制器数据和缓存数据指向一致的目的，所以最终问题还是在 $cacheFactory 把结果给序列化了再存储。<br>为了验证下我们的说法，可以修改下 angular 源码下面的地方:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">done</span>(<span class="params">status, response, headersString, statusText</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (cache) &#123;</div><div class="line">        <span class="keyword">if</span> (isSuccess(status)) &#123;</div><div class="line">        cache.put(url, [status, response, parseHeaders(headersString), statusText]);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// remove promise from the cache</span></div><div class="line">        cache.remove(url);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolveHttpPromise</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        resolvePromise(response, status, headersString, statusText);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (useApplyAsync) &#123;</div><div class="line">        $rootScope.$applyAsync(resolveHttpPromise);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        resolveHttpPromise();</div><div class="line">        <span class="keyword">if</span> (!$rootScope.$$phase) $rootScope.$apply();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>把这一行<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cache.put(url, [status, response, parseHeaders(headersString), statusText]);</div></pre></td></tr></table></figure></p>
<p>改为<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cache.put(url, [status, angular.fromJson(response), parseHeaders(headersString), statusText]);</div></pre></td></tr></table></figure></p>
<p>之后就会发现，从第二次开始缓存的数据就会同步变更了，因为存的是对象，所以下次从缓存取的时候就直接用的对象，所以就可以保持数据的同步了。但第一次还是不行，我也没有再深究下去了，源码有点绕，看不太懂。<br>另外，过程中曾经有想利用 <code>$stateChangeStart</code> 和 <code>$stateChangeSuccess</code> 着手，但是发现这两个事件没有效果，查了资料才知道，<code>ui-router</code> 的新版本(1.0)已经有较大的变化，不再支持上面的事件，而是转而通过 <code>$transition</code> 来操作。如果你还在用老版本的 <code>ui-router</code>，可以试试看这个新版本的，迁移可以参考<a href="https://ui-router.github.io/guide/ng1/migrate-to-1_0#state-change-events" target="_blank" rel="external">这里</a>。</p>
<p>花了好几个小时想尝试解决这个问题都没搞定，现在还是搞不懂为什么 angular 要把数据序列化后缓存，是为了数据的稳定吗？如果可以提供一个 option 来设置不是很好吗？不知道有没有什么解决方案，一直没找着，貌似是因为缓存的数据就不应该被修改，但在一些场景它还是有应用用途的吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天 Angular2 正式发布了，虽然他也在我的学习计划里面，但我并没有把他应用在我最近开展的一个项目中。最近在写一个 Rss 订阅器，基于 Angular1 和 Koa2(总感觉两个有点不搭 =.= )，主要是不想在这个项目花太长时间，再者我还想集我目前掌握的所有技术之大成写一个能拿的出手的项目，所以就没有选择 Angular2 了。至于 Koa2，其实很早就想学了，只是之前一直在忙别的。&lt;/p&gt;
&lt;h2 id=&quot;angular-resource-介绍&quot;&gt;&lt;a href=&quot;#angular-resource-介绍&quot; class=&quot;headerlink&quot; title=&quot;angular-resource 介绍&quot;&gt;&lt;/a&gt;angular-resource 介绍&lt;/h2&gt;&lt;p&gt;今天捣鼓 Angular 的 Resource 功能，前端后端都掌握在自己的手上时去用 Angular 的 Resource 特别舒服，大大减少了代码量，特么强大。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    angular&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        .module(&lt;span class=&quot;string&quot;&gt;&#39;app&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        .factory(&lt;span class=&quot;string&quot;&gt;&#39;Post&#39;&lt;/span&gt;, $resource =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; $resource(&lt;span class=&quot;string&quot;&gt;&#39;/api/feed/:feed_id/post/:id&#39;&lt;/span&gt;, &amp;#123;&lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;@_id&#39;&lt;/span&gt;&amp;#125;, &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;attr&quot;&gt;update&lt;/span&gt;: &amp;#123;&lt;span class=&quot;attr&quot;&gt;method&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;PUT&#39;&lt;/span&gt;&amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;attr&quot;&gt;get&lt;/span&gt;: &amp;#123;&lt;span class=&quot;attr&quot;&gt;method&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;GET&#39;&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;cache&lt;/span&gt;: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;());&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在上面我定义了一个 &lt;code&gt;Post&lt;/code&gt; 资源，一旦创建完成后，他就自动拥有了以下方法。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&#39;get&#39;&lt;/span&gt;: &amp;#123;&lt;span class=&quot;attr&quot;&gt;method&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;GET&#39;&lt;/span&gt;&amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&#39;save&#39;&lt;/span&gt;: &amp;#123;&lt;span class=&quot;attr&quot;&gt;method&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;POST&#39;&lt;/span&gt;&amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&#39;query&#39;&lt;/span&gt;: &amp;#123;&lt;span class=&quot;attr&quot;&gt;method&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;GET&#39;&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;isArray&lt;/span&gt;: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&#39;remove&#39;&lt;/span&gt;: &amp;#123;&lt;span class=&quot;attr&quot;&gt;method&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;DELETE&#39;&lt;/span&gt;&amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&#39;delete&#39;&lt;/span&gt;: &amp;#123;&lt;span class=&quot;attr&quot;&gt;method&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;DELETE&#39;&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;有些 IE 浏览器可能不支持 &lt;code&gt;delete&lt;/code&gt;，这时候可以使用 &lt;code&gt;remove&lt;/code&gt;。&lt;br&gt;我们还可以自定义或者修改里面的方法，比如我上面中就自定义了一个 &lt;code&gt;update&lt;/code&gt; 方法以及给 &lt;code&gt;get&lt;/code&gt; 方法开启了缓存。&lt;/p&gt;
    
    </summary>
    
      <category term="Angular" scheme="https://ruiming.github.io/categories/Angular/"/>
    
    
      <category term="Angular" scheme="https://ruiming.github.io/tags/Angular/"/>
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>提升网站加载速度的 N 个方法</title>
    <link href="https://ruiming.github.io/2016/09/11/%E6%8F%90%E5%8D%87%E7%BD%91%E7%AB%99%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E7%9A%84%20N%20%E4%B8%AA%E6%96%B9%E6%B3%95/"/>
    <id>https://ruiming.github.io/2016/09/11/提升网站加载速度的 N 个方法/</id>
    <published>2016-09-11T05:53:33.000Z</published>
    <updated>2016-09-29T05:07:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>Web 这几年的一个变化之一估计就是各种优化小技巧不断涌出…自己也琢磨和尝试了不少优化，毕竟自己项目的网页首屏加载也是一度接近 2M 的。以下针对 HTTP1 和 HTTP1.1，在 HTTP2 中，很多最佳实践都适得其反了。</p>
<h2 id="减少文件传输数量"><a href="#减少文件传输数量" class="headerlink" title="减少文件传输数量"></a>减少文件传输数量</h2><p>现在前端代码发布上线的时候一般都会进行压缩，混淆，合并等操作，他们起到了减少文件体积和数量以及混淆代码降低可读性的作用。</p>
<p>浏览器针对同一域名的并发请求数目是有限制的，而在 HTTP1 和 HTTP1.1 中每传输一个资源就得建立一条连接。因此当网站的请求资源数量过多时，会导致后面资源请求的阻塞，也会导致频繁的连接建立和关闭带来的开销。一般浏览器的并发请求数量在4-8之间。因此我们针对同一域名的资源不宜过多，否则就会导致后面资源的阻塞。</p>
<p>针对该问题，我们可以采用合并文件，将资源分到不同域名，缓加载资源，提前加载资源，缓存等手段。具体如下：</p>
<ol>
<li>合并文件以减少并发请求数量<br> 合并文件也不能简单粗暴的合并为一个，对于长时间不会改变的文件我们要单独合并出来，这个文件是可以进行长期缓存的，而一些变动较为频繁的我们就不应该和上面的这些文件合并在一起，并且他们也不应该设置过激的缓存策略。</li>
<li>将次要文件延迟加载，比如 Google Analysis<br> 一些无关痛痒的文件可以放到页面最尾部，这是最佳实践，这里特别想提一下 async 和 defer，他们并没有对文件的请求产生影响，只是影响了执行的过程，所以我们不应该使用 async 或者 defer 方法来优化。 <img src="/2016/09/11/提升网站加载速度的%20N%20个方法/async-defer.jpg" alt="async-defer" title="async-defer">
 使用 async，会立即开始并行加载，加载完成后会进行执行并阻塞主渲染进程。<br> 使用 defer，会立即开始并行加载，但会延迟到最后才执行。</li>
<li>分散资源到不同域名<br> 比如图片有专门的域名(img.xxx.com)来存储。一些资源可以考虑第三方 CDN 比如 Bootcss 的 CDN，因为这类 CDN 使用较广，有可能用户浏览器已经有过缓存，这就避免了再次请求和加载，同时也减轻了服务器压力。</li>
<li>使用雪碧图(css sprites)来合并小图片<br> 这个优化技术其实挺常见，将图片合并为一个后使用 background-image 和 background-position 等来控制显示雪碧图的哪一部分就好了，据说还可以自动生成雪碧图自动定位。</li>
<li>利用 200 缓存<br> 这是一个比较极端的缓存方式，200 缓存时浏览器不发出网络请求，直接调用本地缓存，这需要强制浏览器使用本地缓存。我们可以使用 Expires 标志。即给出日期时间，超出该时间后则认为是过时，浏览器才会重新发起请求。这个具体细节我还不太了解。过后补充。</li>
<li>使用懒加载(lazy load)<br> 很多网站特别是有大量图片的网站都会使用该技术。当用户下滑页面时，才开始加载下面的图片。一来减少了页面加载的请求数和加载时间，二来也减少用户流量。不过可能有人会说这样体验不太好，好在业内有人把这个技术做到了堪称极致的地步，就是预先加载一个高度压缩的原图，然后淡出原图。大家应该有体验到类似的技术，就不多说了。</li>
<li><p>使用预加载技术(prefetch)<br> 这个技术知道的人可能不多，MDN 上面是这样解释的：</p>
<blockquote>
<p>页面资源预加载(Link prefetch)是浏览器提供的一个技巧，目的是让浏览器在空闲时间下载或预读取一些文档资源，用户在将来将会访问这些资源。一个Web页面可以对浏览器设置一系列的预加载指示，当浏览器加载完当前页面后，它会在后台静悄悄的加载指定的文档，并把它们存储在缓存里。当用户访问到这些预加载的文档后，浏览器能快速的从缓存里提取给用户。</p>
</blockquote>
<p> 不过资源预加载其实使用的并不多，可能是因为技术本身不成熟，浏览器支持不够等原因。目前没有发现有哪个网站使用了这个技术。感兴趣的自己去了解下，这里不多阐述这个技术。</p>
</li>
<li>集中加载资源<br> 额，这个名字是我自己起的，姑且我认为也是一种优化手段，主要针对的时 SPA。比如 Angular 搭建的 SPA。Angular 提供了 templateCache 这个模块。这个在前面的博客中已经介绍过，简单说就是一个数组，我们把模板全部都预先放入这个数组中。Angular 在请求页面的时候会先检查 templateCache 是否已经缓存了，如果有则直接调用这个缓存的模板，否则发出网络请求获取该模板，同时会放入 templateCache 中缓存。有人可能会问那不是增加了首屏加载的体积大小了吗？的确，但比起用户每点击一个新的页面就发起一个请求而言，这种方式无疑会更适合不是吗？并且如果你的文件确实太大了，那你应该考虑下你是否充分利用了指令功能。</li>
</ol>
<h2 id="减少文件大小"><a href="#减少文件大小" class="headerlink" title="减少文件大小"></a>减少文件大小</h2><p>除了减少文件数量，减少文件大小也同样重要，不过比起合并文件这样简单的减少文件数量的操作，减少文件大小就没来的那么简单了。常用的方法如下：<br><a id="more"></a></p>
<ol>
<li><p>开启 GZIP 压缩<br> GZIP 压缩应用非常广泛，因其可以有效明显的减少文件的体积。在 Nginx 中，我们可以很简单的进行配置开启 GZIP 压缩。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">gzip on;</div><div class="line">gzip_vary on;</div><div class="line">gzip_comp_level 4;</div><div class="line">gzip_buffers 16 8K;</div><div class="line">gzip_min_length 1k;</div><div class="line">gzip_proxied any;</div><div class="line">gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;</div><div class="line">gzip_disable <span class="string">"MSIE [1-6]\."</span>;</div></pre></td></tr></table></figure>
<p> 这是我项目服务器上面 Nginx 关于 gzip 的配置。我们关心的当然还是压缩前后文件大小的差异，找别人的一个图贴下：</p>
 <img src="/2016/09/11/提升网站加载速度的%20N%20个方法/gzip_comp_level.png" alt="gzip_comp_level" title="gzip_comp_level">
<p> 可以看到效果还是很明显的，一般 GZIP 等级不宜高于 4 级。因为压缩意味着浏览器下载后还需要解压，所以压缩等级过高反而会带来性能问题（移动端耗电增加）甚至是降低页面渲染（解压占用CPU影响页面渲染且耗时）。<br> 另外，大文件压缩效果更明显，所以合并文件后再压缩会比分开压缩效果要好。</p>
</li>
<li><p>使用 WebP 格式图片<br> WebP 是 Google 推出的一种同时提供有损压缩与无损压缩的图片文件格式。根据 Google 较早的测试，无损压缩后的 WebP 比 PNG 文件少了45%的文件大小，即使这些 PNG 文件经过其他压缩工具压缩之后，WebP 还是可以减少28%的文件大小。</p>
 <img src="/2016/09/11/提升网站加载速度的%20N%20个方法/WebP.png" alt="WebP" title="WebP">
<p> WebP 在互联网上已经非常流行，主流浏览器都已经支持，并且国内也有大量站点如淘宝网，腾讯网，QQ空间等等都使用了这一格式。另外，针对不支持的浏览器，也可以引入相应的 shim 解决。</p>
 <img src="/2016/09/11/提升网站加载速度的%20N%20个方法/WebP支持情况.png" alt="WebP支持情况" title="WebP支持情况">
</li>
<li><p>书写压缩友好的代码<br> 这个对开发人员就要较高的要求了，并且如果不是对文件体积有很大的要求一般都不会做到这一步。在代码压缩的过程有一步就是进行变量替换，举一个前面博客中的例子来说</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">	<span class="keyword">var</span> ArrayProto = <span class="built_in">Array</span>.prototype, ObjProto = <span class="built_in">Object</span>.prototype;</div><div class="line"><span class="keyword">var</span> SymbolProto = <span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">'undefined'</span> ? <span class="built_in">Symbol</span>.prototype : <span class="literal">null</span>;</div><div class="line"><span class="keyword">var</span> push = ArrayProto.push,</div><div class="line">    slice = ArrayProto.slice,</div><div class="line">    toString = ObjProto.toString,</div><div class="line">    hasOwnProperty = ObjProto.hasOwnProperty;</div></pre></td></tr></table></figure>
<p> <code>Array.prototype.push</code> 是无法压缩的，而如果我们赋值 <code>ArrayProto = Array.prototype</code> ，那么 <code>ArrayProto</code> 就可以被替换掉，同理，上面中的 <code>push</code>, <code>slice</code> 等都是对压缩友好的。除此之外，一般的压缩工具还会把 <code>undefined</code>  都替换为 <code>void 0</code>，一来可以避免 <code>underfined</code> 重写的问题，二来字符数少了。目前我比较清楚的就这两个，有兴趣的话可以去了解下压缩的过程，对比下压缩前后。</p>
</li>
<li><p>避免引入无用代码<br>有一种比较常见的场景是我们使用了 FontAweSome 等的文件后，虽然我们可以很方便的通过写 CSS 类名来添加修改图标，但我们用到的毕竟时少数图标，所以其他没有用到的图标的引入就是非必须的。这个我自己没有实践过，可以看看<a href="http://stackoverflow.com/questions/15331525/optimize-font-awesome-for-only-used-classes" target="_blank" rel="external">Optimize Font Awesome for only used classes</a>这里的讨论。<br>除了去做筛选之外，还有的办法就是我们不要引入整个图标文件，有些提供图标的网站可以让你自己选择需要的图标后以字体和 CSS 文件的形式下载下来。这样做就稍微麻烦一点，不过既然你要图文件小，那麻烦一点也没什么。</p>
</li>
</ol>
<h2 id="其他-Web-提速手段"><a href="#其他-Web-提速手段" class="headerlink" title="其他 Web 提速手段"></a>其他 Web 提速手段</h2><p>前面集中就文件请求数和文件体积开展讨论，其实还远远不止上面这些办法。常用的还有以下这些。</p>
<ol>
<li><p>dns-prefetch<br> 这个其实和前面说的资源预加载差不多，只是这个是 DNS 预解析。用户访问一个新的域名之前，会首先通过 DNS 解析得到他的 IP 地址，之后才开始建立连接。DNS 解析也是需要时间的，而这个技术的作用就是在用户页面空闲的时候去预获取 IP 地址并缓存，这样当访问该域名页面的时候，就不需要再解析域名，从而缩短了页面加载时间。</p>
 <img src="/2016/09/11/提升网站加载速度的%20N%20个方法/dns-prefetch.png" alt="淘宝网 dns-prefetch" title="淘宝网 dns-prefetch">
</li>
<li><p>Preconnect<br> 这个和上面差不多，但是不光会解析 DNS 还会建立 TCP 握手连接和 TLS 协议(如果需要的话)用法如下：</p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preconnect"</span> <span class="attr">href</span>=<span class="string">"https://ruiming.github.io"</span>&gt;</span></div></pre></td></tr></table></figure>
<p> 但是这个的支持还比较一般，我也没找到有谁使用了这个技术。</p>
 <img src="/2016/09/11/提升网站加载速度的%20N%20个方法/preconnect.png" alt="preconnect" title="preconnect">
<p> 其实类似的预xx技术还挺多，还有预渲染等，感兴趣的可以参考<a href="http://www.alloyteam.com/2015/10/prefetching-preloading-prebrowsing/" target="_blank" rel="external">此处</a></p>
</li>
<li><p>使用第三方 CDN<br> 前面也有稍微提了下 CDN。对于 CDN 的使用应该根据实际情况来，如果整个页面就只引入了两三个第三方库，我们可以考虑使用公共 CDN 比如 Bootcss 的 CDN。其一是真的很快，比七牛什么都快好多，其二是用的人多，可能用户浏览器已经缓存了，另外 Bootcss 的 CDN 默认使用 HTTP2，在支持 HTTP2 的浏览器中，他也可以避免影响我们网站资源并发请求数量的问题，当然如果你也是用 HTTP2 这个问题就不大了。<br> 如果不使用公共 CDN，对于个人也可以使用七牛或者其他的提供的 CDN 存储。CDN 的好处在可以根据用户位置就近分配资源，同时也可以减轻服务器压力。</p>
</li>
</ol>
<hr>
<p>参考资料：<br>WebP 探寻之路: <a href="https://isux.tencent.com/introduction-of-webp.html" target="_blank" rel="external">https://isux.tencent.com/introduction-of-webp.html</a><br>一箩筐的预加载技术: <a href="http://www.alloyteam.com/2015/10/prefetching-preloading-prebrowsing" target="_blank" rel="external">http://www.alloyteam.com/2015/10/prefetching-preloading-prebrowsing</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web 这几年的一个变化之一估计就是各种优化小技巧不断涌出…自己也琢磨和尝试了不少优化，毕竟自己项目的网页首屏加载也是一度接近 2M 的。以下针对 HTTP1 和 HTTP1.1，在 HTTP2 中，很多最佳实践都适得其反了。&lt;/p&gt;
&lt;h2 id=&quot;减少文件传输数量&quot;&gt;&lt;a href=&quot;#减少文件传输数量&quot; class=&quot;headerlink&quot; title=&quot;减少文件传输数量&quot;&gt;&lt;/a&gt;减少文件传输数量&lt;/h2&gt;&lt;p&gt;现在前端代码发布上线的时候一般都会进行压缩，混淆，合并等操作，他们起到了减少文件体积和数量以及混淆代码降低可读性的作用。&lt;/p&gt;
&lt;p&gt;浏览器针对同一域名的并发请求数目是有限制的，而在 HTTP1 和 HTTP1.1 中每传输一个资源就得建立一条连接。因此当网站的请求资源数量过多时，会导致后面资源请求的阻塞，也会导致频繁的连接建立和关闭带来的开销。一般浏览器的并发请求数量在4-8之间。因此我们针对同一域名的资源不宜过多，否则就会导致后面资源的阻塞。&lt;/p&gt;
&lt;p&gt;针对该问题，我们可以采用合并文件，将资源分到不同域名，缓加载资源，提前加载资源，缓存等手段。具体如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;合并文件以减少并发请求数量&lt;br&gt; 合并文件也不能简单粗暴的合并为一个，对于长时间不会改变的文件我们要单独合并出来，这个文件是可以进行长期缓存的，而一些变动较为频繁的我们就不应该和上面的这些文件合并在一起，并且他们也不应该设置过激的缓存策略。&lt;/li&gt;
&lt;li&gt;将次要文件延迟加载，比如 Google Analysis&lt;br&gt; 一些无关痛痒的文件可以放到页面最尾部，这是最佳实践，这里特别想提一下 async 和 defer，他们并没有对文件的请求产生影响，只是影响了执行的过程，所以我们不应该使用 async 或者 defer 方法来优化。 &lt;img src=&quot;/2016/09/11/提升网站加载速度的%20N%20个方法/async-defer.jpg&quot; alt=&quot;async-defer&quot; title=&quot;async-defer&quot;&gt;
 使用 async，会立即开始并行加载，加载完成后会进行执行并阻塞主渲染进程。&lt;br&gt; 使用 defer，会立即开始并行加载，但会延迟到最后才执行。&lt;/li&gt;
&lt;li&gt;分散资源到不同域名&lt;br&gt; 比如图片有专门的域名(img.xxx.com)来存储。一些资源可以考虑第三方 CDN 比如 Bootcss 的 CDN，因为这类 CDN 使用较广，有可能用户浏览器已经有过缓存，这就避免了再次请求和加载，同时也减轻了服务器压力。&lt;/li&gt;
&lt;li&gt;使用雪碧图(css sprites)来合并小图片&lt;br&gt; 这个优化技术其实挺常见，将图片合并为一个后使用 background-image 和 background-position 等来控制显示雪碧图的哪一部分就好了，据说还可以自动生成雪碧图自动定位。&lt;/li&gt;
&lt;li&gt;利用 200 缓存&lt;br&gt; 这是一个比较极端的缓存方式，200 缓存时浏览器不发出网络请求，直接调用本地缓存，这需要强制浏览器使用本地缓存。我们可以使用 Expires 标志。即给出日期时间，超出该时间后则认为是过时，浏览器才会重新发起请求。这个具体细节我还不太了解。过后补充。&lt;/li&gt;
&lt;li&gt;使用懒加载(lazy load)&lt;br&gt; 很多网站特别是有大量图片的网站都会使用该技术。当用户下滑页面时，才开始加载下面的图片。一来减少了页面加载的请求数和加载时间，二来也减少用户流量。不过可能有人会说这样体验不太好，好在业内有人把这个技术做到了堪称极致的地步，就是预先加载一个高度压缩的原图，然后淡出原图。大家应该有体验到类似的技术，就不多说了。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用预加载技术(prefetch)&lt;br&gt; 这个技术知道的人可能不多，MDN 上面是这样解释的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;页面资源预加载(Link prefetch)是浏览器提供的一个技巧，目的是让浏览器在空闲时间下载或预读取一些文档资源，用户在将来将会访问这些资源。一个Web页面可以对浏览器设置一系列的预加载指示，当浏览器加载完当前页面后，它会在后台静悄悄的加载指定的文档，并把它们存储在缓存里。当用户访问到这些预加载的文档后，浏览器能快速的从缓存里提取给用户。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 不过资源预加载其实使用的并不多，可能是因为技术本身不成熟，浏览器支持不够等原因。目前没有发现有哪个网站使用了这个技术。感兴趣的自己去了解下，这里不多阐述这个技术。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;集中加载资源&lt;br&gt; 额，这个名字是我自己起的，姑且我认为也是一种优化手段，主要针对的时 SPA。比如 Angular 搭建的 SPA。Angular 提供了 templateCache 这个模块。这个在前面的博客中已经介绍过，简单说就是一个数组，我们把模板全部都预先放入这个数组中。Angular 在请求页面的时候会先检查 templateCache 是否已经缓存了，如果有则直接调用这个缓存的模板，否则发出网络请求获取该模板，同时会放入 templateCache 中缓存。有人可能会问那不是增加了首屏加载的体积大小了吗？的确，但比起用户每点击一个新的页面就发起一个请求而言，这种方式无疑会更适合不是吗？并且如果你的文件确实太大了，那你应该考虑下你是否充分利用了指令功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;减少文件大小&quot;&gt;&lt;a href=&quot;#减少文件大小&quot; class=&quot;headerlink&quot; title=&quot;减少文件大小&quot;&gt;&lt;/a&gt;减少文件大小&lt;/h2&gt;&lt;p&gt;除了减少文件数量，减少文件大小也同样重要，不过比起合并文件这样简单的减少文件数量的操作，减少文件大小就没来的那么简单了。常用的方法如下：&lt;br&gt;
    
    </summary>
    
      <category term="还不知道分什么类好" scheme="https://ruiming.github.io/categories/%E8%BF%98%E4%B8%8D%E7%9F%A5%E9%81%93%E5%88%86%E4%BB%80%E4%B9%88%E7%B1%BB%E5%A5%BD/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="HTTP" scheme="https://ruiming.github.io/tags/HTTP/"/>
    
      <category term="Web" scheme="https://ruiming.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 Angular 脏检查</title>
    <link href="https://ruiming.github.io/2016/09/04/%E6%B5%85%E8%B0%88%20Angular%20%E8%84%8F%E6%A3%80%E6%9F%A5/"/>
    <id>https://ruiming.github.io/2016/09/04/浅谈 Angular 脏检查/</id>
    <published>2016-09-04T06:57:22.000Z</published>
    <updated>2016-09-09T11:11:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>Angular 的脏值检查机制一直是 Angular 被人诟病的地方，但瑕不掩瑜，Angular 还是一个非常优秀的框架，并且 Angular2 也已经抛弃了这个脏值检查的算法。<br>最近在看《AngularJS 深度剖析与最佳实践》，不得不说是一本很好的书籍，作者在第三章开始讲背后的原理，这里分析了 Angular 的 $digest 函数，即脏检查机制。所以自己也去下载了 Angular 最新的源码去瞧了下，然后做下笔记吧。</p>
<p>首先要注意，Angular 的 digest 的触发不是定时的，只有在指定的事件触发之后才会进入 $digest。基本上我们用的带 <code>$</code> 的东西调用之后都可能会触发 digest。比如我们使用 <code>setTimeout</code> 就不会触发 digest，即当你使用 <code>setTimeout</code> 更改 viewmodel 的值后，它不会同步的反映到用户的视图中去，解决方法有两个，一个是使用 Angular 提供的 <code>$timeout</code> 替代 <code>setTimeout</code>，<code>$timeout</code> 会在执行结束之后自动触发 digest； 另一个方法是手动调用 $apply，$apply 是 Angular 对 digest 的一层封装，我们一般不会直接调用 digest 而是通过使用 $apply 方法。比如对于 <code>setTimeout</code>，我们就可以这样触发 digest。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  $scope.$apply(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    $scope.test = <span class="number">123</span>;</div><div class="line">  &#125;)    </div><div class="line">&#125;, <span class="number">500</span>);</div></pre></td></tr></table></figure></p>
<p>我们看一个例子，这也是 Angular 源码 $digest 部分的一个示例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scope = ...;</div><div class="line">scope.name = <span class="string">'misko'</span>;</div><div class="line">scope.counter = <span class="number">0</span>;</div><div class="line"></div><div class="line">expect(scope.counter).toEqual(<span class="number">0</span>);</div><div class="line">scope.$watch(<span class="string">'name'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue</span>)</span>&#123;</div><div class="line">  scope.counter = scope.counter + <span class="number">1</span>;</div><div class="line">&#125;);</div><div class="line">expect(scope.counter).toEqual(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">// 执行第一次 digest，第一次 digest 会遍历全部的 watcher，并触发上面的方法，从而使的 count+1</span></div><div class="line">scope.$digest();</div><div class="line">expect(scope.counter).toEqual(<span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="comment">// 第二次调用时，由于上一次调用检查 name 不脏，所以不会再去处理</span></div><div class="line">scope.$digest();</div><div class="line">expect(scope.counter).toEqual(<span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="comment">// 第三次调用时，由于 name 发生了变化，使得当前值和上一次保存的值不同，所以会触发起 $watch 方法</span></div><div class="line">scope.name = <span class="string">'adam'</span>;</div><div class="line">scope.$digest();</div><div class="line">expect(scope.counter).toEqual(<span class="number">2</span>);</div></pre></td></tr></table></figure></p>
<p>Angular 的脏值检查过程大致如下：<br>对当前作用域和子作用域上的 <code>$$watchers</code> 进行遍历，<code>$$watches</code> 保存着 scope 上的所有变量以及其 <code>$watch</code> 方法，调用时会取当前值和上一次值进行比较，如果不相等则会调用 <code>$watch</code> 方法，同时会保存当前的值以在下一次进行比较，并且记录此次检查结果为脏。然后重复进行直到数据不脏为止，因此至少要 digest 两次，超出 10 次会报错，可以调高这个次数限制。当数据不再脏即 model 稳定下来之后， Angular 才会开始一次性批量更新 UI。从而减少了浏览器的 repaint 次数，提升性能。</p>
<p>深入到源码来看：<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div></pre></td><td class="code"><pre><div class="line">$digest: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> watch, value, last, fn, get,</div><div class="line">      watchers,</div><div class="line">      length,</div><div class="line">      dirty, ttl = TTL,</div><div class="line">      next, current, target = <span class="keyword">this</span>,</div><div class="line">      watchLog = [],</div><div class="line">      logIdx, asyncTask;</div><div class="line">      </div><div class="line">  beginPhase(<span class="string">'$digest'</span>);</div><div class="line">  $browser.$$checkUrlChange();</div><div class="line">  </div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === $rootScope &amp;&amp; applyAsyncId !== <span class="literal">null</span>) &#123;</div><div class="line">    $browser.defer.cancel(applyAsyncId);</div><div class="line">    flushApplyAsync();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  lastDirtyWatch = <span class="literal">null</span>;</div><div class="line">  </div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    dirty = <span class="literal">false</span>;</div><div class="line">    current = target;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> asyncQueuePosition = <span class="number">0</span>; asyncQueuePosition &lt; asyncQueue.length; asyncQueuePosition++) &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        asyncTask = asyncQueue[asyncQueuePosition];</div><div class="line">        asyncTask.scope.$<span class="built_in">eval</span>(asyncTask.expression, asyncTask.locals);</div><div class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        $exceptionHandler(e);</div><div class="line">      &#125;</div><div class="line">      lastDirtyWatch = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">    asyncQueue.length = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 脏值检查开始</span></div><div class="line">    traverseScopesLoop:</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">      <span class="comment">// 获取当前 scope 的 $$watchers</span></div><div class="line">      <span class="keyword">if</span> ((watchers = current.$$watchers)) &#123;</div><div class="line">        <span class="comment">// process our watches</span></div><div class="line">        <span class="comment">// 遍历执行这些 watches</span></div><div class="line">        length = watchers.length;</div><div class="line">        <span class="keyword">while</span> (length--) &#123;</div><div class="line">          <span class="keyword">try</span> &#123;</div><div class="line">            watch = watchers[length];</div><div class="line">            <span class="keyword">if</span> (watch) &#123;</div><div class="line">              get = watch.get;</div><div class="line">              <span class="keyword">if</span> ((value = get(current)) !== (last = watch.last) &amp;&amp;</div><div class="line">                  !(watch.eq</div><div class="line">                      ? equals(value, last)</div><div class="line">                      : (<span class="keyword">typeof</span> value === <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> last === <span class="string">'number'</span></div><div class="line">                         &amp;&amp; <span class="built_in">isNaN</span>(value) &amp;&amp; <span class="built_in">isNaN</span>(last)))) &#123;</div><div class="line">                           <span class="comment">// 优先使用 === 判断 value 和 last，其次再是根据他们是否为数字做 ng 的深度相等判断或者 isNaN 判断</span></div><div class="line">                dirty = <span class="literal">true</span>;</div><div class="line">                lastDirtyWatch = watch;</div><div class="line">                <span class="comment">// 如果 watch.eq 为 true，表示该 watch 的目标为对象，所以把该对象克隆到 watch.last 上面以下一次 digest 时来判断</span></div><div class="line">                <span class="comment">// 如果 watch.eq 为 false，表示该 watch 的目标为数字，所以直接赋值就可以了</span></div><div class="line">                <span class="comment">// 这里和上面一样都是为了提高速度和性能用</span></div><div class="line">                watch.last = watch.eq ? copy(value, <span class="literal">null</span>) : value;</div><div class="line">                <span class="comment">// 获取该 watch 的表达式并执行</span></div><div class="line">                fn = watch.fn;</div><div class="line">                <span class="comment">// 如果 last 和最开始的值相同则使用后者，否则使用前者。</span></div><div class="line">                fn(value, ((last === initWatchVal) ? value : last), current);</div><div class="line">                <span class="keyword">if</span> (ttl &lt; <span class="number">5</span>) &#123;</div><div class="line">                  logIdx = <span class="number">4</span> - ttl;</div><div class="line">                  <span class="keyword">if</span> (!watchLog[logIdx]) watchLog[logIdx] = [];</div><div class="line">                  watchLog[logIdx].push(&#123;</div><div class="line">                    <span class="attr">msg</span>: isFunction(watch.exp) ? <span class="string">'fn: '</span> + (watch.exp.name || watch.exp.toString()) : watch.exp,</div><div class="line">                    <span class="attr">newVal</span>: value,</div><div class="line">                    <span class="attr">oldVal</span>: last</div><div class="line">                  &#125;);</div><div class="line">                &#125;</div><div class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (watch === lastDirtyWatch) &#123;</div><div class="line">                dirty = <span class="literal">false</span>;</div><div class="line">                <span class="keyword">break</span> traverseScopesLoop;</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">            $exceptionHandler(e);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// Insanity Warning: scope depth-first traversal</span></div><div class="line">      <span class="comment">// yes, this code is a bit crazy, but it works and we have tests to prove it!</span></div><div class="line">      <span class="comment">// this piece should be kept in sync with the traversal in $broadcast</span></div><div class="line">      <span class="comment">// 对当前 scope 的子 scope 做遍历</span></div><div class="line">      <span class="keyword">if</span> (!(next = ((current.$$watchersCount &amp;&amp; current.$$childHead) ||</div><div class="line">          (current !== target &amp;&amp; current.$$nextSibling)))) &#123;</div><div class="line">        <span class="keyword">while</span> (current !== target &amp;&amp; !(next = current.$$nextSibling)) &#123;</div><div class="line">          current = current.$parent;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">while</span> ((current = next));</div><div class="line">    </div><div class="line">    <span class="comment">// 脏值检查未结束但此时 ttl 为 0，则抛出错误</span></div><div class="line">    <span class="keyword">if</span> ((dirty || asyncQueue.length) &amp;&amp; !(ttl--)) &#123;</div><div class="line">      clearPhase();</div><div class="line">      <span class="keyword">throw</span> $rootScopeMinErr(<span class="string">'infdig'</span>,</div><div class="line">          <span class="string">'&#123;0&#125; $digest() iterations reached. Aborting!\n'</span> +</div><div class="line">          <span class="string">'Watchers fired in the last 5 iterations: &#123;1&#125;'</span>,</div><div class="line">          TTL, watchLog);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 循环遍历直到 dirty 为 false 并且 asyncQueue.length = 0</span></div><div class="line">  &#125; <span class="keyword">while</span> (dirty || asyncQueue.length);</div><div class="line"></div><div class="line">  clearPhase();</div><div class="line"></div><div class="line">  <span class="comment">// 执行 postDigest 序列</span></div><div class="line">  <span class="keyword">while</span> (postDigestQueuePosition &lt; postDigestQueue.length) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      postDigestQueue[postDigestQueuePosition++]();</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">      $exceptionHandler(e);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  postDigestQueue.length = postDigestQueuePosition = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不过这段代码我也不是全都理解了，但是核心的算了解了。总体来看这个算法还是很简单粗暴的，这里保留了一段注释，有意思，官方吐槽的感觉。</p>
<p>由于脏检查的性能问题，在页面绑定数据较多的时候，我们应该尽量减少双向绑定的数量，比如使用 <code>ngInfiniteScroll</code> 这样的插件，适当使用单向绑定，甚至是取消一些变量的 watch 方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Angular 的脏值检查机制一直是 Angular 被人诟病的地方，但瑕不掩瑜，Angular 还是一个非常优秀的框架，并且 Angular2 也已经抛弃了这个脏值检查的算法。&lt;br&gt;最近在看《AngularJS 深度剖析与最佳实践》，不得不说是一本很好的书籍，作者在第三章开始讲背后的原理，这里分析了 Angular 的 $digest 函数，即脏检查机制。所以自己也去下载了 Angular 最新的源码去瞧了下，然后做下笔记吧。&lt;/p&gt;
&lt;p&gt;首先要注意，Angular 的 digest 的触发不是定时的，只有在指定的事件触发之后才会进入 $digest。基本上我们用的带 &lt;code&gt;$&lt;/code&gt; 的东西调用之后都可能会触发 digest。比如我们使用 &lt;code&gt;setTimeout&lt;/code&gt; 就不会触发 digest，即当你使用 &lt;code&gt;setTimeout&lt;/code&gt; 更改 viewmodel 的值后，它不会同步的反映到用户的视图中去，解决方法有两个，一个是使用 Angular 提供的 &lt;code&gt;$timeout&lt;/code&gt; 替代 &lt;code&gt;setTimeout&lt;/code&gt;，&lt;code&gt;$timeout&lt;/code&gt; 会在执行结束之后自动触发 digest； 另一个方法是手动调用 $apply，$apply 是 Angular 对 digest 的一层封装，我们一般不会直接调用 digest 而是通过使用 $apply 方法。比如对于 &lt;code&gt;setTimeout&lt;/code&gt;，我们就可以这样触发 digest。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  $scope.$apply(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    $scope.test = &lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;)    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;number&quot;&gt;500&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们看一个例子，这也是 Angular 源码 $digest 部分的一个示例。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; scope = ...;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;scope.name = &lt;span class=&quot;string&quot;&gt;&#39;misko&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;scope.counter = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;expect(scope.counter).toEqual(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;scope.$watch(&lt;span class=&quot;string&quot;&gt;&#39;name&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;newValue, oldValue&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  scope.counter = scope.counter + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;expect(scope.counter).toEqual(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 执行第一次 digest，第一次 digest 会遍历全部的 watcher，并触发上面的方法，从而使的 count+1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;scope.$digest();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;expect(scope.counter).toEqual(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 第二次调用时，由于上一次调用检查 name 不脏，所以不会再去处理&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;scope.$digest();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;expect(scope.counter).toEqual(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 第三次调用时，由于 name 发生了变化，使得当前值和上一次保存的值不同，所以会触发起 $watch 方法&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;scope.name = &lt;span class=&quot;string&quot;&gt;&#39;adam&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;scope.$digest();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;expect(scope.counter).toEqual(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Angular 的脏值检查过程大致如下：&lt;br&gt;对当前作用域和子作用域上的 &lt;code&gt;$$watchers&lt;/code&gt; 进行遍历，&lt;code&gt;$$watches&lt;/code&gt; 保存着 scope 上的所有变量以及其 &lt;code&gt;$watch&lt;/code&gt; 方法，调用时会取当前值和上一次值进行比较，如果不相等则会调用 &lt;code&gt;$watch&lt;/code&gt; 方法，同时会保存当前的值以在下一次进行比较，并且记录此次检查结果为脏。然后重复进行直到数据不脏为止，因此至少要 digest 两次，超出 10 次会报错，可以调高这个次数限制。当数据不再脏即 model 稳定下来之后， Angular 才会开始一次性批量更新 UI。从而减少了浏览器的 repaint 次数，提升性能。&lt;/p&gt;
&lt;p&gt;深入到源码来看：&lt;br&gt;
    
    </summary>
    
      <category term="Angular" scheme="https://ruiming.github.io/categories/Angular/"/>
    
    
      <category term="Angular" scheme="https://ruiming.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>项目采坑笔记</title>
    <link href="https://ruiming.github.io/2016/08/15/%E9%A1%B9%E7%9B%AE%E9%87%87%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    <id>https://ruiming.github.io/2016/08/15/项目采坑笔记/</id>
    <published>2016-08-15T08:37:19.000Z</published>
    <updated>2016-08-15T15:38:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>有段时间没写博客了，前段时间在看 Underscore 源码所以写的多了点，这段时间还是在忙自己的其他项目去了，还是有不少收获的。</p>
<h2 id="Angular-视图过渡动画"><a href="#Angular-视图过渡动画" class="headerlink" title="Angular 视图过渡动画"></a>Angular 视图过渡动画</h2><p>之前使用 <code>angular-promise-button</code> 这个模块实现了按钮的自动变化，以前自己是用很多标志位来判断特别二。不仅如此，页面切换动画也是用标志位判断，这样就特别不好维护特别不优雅，上次重构的时候就把这些全部去掉了。但是问题来了，页面数据未到达时候页面就渲染肯定会造成视觉上的问题，怎么解决呢。<br>我们都想写一些应用很广的代码，比如指令，比如上面这个 <code>angular-promise-button</code> 模块等等。其实要解决上面的问题，也是几行代码就可以解决的事情了。<br>我所使用的是 Angular 的 ui-router。ngRoute 应该也差不多。<br>在 ui-router 中可以使用 resolve 达到在控制器初始化以及视图加载前确保数据到达。比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$stateProvider</div><div class="line">    .state(<span class="string">'me'</span>,&#123;</div><div class="line">        <span class="attr">url</span>: <span class="string">'/me'</span>,</div><div class="line">        <span class="attr">controller</span>: <span class="string">'MeCtrl'</span>,</div><div class="line">        <span class="attr">templateUrl</span>: <span class="string">'me/me_tpl.html'</span>,</div><div class="line">        <span class="attr">controllerAs</span>: <span class="string">'vm'</span>,</div><div class="line">        <span class="attr">nav</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">resolve</span>: &#123;</div><div class="line">            <span class="attr">me</span>: <span class="function"><span class="keyword">function</span>(<span class="params">userservice</span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> userservice.getUserInfo()</div><div class="line">                    .then(<span class="function"><span class="params">response</span> =&gt;</span> response);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;)</div></pre></td></tr></table></figure></p>
<p>只有 resolve 中的全部方法执行完后，才会开始初始化控制和加载视图。这个数据如果在控制器或者视图中要使用，可以在控制器中进行依赖注入。例如上面这个我的控制器是这样写的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="meta">    'use strict'</span>;</div><div class="line">    </div><div class="line">    angular</div><div class="line">        .module(<span class="string">'index'</span>)</div><div class="line">        .controller(<span class="string">'MeCtrl'</span>, MeCtrl);</div><div class="line">        </div><div class="line">    MeCtrl.$inject = [<span class="string">'me'</span>];</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">MeCtrl</span>(<span class="params">me</span>) </span>&#123;</div><div class="line">        <span class="keyword">let</span> vm = <span class="keyword">this</span>;</div><div class="line">        vm.user = me;</div><div class="line">    &#125;</div><div class="line">&#125;());</div></pre></td></tr></table></figure></p>
<p>resolve中的方法是阻塞页面进行的，这样就会带来问题了，如果数据请求比较久将导致网站停滞，我们这时候就希望可以有过渡动画出来。要达到全局过渡效果的作用，可以直接监听 <code>$rootScope</code> 中的三个状态即 <code>$stateChangeStart</code> 和 <code>$stateChangeSuccess</code> 以及 <code>$stateChangeError</code> 事件。例如上面这个例子中，当我们触发 <code>me</code> 这个 state 时，也就触发了 $rootScope 上的 <code>$stateChangeStart</code> 事件，当处理结束后将出发 <code>$stateChangeSuccess</code> 并加载视图， 处理失败就会触发 <code>$stateChangeError</code> 事件。代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">angular</div><div class="line">    .module(<span class="string">'index'</span>, [</div><div class="line">        <span class="string">'ui.router'</span>,</div><div class="line">        <span class="string">'ui.bootstrap'</span>,</div><div class="line">        <span class="string">'ngAnimate'</span>,</div><div class="line">        <span class="string">'ngSanitize'</span>,</div><div class="line">        <span class="string">'ngTouch'</span>,</div><div class="line">        <span class="string">'infinite-scroll'</span>,</div><div class="line">        <span class="string">'angularPromiseButtons'</span></div><div class="line">    ])</div><div class="line">    .config(config)</div><div class="line">    .run(<span class="function">(<span class="params">$state,$rootScope</span>) =&gt;</span> &#123;</div><div class="line">        $rootScope.$state = $state;</div><div class="line">        $rootScope.$on(<span class="string">"$stateChangeStart"</span>, (event, toState, toStateParams, fromState, fromStateParams) =&gt; &#123;</div><div class="line">            <span class="keyword">var</span> isLoading = toState.resolve;</div><div class="line">            <span class="keyword">if</span>(!isLoading) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> toState.views) &#123;</div><div class="line">                    <span class="keyword">if</span> (toState.views.hasOwnProperty(prop)) &#123;</div><div class="line">                        <span class="keyword">if</span>(toState.views[prop].resolve) &#123;</div><div class="line">                            isLoading = <span class="literal">true</span>;</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (isLoading) &#123;</div><div class="line">                $rootScope.loading = <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        $rootScope.$on(<span class="string">"$stateChangeSuccess"</span>, (event, toState, toParams, fromState, fromParams) =&gt; &#123;</div><div class="line">            $rootScope.loading = <span class="literal">false</span>;</div><div class="line">        &#125;);</div><div class="line">        $rootScope.$on(<span class="string">"$stateChangeError"</span>, (event, toState, toParams, fromState, fromParams, error) =&gt; &#123;</div><div class="line">            $rootScope.loading = <span class="literal">false</span>;</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p>
<p>入口页面，省去了其他代码，这里第一行就是视图，第二行是加载动画，通过ng-show来控制显示。第三行是引入导航栏，这个在后面会说下。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span> <span class="attr">class</span>=<span class="string">"uiview"</span> <span class="attr">ng-show</span>=<span class="string">"!$root.loading"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cssload-thecube"</span> <span class="attr">ng-show</span>=<span class="string">"$root.loading"</span>&gt;</span> loading... <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-show</span>=<span class="string">"$state.current.nav"</span> <span class="attr">ng-include</span>=<span class="string">"'navbar/navbar_tpl.html'"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>可以看到上面的代码中是监听了 <code>$stateChangeStart</code> 事件，然后获取目标 state 上的 resolve 方法，当 state 上的 resolve 方法全部结束后，<code>$rootScope.loading</code> 设置为 false，否则保持为 true。<br>当监听到 <code>$stateChangeSuccess</code> 或者 <code>$stateChangeError</code> 事件时，置 <code>$rootScope.loading</code> 为 false，退出过渡动画。在视图中可以使用 <code>$root</code> 得到 <code>$rootScope</code>。<br>可以看到这里有很多参数，可见其功能是很强大的。<br><a id="more"></a><br>再看下上面这个第三行<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-show</span>=<span class="string">"$state.current.nav"</span> <span class="attr">ng-include</span>=<span class="string">"'navbar/navbar_tpl.html'"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>结合上面的 JS 代码来看，我已经把 <code>$state</code> 注入到了 <code>$rootScope</code> 中了，之后我就可以使用 <code>$state.current</code> 来获取当前的视图状态和信息。我需要实现导航栏仅仅出现在我指定的页面中，下方按钮可以根据当前视图来激活。第一点可以通过给路由 state 补充变量比如我这里的 <code>nav</code> 来实现，需要导航栏的地方就设置 <code>nav</code> 为 true, 否则就不设置。第二点则可以利用 <code>ui-sref-active</code> 来实现。如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- navbar/navbar_tpl.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"bookist-nav navbar navbar-default"</span> <span class="attr">role</span>=<span class="string">"navigation"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"nav navbar-nav"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">ui-sref-active</span>=<span class="string">"active"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">ui-sref</span>=<span class="string">"index"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-home fa-lg"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">ui-sref-active</span>=<span class="string">"active"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">ui-sref</span>=<span class="string">"booklists"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-th-large fa-lg"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>书单<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">ui-sref-active</span>=<span class="string">"active"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">ui-sref</span>=<span class="string">"cart"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-shopping-cart fa-lg"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>购物车<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">ui-sref-active</span>=<span class="string">"active"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">ui-sref</span>=<span class="string">"me"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-user fa-lg"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>我的<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>最后还有一个地方就是，下面这个代码<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span> <span class="attr">class</span>=<span class="string">"uiview"</span> <span class="attr">ng-show</span>=<span class="string">"!$root.loading"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>ui-view 的用法其实还不少，如果你有去注意的话，会看到这个视图在变化的时候其类名会变化，依次我们可以结合 angular-animate 来实现切换动画。注意这个切换动画是在视图加载后才开始的，和上面的不一样，如果同时使用，则会在上方过渡效果结束后触发。例如，我们可以实现淡入淡出：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.uiview &#123;</div><div class="line">  &amp;.ng-enter &#123;</div><div class="line">    transition: .5s;</div><div class="line">    opacity: 0;</div><div class="line">  &#125;</div><div class="line">  &amp;.ng-enter-active &#123;</div><div class="line">    opacity: 1;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以上面其实说了好几点：</p>
<ul>
<li>使用路由上的 resolve 来实现在控制器初始化前获取到需要的数据</li>
<li>监听 $rootScope 上的事件来实现 resolve 等待动画</li>
<li>在 ui-view 上通过使用 angular-animate 来实现视图的切换动画</li>
<li>通过 ui-sref-active 在当 ui-sref 和当前 state 一致时激活 active 类名</li>
<li>把 $state 注入到 $rootScope 达到在视图中获取 $state 用途</li>
<li>使用 $root 得到 $rootScope，利用 $root 获取 $rootScope 上的对象</li>
</ul>
<h2 id="静态资源自动发布七牛云"><a href="#静态资源自动发布七牛云" class="headerlink" title="静态资源自动发布七牛云"></a>静态资源自动发布七牛云</h2><p>这个很简单啦，我使用了 gulp-qiniu 这个模块来实现，很简单，结合前面说的 gulp-usemin 就更完美了。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- build:js //cdn.bookist.org/bookist.min.js --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"src/js/bookist.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"src/js/templates.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- endbuild --&gt;</span></div></pre></td></tr></table></figure></p>
<p>例如对上面 index.html 中的这一片段，我们要在开发环境中使用本地资源，而在线上环境则使用 CDN 资源。我们可以这样配置 gulpfile。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">gulp</span><span class="selector-class">.task</span>(<span class="string">'cdn'</span>, () =&gt; &#123;</div><div class="line">    <span class="selector-tag">gulp</span><span class="selector-class">.src</span>(<span class="string">'index.html'</span>)</div><div class="line">        <span class="selector-class">.pipe</span>(usemin())</div><div class="line">        <span class="selector-class">.pipe</span>(gulp.dest(<span class="string">'backend/app/templates'</span>));</div><div class="line">    <span class="selector-tag">gulp</span><span class="selector-class">.src</span>([<span class="string">'./src/js/bookist.js'</span>, <span class="string">'./src/js/templates.js'</span>])</div><div class="line">        <span class="selector-class">.pipe</span>(plumber())</div><div class="line">        <span class="selector-class">.pipe</span>(uglify())</div><div class="line">        <span class="selector-class">.pipe</span>(babel())</div><div class="line">        <span class="selector-class">.pipe</span>(concat(<span class="string">'bookist.min.js'</span>))</div><div class="line">        <span class="selector-class">.pipe</span>(qiniu(&#123;</div><div class="line">            <span class="attribute">accessKey</span>: <span class="string">"xxx"</span>,</div><div class="line">            <span class="attribute">secretKey</span>: <span class="string">"xxx"</span>,</div><div class="line">            <span class="attribute">bucket</span>: <span class="string">"bookist"</span>,</div><div class="line">            <span class="attribute">private</span>: false</div><div class="line">        &#125;));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行上面的任务后就会在 <code>backend/app/templates</code> 生成一个修改过的 index.html。对于上面的片段，处理之后是这样的：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.bookist.org/bookist.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>前面的注释是给 usemin 使用的，所以要按照规范书写。<br>同时上面的任务也会把资源发布到七牛云上面，如果你还想指定文件头或者版本号之类的信息，可以参考 gulp-qiniu 的文档进行配置。<br>上面的方法有一个小问题就是还会在 <code>backend/app/templates</code> 生成一个 <code>cdn.bookist.org</code> 的文件夹，不过无所谓咯，放到 .gitignore 就好了。<br>至于图片和 css 都差不多吧，就不多说了。</p>
<h2 id="微信坑逼"><a href="#微信坑逼" class="headerlink" title="微信坑逼"></a>微信坑逼</h2><p>有段时间我的网站在微信显示部分地方是有问题的，但在手机浏览器和电脑都没任何问题，一开始以为是样式的问题。等到自己要去解决这个问题了，才知道是 js 的问题。<br>由于微信开发工具不支持 linux，然后我虚拟机的 win10 有不知道什么原因一直连接不到手机。所以就手动调试了，这边改一点，发布上去，然后等微信缓存没了看效果(微信恶心的缓存…我都叫用苹果的人帮我看，因为苹果可以刷新..)。就这样一步步看，最后定位了问题代码。中间过程就不描述了，直接看：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> book <span class="keyword">of</span> books) &#123;</div><div class="line">    <span class="keyword">if</span>(book.rate)   book.star = <span class="built_in">Math</span>.ceil(book.rate/<span class="number">2</span>);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(book.star)   book.star = <span class="built_in">Math</span>.ceil(book.star/<span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>省略了无关代码，这是一个方法里面的部分代码，如果一个对象传入这个方法中，在微信会得不到返回值，在手机浏览器和电脑上都正常。<br>虽然这里使用了 ES6 的语法，但是我其实已经大量使用 let…of… 语句，项目并没有出现太大问题，就只是上面描述的一些地方异常而已。再者我使用了 babel 转码了。越想越觉得没道理啊。。。<br>最后虚拟机换了 win7 然后手机连接上了，打开了微信开发工具，调试微信 webview，报错 <code>Symbol is not defined</code>。<br>果断控制台敲 Symbol，结果 <code>Symbol is not defined</code>。<br>好吧，问题出来了，微信这个辣鸡不支持 Symbol…<br>但问题是我没有用 Symbol 这个东西啊，我瞄了 babel 一眼。<br>看下上面那段代码转码的结果：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _iteratorNormalCompletion5 = <span class="literal">true</span>;</div><div class="line"><span class="keyword">var</span> _didIteratorError5 = <span class="literal">false</span>;</div><div class="line"><span class="keyword">var</span> _iteratorError5 = <span class="literal">undefined</span>;</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> _iterator5 = books[<span class="built_in">Symbol</span>.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = <span class="literal">true</span>) &#123;</div><div class="line">        <span class="keyword">var</span> book = _step5.value;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (book.rate) book.star = <span class="built_in">Math</span>.ceil(book.rate / <span class="number">2</span>);<span class="keyword">else</span> <span class="keyword">if</span> (book.star) book.star = <span class="built_in">Math</span>.ceil(book.star / <span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">    _didIteratorError5 = <span class="literal">true</span>;</div><div class="line">    _iteratorError5 = err;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (!_iteratorNormalCompletion5 &amp;&amp; _iterator5.return) &#123;</div><div class="line">            _iterator5.return();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (_didIteratorError5) &#123;</div><div class="line">            <span class="keyword">throw</span> _iteratorError5;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>什么鬼…算了，不看了，但是确定了是 babel 转码导致的。然后查了下资料：</p>
<blockquote>
<p>Babel默认只转换新的JavaScript句法(syntax)，而不转换新的API，比如Iterator, Generator, Set, Maps, Proxy, Reflect, Symbol, Promise等全局对象，以及一些定义在全局对象上的方法(比如Object.assign)都不会转码。</p>
</blockquote>
<p>其实早有耳闻 polyfill 这个东西，但我想他一般是用在 IE 这种辣鸡浏览器上的，没想到微信 webview 这么不争气。<br>多打包一个 babel-polyfill 解决了这个问题。<br>坑比微信…</p>
<p>故事还没结束…<br>昨天发现网站并没有使用 http2，但是已经进行了设置了，最后查了很多资料原因好像是 openssl 的问题，但由于使用的是 docker，貌似不太好搞，但其实更换 nginx 版本就好了，原先是1.9版本，换成1.11-alpine 版就解决了，用 docker 更换 nginx 版本非常方便。额，具体原因不深究了，可能跟 alpine 这个字眼有关？不清楚…<br>http2 具备多路复用的特点，在 http1.1 中，并行传输文件是有限制的，因为用户端和服务端的最大连接数是有限制的，而连接的建立和销毁又会带来开销，所以在 http1.1 中对文件进行压缩合并是很有必要的。不过在 http2 就不需要这样做了，http2 可以在一条通道上传输多个文件，如果合并剩几个，就没法发挥并行传输的优势，而且文件太大，还会降低运输层的效率，即丢包或者乱序到达的影响。<br>我把网站改到了 http2 后，就不再进行文件合并了，转而可以大量使用 bootcss 的 CDN，bootcss 的 CDN 支持 http2，传输很快。至于上面没有的和自己写的，就发布到七牛云上面。恩，电脑上加载是变快了很多。<br>但是感觉不到微信加载变快…最后发现是微信不支持 http2…<br>好伤心…<br>最后我的方案是产生两个 css 文件和两个 js 文件，之所以是两个，因为一个是自己写的，经常变，另一个是用别人的，几乎不会变。</p>
<p>最后又发现微信好像支持 spdy… 心好累，算了，降了 nginx 版本开启 spdy 不理了。</p>
<hr>
<p>总结：</p>
<ul>
<li>Angular 是一个大而全的框架，我觉得很强大很牛逼，越来越喜欢 Angular 了</li>
<li>使用 CDN 可以大大的加速，尽量使用 CDN</li>
<li>微信这个坑比我就不说了，不支持 Symbol 不支持 http2</li>
<li>能用 http2 就尽量用 http2</li>
<li>考虑浏览器兼容性，根据需要引入 babel-polyfill</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有段时间没写博客了，前段时间在看 Underscore 源码所以写的多了点，这段时间还是在忙自己的其他项目去了，还是有不少收获的。&lt;/p&gt;
&lt;h2 id=&quot;Angular-视图过渡动画&quot;&gt;&lt;a href=&quot;#Angular-视图过渡动画&quot; class=&quot;headerlink&quot; title=&quot;Angular 视图过渡动画&quot;&gt;&lt;/a&gt;Angular 视图过渡动画&lt;/h2&gt;&lt;p&gt;之前使用 &lt;code&gt;angular-promise-button&lt;/code&gt; 这个模块实现了按钮的自动变化，以前自己是用很多标志位来判断特别二。不仅如此，页面切换动画也是用标志位判断，这样就特别不好维护特别不优雅，上次重构的时候就把这些全部去掉了。但是问题来了，页面数据未到达时候页面就渲染肯定会造成视觉上的问题，怎么解决呢。&lt;br&gt;我们都想写一些应用很广的代码，比如指令，比如上面这个 &lt;code&gt;angular-promise-button&lt;/code&gt; 模块等等。其实要解决上面的问题，也是几行代码就可以解决的事情了。&lt;br&gt;我所使用的是 Angular 的 ui-router。ngRoute 应该也差不多。&lt;br&gt;在 ui-router 中可以使用 resolve 达到在控制器初始化以及视图加载前确保数据到达。比如：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$stateProvider&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    .state(&lt;span class=&quot;string&quot;&gt;&#39;me&#39;&lt;/span&gt;,&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;url&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;/me&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;controller&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;MeCtrl&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;templateUrl&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;me/me_tpl.html&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;controllerAs&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;vm&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;nav&lt;/span&gt;: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;resolve&lt;/span&gt;: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;attr&quot;&gt;me&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;userservice&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; userservice.getUserInfo()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    .then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;response&lt;/span&gt; =&amp;gt;&lt;/span&gt; response);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;只有 resolve 中的全部方法执行完后，才会开始初始化控制和加载视图。这个数据如果在控制器或者视图中要使用，可以在控制器中进行依赖注入。例如上面这个我的控制器是这样写的：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;    &#39;use strict&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    angular&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        .module(&lt;span class=&quot;string&quot;&gt;&#39;index&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        .controller(&lt;span class=&quot;string&quot;&gt;&#39;MeCtrl&#39;&lt;/span&gt;, MeCtrl);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    MeCtrl.$inject = [&lt;span class=&quot;string&quot;&gt;&#39;me&#39;&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MeCtrl&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;me&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; vm = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        vm.user = me;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;());&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;resolve中的方法是阻塞页面进行的，这样就会带来问题了，如果数据请求比较久将导致网站停滞，我们这时候就希望可以有过渡动画出来。要达到全局过渡效果的作用，可以直接监听 &lt;code&gt;$rootScope&lt;/code&gt; 中的三个状态即 &lt;code&gt;$stateChangeStart&lt;/code&gt; 和 &lt;code&gt;$stateChangeSuccess&lt;/code&gt; 以及 &lt;code&gt;$stateChangeError&lt;/code&gt; 事件。例如上面这个例子中，当我们触发 &lt;code&gt;me&lt;/code&gt; 这个 state 时，也就触发了 $rootScope 上的 &lt;code&gt;$stateChangeStart&lt;/code&gt; 事件，当处理结束后将出发 &lt;code&gt;$stateChangeSuccess&lt;/code&gt; 并加载视图， 处理失败就会触发 &lt;code&gt;$stateChangeError&lt;/code&gt; 事件。代码如下：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;angular&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    .module(&lt;span class=&quot;string&quot;&gt;&#39;index&#39;&lt;/span&gt;, [&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;ui.router&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;ui.bootstrap&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;ngAnimate&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;ngSanitize&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;ngTouch&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;infinite-scroll&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;angularPromiseButtons&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    .config(config)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    .run(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;$state,$rootScope&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        $rootScope.$state = $state;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        $rootScope.$on(&lt;span class=&quot;string&quot;&gt;&quot;$stateChangeStart&quot;&lt;/span&gt;, (event, toState, toStateParams, fromState, fromStateParams) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; isLoading = toState.resolve;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!isLoading) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; prop &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; toState.views) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (toState.views.hasOwnProperty(prop)) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(toState.views[prop].resolve) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                            isLoading = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isLoading) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                $rootScope.loading = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        $rootScope.$on(&lt;span class=&quot;string&quot;&gt;&quot;$stateChangeSuccess&quot;&lt;/span&gt;, (event, toState, toParams, fromState, fromParams) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            $rootScope.loading = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        $rootScope.$on(&lt;span class=&quot;string&quot;&gt;&quot;$stateChangeError&quot;&lt;/span&gt;, (event, toState, toParams, fromState, fromParams, error) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            $rootScope.loading = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;入口页面，省去了其他代码，这里第一行就是视图，第二行是加载动画，通过ng-show来控制显示。第三行是引入导航栏，这个在后面会说下。&lt;br&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ui-view&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;uiview&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ng-show&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;!$root.loading&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;cssload-thecube&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ng-show&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;$root.loading&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt; loading... &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ng-show&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;$state.current.nav&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ng-include&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;&#39;navbar/navbar_tpl.html&#39;&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看到上面的代码中是监听了 &lt;code&gt;$stateChangeStart&lt;/code&gt; 事件，然后获取目标 state 上的 resolve 方法，当 state 上的 resolve 方法全部结束后，&lt;code&gt;$rootScope.loading&lt;/code&gt; 设置为 false，否则保持为 true。&lt;br&gt;当监听到 &lt;code&gt;$stateChangeSuccess&lt;/code&gt; 或者 &lt;code&gt;$stateChangeError&lt;/code&gt; 事件时，置 &lt;code&gt;$rootScope.loading&lt;/code&gt; 为 false，退出过渡动画。在视图中可以使用 &lt;code&gt;$root&lt;/code&gt; 得到 &lt;code&gt;$rootScope&lt;/code&gt;。&lt;br&gt;可以看到这里有很多参数，可见其功能是很强大的。&lt;br&gt;
    
    </summary>
    
      <category term="Angular" scheme="https://ruiming.github.io/categories/Angular/"/>
    
    
      <category term="Angular" scheme="https://ruiming.github.io/tags/Angular/"/>
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 JavaScript 模块定义规范</title>
    <link href="https://ruiming.github.io/2016/08/06/%E6%B5%85%E8%B0%88JavaScript%E6%A8%A1%E5%9D%97%E5%AE%9A%E4%B9%89%E8%A7%84%E8%8C%83/"/>
    <id>https://ruiming.github.io/2016/08/06/浅谈JavaScript模块定义规范/</id>
    <published>2016-08-06T14:28:35.000Z</published>
    <updated>2016-08-06T14:31:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>JS 模块定义常见的有三种方式，即 AMD, CMD 和 CommonJS。其实还有一个 UMD，他是 CommonJS 和 AMD 揉和在一起而已。不过这些都 out 了，拥抱 ES6 吧。话虽这么说，你让那些不用 ES6 不用 babel 的怎么活，所以还是要了解下滴。</p>
<h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>CommonJS 是服务端即 Node.js 采用的模块化方案，我们应该都很熟悉了。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line">fs.readFileSync();</div></pre></td></tr></table></figure></p>
<p>这个过程是同步的，只有成功加载 <code>fs</code> 后才能执行后面的步骤。但在服务器文件都在本地，所以这个问题不大。但这个在浏览器就不合适了，如果文件加载耗时很长，将导致一直等待。</p>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>AMD 全称 Asynchronous Module Definition，意思就是异步模块定义。<br>用法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">math</span>) </span>&#123;</div><div class="line">    math.add(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>math 模块的加载和 <code>math.add()</code> 方法的执行不是同步的，这样浏览器就不会假死。<br>RequireJs 和 CurlJs 实现了 AMD 规范，将他们嵌入网页，就可以在浏览器端进行模块化编程了。<br>关于 AMD 的详细模块定义可以参考<a href="https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88" target="_blank" rel="external">wiki</a>)。这里给出 Underscore 的 AMD 定义方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> define == <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</div><div class="line">    define(<span class="string">'underscore'</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> _;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>CMD 全称 Common Module Definition，意思就是通用模块定义。。<br>对于依赖的模块，AMD 是提前执行，而 CMD 是延迟执行。AMD 推崇依赖前置，而 CMD 则推崇依赖就近。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> math = <span class="built_in">require</span>(<span class="string">'./math'</span>);</div><div class="line">    math.add(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>CMD 的主要实现是 SeaJS<br>AMD 预先加载所有依赖，使用的时候才去执行，速度快，可以并行加载多个模块。但这就需要开发的时候把全部依赖都提前定义，不便于开发和阅读，而且部分依赖（弱依赖）可能只在少数情况下使用。<br>CMD 只有在真正需要的时候才去加载依赖，使用的时候才去定义执行，但这个加载逻辑偏重，耗性能。</p>
<h2 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h2><p>UMD 全称 Universal Module Definition。<br>UMD 是 AMD 和 CommonJS 的揉和，他优先使用 CommonJS 的加载方式，其次才使用 AMD 的加载方式。<br>例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">window, factory</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">'object'</span>) &#123;</div><div class="line">     </div><div class="line">        <span class="built_in">module</span>.exports = factory();</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</div><div class="line">     </div><div class="line">        define(factory);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">     </div><div class="line">        <span class="built_in">window</span>.eventUtil = factory();</div><div class="line">    &#125;</div><div class="line">&#125;)(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//module ...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>其实就是一个服务端和浏览端通用的模块解决方案。</p>
<h2 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h2><p>ES6 在语言规格的层面上实现了模块功能，并且实现非常简单，完全可以替代现有的模块加载方案，成为浏览器和服务端都通用的模块解决方案。<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;stat, exists, readFile&#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</div></pre></td></tr></table></figure></p>
<p>这种做法将只在 fs 模块加载3个方法，其他方法不会进行加载。ES6 可以在编译时就完成模块加载，效率比 CommonJS 的加载方式高。<br>在浏览器中使用 ES6 模块的语法：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"foo.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>目前 Node 默认模块格式是 CommonJS，ES6 的模块方案还不支持，但可以通过 babel 来使用。</p>
<p>现在推荐做法是广泛使用 ES6 甚至 ES7 来书写 JavaScript 以提高开发效率，再使用 babel 转码就好了。所以前后端我们也都可以使用 ES6 的 Module 来进行。其他的模块加载方案应该会渐渐退出历史舞台。</p>
<hr>
<p><a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="external">ECMAScript6 入门 Module</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS 模块定义常见的有三种方式，即 AMD, CMD 和 CommonJS。其实还有一个 UMD，他是 CommonJS 和 AMD 揉和在一起而已。不过这些都 out 了，拥抱 ES6 吧。话虽这么说，你让那些不用 ES6 不用 babel 的怎么活，所以还是要了解下滴。&lt;/p&gt;
&lt;h2 id=&quot;CommonJS&quot;&gt;&lt;a href=&quot;#CommonJS&quot; class=&quot;headerlink&quot; title=&quot;CommonJS&quot;&gt;&lt;/a&gt;CommonJS&lt;/h2&gt;&lt;p&gt;CommonJS 是服务端即 Node.js 采用的模块化方案，我们应该都很熟悉了。例如：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; fs = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;fs&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;fs.readFileSync();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个过程是同步的，只有成功加载 &lt;code&gt;fs&lt;/code&gt; 后才能执行后面的步骤。但在服务器文件都在本地，所以这个问题不大。但这个在浏览器就不合适了，如果文件加载耗时很长，将导致一直等待。&lt;/p&gt;
&lt;h2 id=&quot;AMD&quot;&gt;&lt;a href=&quot;#AMD&quot; class=&quot;headerlink&quot; title=&quot;AMD&quot;&gt;&lt;/a&gt;AMD&lt;/h2&gt;&lt;p&gt;AMD 全称 Asynchronous Module Definition，意思就是异步模块定义。&lt;br&gt;用法如下：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;([&lt;span class=&quot;string&quot;&gt;&#39;math&#39;&lt;/span&gt;], &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;math&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    math.add(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;math 模块的加载和 &lt;code&gt;math.add()&lt;/code&gt; 方法的执行不是同步的，这样浏览器就不会假死。&lt;br&gt;RequireJs 和 CurlJs 实现了 AMD 规范，将他们嵌入网页，就可以在浏览器端进行模块化编程了。&lt;br&gt;关于 AMD 的详细模块定义可以参考&lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88&quot;&gt;wiki&lt;/a&gt;)。这里给出 Underscore 的 AMD 定义方法：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; define == &lt;span class=&quot;string&quot;&gt;&#39;function&#39;&lt;/span&gt; &amp;amp;&amp;amp; define.amd) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    define(&lt;span class=&quot;string&quot;&gt;&#39;underscore&#39;&lt;/span&gt;, [], &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;CMD&quot;&gt;&lt;a href=&quot;#CMD&quot; class=&quot;headerlink&quot; title=&quot;CMD&quot;&gt;&lt;/a&gt;CMD&lt;/h2&gt;&lt;p&gt;CMD 全称 Common Module Definition，意思就是通用模块定义。。&lt;br&gt;对于依赖的模块，AMD 是提前执行，而 CMD 是延迟执行。AMD 推崇依赖前置，而 CMD 则推崇依赖就近。例如：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;define(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;require, exports, module&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; math = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;./math&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    math.add(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;CMD 的主要实现是 SeaJS&lt;br&gt;AMD 预先加载所有依赖，使用的时候才去执行，速度快，可以并行加载多个模块。但这就需要开发的时候把全部依赖都提前定义，不便于开发和阅读，而且部分依赖（弱依赖）可能只在少数情况下使用。&lt;br&gt;CMD 只有在真正需要的时候才去加载依赖，使用的时候才去定义执行，但这个加载逻辑偏重，耗性能。&lt;/p&gt;
&lt;h2 id=&quot;UMD&quot;&gt;&lt;a href=&quot;#UMD&quot; class=&quot;headerlink&quot; title=&quot;UMD&quot;&gt;&lt;/a&gt;UMD&lt;/h2&gt;&lt;p&gt;UMD 全称 Universal Module Definition。&lt;br&gt;UMD 是 AMD 和 CommonJS 的揉和，他优先使用 CommonJS 的加载方式，其次才使用 AMD 的加载方式。&lt;br&gt;例如：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;window, factory&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; exports === &lt;span class=&quot;string&quot;&gt;&#39;object&#39;&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = factory();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; define === &lt;span class=&quot;string&quot;&gt;&#39;function&#39;&lt;/span&gt; &amp;amp;&amp;amp; define.amd) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        define(factory);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.eventUtil = factory();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//module ...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其实就是一个服务端和浏览端通用的模块解决方案。&lt;/p&gt;
&lt;h2 id=&quot;ES6-Module&quot;&gt;&lt;a href=&quot;#ES6-Module&quot; class=&quot;headerlink&quot; title=&quot;ES6 Module&quot;&gt;&lt;/a&gt;ES6 Module&lt;/h2&gt;&lt;p&gt;ES6 在语言规格的层面上实现了模块功能，并且实现非常简单，完全可以替代现有的模块加载方案，成为浏览器和服务端都通用的模块解决方案。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://ruiming.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Underscore 源码学习(七)</title>
    <link href="https://ruiming.github.io/2016/08/06/Underscore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0(%E4%B8%83)/"/>
    <id>https://ruiming.github.io/2016/08/06/Underscore源码学习(七)/</id>
    <published>2016-08-06T07:53:18.000Z</published>
    <updated>2016-08-06T13:03:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>Underscore 中间 flatten 相关的方法之前一直不是很理解，现在完全搞懂了，稍微说一下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> flatten = <span class="function"><span class="keyword">function</span>(<span class="params">input, shallow, strict, output</span>) </span>&#123;</div><div class="line">    output = output || [];</div><div class="line">    <span class="keyword">var</span> idx = output.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = getLength(input); i &lt; length; i++) &#123;</div><div class="line">        <span class="keyword">var</span> value = input[i];</div><div class="line">        <span class="comment">// 若value为数组，把里面东西去出来赋值给output</span></div><div class="line">        <span class="comment">// 否则直接赋值给output</span></div><div class="line">        <span class="comment">// isArrayLike的判断可以去掉，保留的原因是因为他用来判断value是否为数组很快，可以迅速筛选掉非数组</span></div><div class="line">        <span class="keyword">if</span> (isArrayLike(value) &amp;&amp; (_.isArray(value) || _.isArguments(value))) &#123;</div><div class="line">        <span class="comment">// Flatten current level of array or arguments object.</span></div><div class="line">        <span class="keyword">if</span> (shallow) &#123;</div><div class="line">            <span class="comment">// 如果给了shallow参数，只只遍历一层</span></div><div class="line">            <span class="keyword">var</span> j = <span class="number">0</span>, len = value.length;</div><div class="line">            <span class="keyword">while</span> (j &lt; len) output[idx++] = value[j++];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 一直遍历下去，如果是元素则按下面赋值，如果是数组则继续遍历</span></div><div class="line">            flatten(value, shallow, strict, output);</div><div class="line">            idx = output.length;</div><div class="line">        &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strict) &#123;</div><div class="line">        output[idx++] = value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> output;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个方法不难看懂，作用是将input平铺展开，如果 <code>shallow</code> 为 <code>true</code>，则只展开一层。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_.flatten([<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>], [[<span class="number">4</span>, [<span class="number">5</span>]]]])              <span class="comment">// [1, 2, 3, 4, 5]</span></div><div class="line">_.flatten([<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>], [[<span class="number">4</span>, [<span class="number">5</span>]]]], <span class="literal">true</span>)        <span class="comment">// [1, 2, 3, [4, [5]]]</span></div></pre></td></tr></table></figure></p>
<p>这里的 <code>strict</code> 参数就是之前一直卡住的原因，就是下面这个地方：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">_.without = restArgs(<span class="function"><span class="keyword">function</span>(<span class="params">array, otherArrays</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> _.difference(array, otherArrays);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">_.difference = restArgs(<span class="function"><span class="keyword">function</span>(<span class="params">array, rest</span>) </span>&#123;</div><div class="line">    rest = flatten(rest, <span class="literal">true</span>, <span class="literal">true</span>);</div><div class="line">    <span class="comment">// 遍历array，如果array中一个元素包含在rest中，则去掉该元素</span></div><div class="line">    <span class="keyword">return</span> _.filter(array, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> !_.contains(rest, value);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这是两个方法，那时候想 <code>without</code> 方法调用的时候, <code>otherArrays</code>是一个数组了，到 <code>difference</code> 方法的时候，这个数组去调用 <code>flatten</code> 方法的时候不是会出问题吗？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_.flatten([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="literal">true</span>, <span class="literal">true</span>)        <span class="comment">// []</span></div></pre></td></tr></table></figure></p>
<p>脑子里面就这样想…卡了好久，等我基本看了全部源码才会过来看才理解了。<br><code>difference</code> 方法的 <code>restArgs</code> 很重要，他们两个是各自独立的方法，但是 <code>without</code> 可以共用 <code>difference</code> 的逻辑。<br>上面那样子理解是有问题的，因为在 <code>without</code> 方法中 <code>otherArrays</code> 如果是[1, 2, 3]，到了 <code>flatten</code> 调用的时候因为 <code>restArgs</code> 的关系他变成了 [[1, 2, 3]]，调用最后返回结果[1, 2, 3]。然后我就纳闷了，加了一层又解除这是何解…<br>不过抛开 <code>without</code> 方法去看 <code>difference</code> 方法就能理解了。<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">_.without([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line"><span class="comment">// 1, 2, 3通过restArgs变为[1, 2, 3]，传入difference方法</span></div><div class="line"><span class="comment">// [1, 2, 3]通过restArgs变为[[1, 2, 3]]，传入flatten方法</span></div><div class="line"><span class="comment">// 返回[1, 2, 3]，剩下的可以看懂了不解释</span></div><div class="line"><span class="comment">// 之所以shallow和strict都为true，是因为不需要两个数组即使内容一样他们也是不想等的，</span></div><div class="line"><span class="comment">// 不需要进行处理，所以没必要展开</span></div><div class="line">_.difference([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>]);</div><div class="line"><span class="comment">// [1, 2], [3]通过restArgs变为[1, 2, 3]，传入difference方法，其余同</span></div></pre></td></tr></table></figure></p>
<p>所以其实 <code>difference</code> 方法的 <code>restArgs</code> 虽然对与 <code>without</code> 方法中的调用是多余的，但是作为一个独立的方法，他还是有必要的。<br>上面注释应该说的很清楚了，完。</p>
<p>其实只是我自己没看清楚而已，也不难。这个地方的很多方法比如 <code>union</code>, <code>intersection</code>等等都是集合的相关操作。比如 <code>difference</code> 就是差集，<code>union</code> 就是并集，而<code>intersection</code> 就是交集。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Underscore 中间 flatten 相关的方法之前一直不是很理解，现在完全搞懂了，稍微说一下。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; flatten = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;input, shallow, strict, output&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    output = output || [];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; idx = output.length;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, length = getLength(input); i &amp;lt; length; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; value = input[i];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 若value为数组，把里面东西去出来赋值给output&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 否则直接赋值给output&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// isArrayLike的判断可以去掉，保留的原因是因为他用来判断value是否为数组很快，可以迅速筛选掉非数组&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isArrayLike(value) &amp;amp;&amp;amp; (_.isArray(value) || _.isArguments(value))) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Flatten current level of array or arguments object.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (shallow) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 如果给了shallow参数，只只遍历一层&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, len = value.length;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (j &amp;lt; len) output[idx++] = value[j++];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 一直遍历下去，如果是元素则按下面赋值，如果是数组则继续遍历&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            flatten(value, shallow, strict, output);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            idx = output.length;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!strict) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        output[idx++] = value;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; output;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个方法不难看懂，作用是将input平铺展开，如果 &lt;code&gt;shallow&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt;，则只展开一层。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;_.flatten([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;], [[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, [&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]]]])              &lt;span class=&quot;comment&quot;&gt;// [1, 2, 3, 4, 5]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;_.flatten([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;], [[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, [&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]]]], &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;)        &lt;span class=&quot;comment&quot;&gt;// [1, 2, 3, [4, [5]]]&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里的 &lt;code&gt;strict&lt;/code&gt; 参数就是之前一直卡住的原因，就是下面这个地方：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;_.without = restArgs(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;array, otherArrays&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _.difference(array, otherArrays);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;_.difference = restArgs(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;array, rest&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    rest = flatten(rest, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 遍历array，如果array中一个元素包含在rest中，则去掉该元素&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _.filter(array, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;value&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; !_.contains(rest, value);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这是两个方法，那时候想 &lt;code&gt;without&lt;/code&gt; 方法调用的时候, &lt;code&gt;otherArrays&lt;/code&gt;是一个数组了，到 &lt;code&gt;difference&lt;/code&gt; 方法的时候，这个数组去调用 &lt;code&gt;flatten&lt;/code&gt; 方法的时候不是会出问题吗？&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;_.flatten([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;], &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;)        &lt;span class=&quot;comment&quot;&gt;// []&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;脑子里面就这样想…卡了好久，等我基本看了全部源码才会过来看才理解了。&lt;br&gt;&lt;code&gt;difference&lt;/code&gt; 方法的 &lt;code&gt;restArgs&lt;/code&gt; 很重要，他们两个是各自独立的方法，但是 &lt;code&gt;without&lt;/code&gt; 可以共用 &lt;code&gt;difference&lt;/code&gt; 的逻辑。&lt;br&gt;上面那样子理解是有问题的，因为在 &lt;code&gt;without&lt;/code&gt; 方法中 &lt;code&gt;otherArrays&lt;/code&gt; 如果是[1, 2, 3]，到了 &lt;code&gt;flatten&lt;/code&gt; 调用的时候因为 &lt;code&gt;restArgs&lt;/code&gt; 的关系他变成了 [[1, 2, 3]]，调用最后返回结果[1, 2, 3]。然后我就纳闷了，加了一层又解除这是何解…&lt;br&gt;不过抛开 &lt;code&gt;without&lt;/code&gt; 方法去看 &lt;code&gt;difference&lt;/code&gt; 方法就能理解了。&lt;br&gt;
    
    </summary>
    
      <category term="Underscore" scheme="https://ruiming.github.io/categories/Underscore/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="Underscore" scheme="https://ruiming.github.io/tags/Underscore/"/>
    
  </entry>
  
  <entry>
    <title>Underscore 源码学习(六)</title>
    <link href="https://ruiming.github.io/2016/08/05/Underscore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0(%E5%85%AD)/"/>
    <id>https://ruiming.github.io/2016/08/05/Underscore源码学习(六)/</id>
    <published>2016-08-05T05:59:06.000Z</published>
    <updated>2016-08-05T06:07:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于 Underscore 的 mixin 方法。<br>首先先看个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Panel</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  consoe.log(<span class="keyword">this</span>, <span class="keyword">this</span> <span class="keyword">instanceof</span> Panel);</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> Panel) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Panel();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">a = Panel();        <span class="comment">// Window   false</span></div><div class="line">b = <span class="keyword">new</span> Panel();    <span class="comment">// Panel&#123;&#125;  true</span></div></pre></td></tr></table></figure></p>
<p>当函数作为构造器使用时，函数内的 <code>this</code> 执行被新建的对象。当函数被调用时，函数内的 <code>this</code> 则为被调用的对象，在这里是 <code>Window</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _ = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> _) <span class="keyword">return</span> obj;</div><div class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> _)) <span class="keyword">return</span> <span class="keyword">new</span> _(obj);</div><div class="line">  <span class="keyword">this</span>._wrapped = obj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>同样的，如果我们使用下面方法调用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> under = _();</div></pre></td></tr></table></figure></p>
<p>第二个条件成立，所以新建一个 <code>_</code> 对象后返回，注意这里是再次调用这个函数。<br>如果我们这样调用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> under = <span class="keyword">new</span> _();</div></pre></td></tr></table></figure></p>
<p>就好像上面第二次调用一样，这时候就构造了 <code>under</code> 这个对象，如果传入了参数 <code>obj</code>，则把 <code>obj</code> 存入 <code>under</code> 这个对象的 <code>_wrapped</code> 属性中。<br><code>Underscore</code> 提供了一个 OO 的调用方法，即:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> chainResult = <span class="function"><span class="keyword">function</span>(<span class="params">instance, obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> instance._chain ? _(obj).chain() : obj;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">_.mixin = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="comment">// 遍历obj中的函数</span></div><div class="line">    _.each(_.functions(obj), <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="comment">// 避免原型链查找，提升性能</span></div><div class="line">        <span class="keyword">var</span> func = _[name] = obj[name];</div><div class="line">        _.prototype[name] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">// 把wrapped作为数组第一个参数(context)，其余传参push到这个数组中</span></div><div class="line">            <span class="keyword">var</span> args = [<span class="keyword">this</span>._wrapped];</div><div class="line">            push.apply(args, <span class="built_in">arguments</span>);</div><div class="line">            <span class="comment">// 如果this是一个_实例，则使用func调用的结果来新建_实例后返回以供继续链式调用</span></div><div class="line">            <span class="comment">// 如果this不是一个_实例，则直接返回func调用的结果</span></div><div class="line">            <span class="keyword">return</span> chainResult(<span class="keyword">this</span>, func.apply(_, args));</div><div class="line">        &#125;;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> _;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 把Underscore对象mixin化，这样就可以直接在_上调用方法</span></div><div class="line">_.mixin(_);</div></pre></td></tr></table></figure></p>
<p>当然我们还可以把自己写的方法通过 <code>mixin</code> 加入到 <code>Underscore</code> 对象中。<br><a id="more"></a><br>在这段代码后面还把原生的一些操作方法也添加到这个 <code>_</code> 上面，这样我们就可以直接在 <code>_</code> 上调用这些方法。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Add all mutator Array functions to the wrapper.</span></div><div class="line">_.each([<span class="string">'pop'</span>, <span class="string">'push'</span>, <span class="string">'reverse'</span>, <span class="string">'shift'</span>, <span class="string">'sort'</span>, <span class="string">'splice'</span>, <span class="string">'unshift'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> method = ArrayProto[name];</div><div class="line">    _.prototype[name] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> obj = <span class="keyword">this</span>._wrapped;</div><div class="line">        method.apply(obj, <span class="built_in">arguments</span>);</div><div class="line">        <span class="keyword">if</span> ((name === <span class="string">'shift'</span> || name === <span class="string">'splice'</span>) &amp;&amp; obj.length === <span class="number">0</span>) <span class="keyword">delete</span> obj[<span class="number">0</span>];</div><div class="line">        <span class="keyword">return</span> chainResult(<span class="keyword">this</span>, obj);</div><div class="line">    &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>上面这些方法并不是 Underscore 新建的，不存在于 Underscore 对象的原型链上，所以我们要把他们加进去。和上面 <code>mixin</code> 方法类似，下面这段代码是为了兼容 IE 而采取的操作：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ((name === <span class="string">'shift'</span> || name === <span class="string">'splice'</span>) &amp;&amp; obj.length === <span class="number">0</span>) <span class="keyword">delete</span> obj[<span class="number">0</span>];</div></pre></td></tr></table></figure></p>
<blockquote>
<p>jdalton commented on 6 Dec 2011<br>IE bugs with splice() and shift(), failing to remove the 0 indexed value, when using an array-like-object with _(…).<br>IE compatibility mode and IE &lt; 9 have buggy Array shift() and splice() functions that fail to remove the last element, object[0], of array-like-objects even though the length property is set to 0.</p>
</blockquote>
<p>通过上面这些方法把 Underscore 转化为可面向对象编程，调用更加优雅，我们可以有以下两种使用方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_.map([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123; <span class="keyword">return</span> n * <span class="number">2</span>; &#125;);</div><div class="line">_([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).map(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123; <span class="keyword">return</span> n * <span class="number">2</span>; &#125;);</div></pre></td></tr></table></figure></p>
<p>至于选择哪一种就看你的喜好了～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 Underscore 的 mixin 方法。&lt;br&gt;首先先看个例子：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Panel&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  consoe.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; Panel);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; Panel) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Panel();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;a = Panel();        &lt;span class=&quot;comment&quot;&gt;// Window   false&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;b = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Panel();    &lt;span class=&quot;comment&quot;&gt;// Panel&amp;#123;&amp;#125;  true&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当函数作为构造器使用时，函数内的 &lt;code&gt;this&lt;/code&gt; 执行被新建的对象。当函数被调用时，函数内的 &lt;code&gt;this&lt;/code&gt; 则为被调用的对象，在这里是 &lt;code&gt;Window&lt;/code&gt;。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; _ = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (obj &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; _) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; obj;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; _)) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; _(obj);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._wrapped = obj;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;同样的，如果我们使用下面方法调用：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; under = _();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;第二个条件成立，所以新建一个 &lt;code&gt;_&lt;/code&gt; 对象后返回，注意这里是再次调用这个函数。&lt;br&gt;如果我们这样调用：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; under = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; _();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;就好像上面第二次调用一样，这时候就构造了 &lt;code&gt;under&lt;/code&gt; 这个对象，如果传入了参数 &lt;code&gt;obj&lt;/code&gt;，则把 &lt;code&gt;obj&lt;/code&gt; 存入 &lt;code&gt;under&lt;/code&gt; 这个对象的 &lt;code&gt;_wrapped&lt;/code&gt; 属性中。&lt;br&gt;&lt;code&gt;Underscore&lt;/code&gt; 提供了一个 OO 的调用方法，即:&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; chainResult = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;instance, obj&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance._chain ? _(obj).chain() : obj;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;_.mixin = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 遍历obj中的函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    _.each(_.functions(obj), &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 避免原型链查找，提升性能&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; func = _[name] = obj[name];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        _.prototype[name] = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 把wrapped作为数组第一个参数(context)，其余传参push到这个数组中&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; args = [&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._wrapped];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            push.apply(args, &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 如果this是一个_实例，则使用func调用的结果来新建_实例后返回以供继续链式调用&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 如果this不是一个_实例，则直接返回func调用的结果&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; chainResult(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, func.apply(_, args));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 把Underscore对象mixin化，这样就可以直接在_上调用方法&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;_.mixin(_);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当然我们还可以把自己写的方法通过 &lt;code&gt;mixin&lt;/code&gt; 加入到 &lt;code&gt;Underscore&lt;/code&gt; 对象中。&lt;br&gt;
    
    </summary>
    
      <category term="Underscore" scheme="https://ruiming.github.io/categories/Underscore/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="Underscore" scheme="https://ruiming.github.io/tags/Underscore/"/>
    
  </entry>
  
  <entry>
    <title>Underscore 源码学习(五)</title>
    <link href="https://ruiming.github.io/2016/08/04/Underscore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0(%E4%BA%94)/"/>
    <id>https://ruiming.github.io/2016/08/04/Underscore源码学习(五)/</id>
    <published>2016-08-04T07:18:48.000Z</published>
    <updated>2016-08-04T11:41:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>Underscore 的函数大部分还是挺好理解的，感觉过一遍就行了，不过今天看到两个函数感觉还是挺有意思的，并且也挺常用。这两个函数就是 throttle 和 debounce。</p>
<h2 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">_.throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, options</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> timeout, context, args, result;</div><div class="line">  <span class="keyword">var</span> previous = <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span> (!options) options = &#123;&#125;;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 更改previous即上一次执行时间为当前时间</span></div><div class="line">    previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : _.now();</div><div class="line">    timeout = <span class="literal">null</span>;</div><div class="line">    result = func.apply(context, args);</div><div class="line">    <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> now = _.now();</div><div class="line">    <span class="comment">// 如果leading为false时禁用第一次首先执行，previous等于now（效果同已经执行过一次，所以第一次被禁用）</span></div><div class="line">    <span class="comment">// 这个if语句只在第一次执行该函数的时候有效</span></div><div class="line">    <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</div><div class="line">    <span class="keyword">var</span> remaining = wait - (now - previous);</div><div class="line">    context = <span class="keyword">this</span>;</div><div class="line">    args = <span class="built_in">arguments</span>;</div><div class="line">    <span class="comment">// 超时处理和未到时的处理</span></div><div class="line">    <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</div><div class="line">      <span class="comment">// timeout不为null时清除掉并设置为null</span></div><div class="line">      <span class="keyword">if</span> (timeout) &#123;</div><div class="line">        clearTimeout(timeout);</div><div class="line">        timeout = <span class="literal">null</span>;</div><div class="line">      &#125;</div><div class="line">      previous = now;</div><div class="line">      <span class="comment">// 立即调用</span></div><div class="line">      result = func.apply(context, args);</div><div class="line">      <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;    <span class="comment">// 如果没有禁用最后一次执行</span></div><div class="line">      timeout = setTimeout(later, remaining);               <span class="comment">// remaining毫秒后执行later</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 返回调用的结果</span></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  throttled.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    clearTimeout(timeout);</div><div class="line">    previous = <span class="number">0</span>;</div><div class="line">    timeout = context = args = <span class="literal">null</span>;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> throttled;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其实一步步去理解也不难，就不细说这个方法了。这个方法有可选项设置，分别为 {leading: false} 和 {trailing: false}。</p>
<p>所以一般有四类情况：</p>
<ul>
<li>默认情况<br>第一次调用时立即响应，之后每个周期内最多执行一次，周期内触发会产生定时执行使在上一次执行时间 <code>preview</code> 周期时间后再次执行。</li>
<li>设置 <code>leading</code> 为 <code>false</code><br>同默认情况区别在于第一次调用不会立即执行而是等待周期时间后再次执行，如果在周期时间内触发，一样等待上一次执行时间 <code>preview</code> 周期时间后再执行。</li>
<li>设置 <code>trailing</code> 为 <code>false</code><br>最后周期内最多执行一次，但在周期时间内调用不会触发 <code>timeout</code>，只能在上一次 <code>timeout</code> 失效后调用才能生效并且此时调用将立即执行。</li>
<li>设置 <code>leading</code> 和 <code>trailing</code> 为 <code>false</code><br>如果同时还设置 <code>leading</code> 为 <code>false</code> 的话，那么第一次调用不会立即执行而是等待周期时间后才执行，在这段时间内调用都不会有效果。</li>
</ul>
<a id="more"></a>
<p>比如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = _.throttle(updatePosition, <span class="number">100</span>);</div><div class="line">$(<span class="built_in">window</span>).scroll(func);</div></pre></td></tr></table></figure></p>
<p>由于 scroll 过程时, <code>func</code> 函数的调用是很密集的，我们不能每次调用都去执行，可以通过设置 throttle 来达到节流阀的作用。<code>leading</code> 和 <code>trailing</code> 只是实现上细微的不同而已。</p>
<p>throll 主要应用在鼠标移动，mousemove 事件，DOM 元素动态定位，window 对象的 resize 和 scroll 等事件。这些事件触发频率高，但又要尽可能进行响应。</p>
<h2 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">_.debounce = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> timeout, result;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params">context, args</span>) </span>&#123;</div><div class="line">    timeout = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">if</span> (args) result = func.apply(context, args);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> debounced = restArgs(<span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</div><div class="line">    <span class="comment">// 再次调用且上次还未执行，则清除上次的timeout</span></div><div class="line">    <span class="comment">// 只是timeout事件不再执行，但timeout依旧存在</span></div><div class="line">    <span class="keyword">if</span> (timeout) clearTimeout(timeout);</div><div class="line">    <span class="comment">// 如果immediate为true</span></div><div class="line">    <span class="keyword">if</span> (immediate) &#123;</div><div class="line">      <span class="comment">// 如果timeout为null，则立即调用函数</span></div><div class="line">      <span class="comment">// 如果timeout不为null，则callNow为false，函数不执行</span></div><div class="line">      <span class="keyword">var</span> callNow = !timeout;</div><div class="line">      timeout = setTimeout(later, wait);</div><div class="line">      <span class="keyword">if</span> (callNow) result = func.apply(<span class="keyword">this</span>, args);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 延迟later执行，如果这个还没到时间再来一次，则新的会覆盖上一次的</span></div><div class="line">      timeout = _.delay(later, wait, <span class="keyword">this</span>, args);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  debounced.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    clearTimeout(timeout);</div><div class="line">    timeout = <span class="literal">null</span>;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> debounced;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数就要比上面那个好理解一点，说明下这个函数：</p>
<ul>
<li><p>如果 <code>immediate</code> 为 <code>true</code>，周期 100ms</p>
<ul>
<li>0   =&gt; 立即执行，设置 <code>timeout</code></li>
<li>50  =&gt; 重新设置 <code>timeout</code>，不执行</li>
<li>100 =&gt; 重新设置 <code>timeout</code>，不执行</li>
<li>200 =&gt; <code>timeout</code> 到时，执行函数</li>
</ul>
</li>
<li><p>如果 <code>immediate</code> 为 <code>false</code>, 周期 100ms</p>
<ul>
<li>0   =&gt; 设置 <code>timeout</code>，不执行</li>
<li>100 =&gt; <code>timeout</code> 到时，执行函数</li>
<li>120 =&gt; 设置 <code>timeout</code>，不执行</li>
<li>180 =&gt; 重新设置 <code>timeout</code>，不执行</li>
<li>280 =&gt; <code>timeout</code> 到时，执行函数</li>
</ul>
</li>
</ul>
<p>其实 <code>timeout</code> 就变成一个控制两次事件触发间隔用的，并且和上面的 throttle 不同，<code>timeout</code> 会被重新设置。</p>
<p>debounce 主要应用在文本输入 keydown 事件，keyup 事件，例如做 autocomplete。</p>
<p>结合两个的应用细细体味下他们差别。如果想自己体验下差别，<a href="http://jsfiddle.net/missinglink/19e2r2we/" target="_blank" rel="external">传送门</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Underscore 的函数大部分还是挺好理解的，感觉过一遍就行了，不过今天看到两个函数感觉还是挺有意思的，并且也挺常用。这两个函数就是 throttle 和 debounce。&lt;/p&gt;
&lt;h2 id=&quot;throttle&quot;&gt;&lt;a href=&quot;#throttle&quot; class=&quot;headerlink&quot; title=&quot;throttle&quot;&gt;&lt;/a&gt;throttle&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;_.throttle = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;func, wait, options&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; timeout, context, args, result;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; previous = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!options) options = &amp;#123;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; later = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 更改previous即上一次执行时间为当前时间&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    previous = options.leading === &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt; ? &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; : _.now();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    timeout = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    result = func.apply(context, args);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!timeout) context = args = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; throttled = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; now = _.now();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果leading为false时禁用第一次首先执行，previous等于now（效果同已经执行过一次，所以第一次被禁用）&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 这个if语句只在第一次执行该函数的时候有效&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!previous &amp;amp;&amp;amp; options.leading === &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;) previous = now;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; remaining = wait - (now - previous);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    context = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    args = &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 超时处理和未到时的处理&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (remaining &amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; || remaining &amp;gt; wait) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// timeout不为null时清除掉并设置为null&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (timeout) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        clearTimeout(timeout);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        timeout = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      previous = now;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 立即调用&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      result = func.apply(context, args);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!timeout) context = args = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!timeout &amp;amp;&amp;amp; options.trailing !== &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;) &amp;#123;    &lt;span class=&quot;comment&quot;&gt;// 如果没有禁用最后一次执行&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      timeout = setTimeout(later, remaining);               &lt;span class=&quot;comment&quot;&gt;// remaining毫秒后执行later&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 返回调用的结果&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  throttled.cancel = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    clearTimeout(timeout);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    previous = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    timeout = context = args = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; throttled;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其实一步步去理解也不难，就不细说这个方法了。这个方法有可选项设置，分别为 {leading: false} 和 {trailing: false}。&lt;/p&gt;
&lt;p&gt;所以一般有四类情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认情况&lt;br&gt;第一次调用时立即响应，之后每个周期内最多执行一次，周期内触发会产生定时执行使在上一次执行时间 &lt;code&gt;preview&lt;/code&gt; 周期时间后再次执行。&lt;/li&gt;
&lt;li&gt;设置 &lt;code&gt;leading&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt;&lt;br&gt;同默认情况区别在于第一次调用不会立即执行而是等待周期时间后再次执行，如果在周期时间内触发，一样等待上一次执行时间 &lt;code&gt;preview&lt;/code&gt; 周期时间后再执行。&lt;/li&gt;
&lt;li&gt;设置 &lt;code&gt;trailing&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt;&lt;br&gt;最后周期内最多执行一次，但在周期时间内调用不会触发 &lt;code&gt;timeout&lt;/code&gt;，只能在上一次 &lt;code&gt;timeout&lt;/code&gt; 失效后调用才能生效并且此时调用将立即执行。&lt;/li&gt;
&lt;li&gt;设置 &lt;code&gt;leading&lt;/code&gt; 和 &lt;code&gt;trailing&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt;&lt;br&gt;如果同时还设置 &lt;code&gt;leading&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 的话，那么第一次调用不会立即执行而是等待周期时间后才执行，在这段时间内调用都不会有效果。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Underscore" scheme="https://ruiming.github.io/categories/Underscore/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="Underscore" scheme="https://ruiming.github.io/tags/Underscore/"/>
    
  </entry>
  
  <entry>
    <title>谈谈 React 和 Redux</title>
    <link href="https://ruiming.github.io/2016/08/01/%E8%B0%88%E8%B0%88React%E5%92%8CRedux/"/>
    <id>https://ruiming.github.io/2016/08/01/谈谈React和Redux/</id>
    <published>2016-08-01T07:53:32.000Z</published>
    <updated>2016-08-04T08:33:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚回到家的时候学习了 React 和 Redux，现在才想来总结一下，不知道会不会忘的差不多了…本来是想写一个问卷发布系统的，使用 React 和 Redux 已经完成了基础的几个功能，但是那个代码量…用 Angular 写简直轻轻松松的好吧…然后就去重构项目还有现在学的 Underscore 去了。是时候重新回顾下了。<br>此处主要讲的是 Redux 。</p>
<h3 id="关于-Redux"><a href="#关于-Redux" class="headerlink" title="关于 Redux"></a>关于 Redux</h3><blockquote>
<p>redux 是facebook 提出的 flux 架构的一种优秀实现；而且不局限于为 react 提供数据状态处理。它是零依赖的，可以配合其他任何框架或者类库一起使用。要想配合 react，还得引入 react-redux。</p>
</blockquote>
<h3 id="关于-Flux"><a href="#关于-Flux" class="headerlink" title="关于 Flux"></a>关于 Flux</h3><p>那什么是 Flux 呢？见下图<br><img src="/2016/08/01/谈谈React和Redux/flux-overview.png" alt="flux-overview.png" title="flux-overview.png"><br>Flux 可以分为四个部分：</p>
<ul>
<li>View: 视图层</li>
<li>Action: 视图层触发的动作</li>
<li>Dispatcher: 派发器，用来接受 Actions, 执行回调函数</li>
<li>Store：数据层，用来存放应用的状态，其变更会触发 View 层更新</li>
</ul>
<p>Flux 的最大特点就是单向流动，他的过程大概如下：</p>
<ol>
<li>用户访问 View ，触发了动作 Action</li>
<li>Dispatcher 收到 Action ，根据 Action 类别进行相应的处理，处理结束后要求 Store 更新</li>
<li>Store 进行更新，通知 View 层刷新</li>
<li>View 层收到通知更新页面</li>
</ol>
<p>额，其实我没有用 Flux，不敢讲太多了，简单的说就是一种单项数据流动的解决方案吧。我是直接学 Redux，对 Flux 也就大概了解这么多了。</p>
<h3 id="Redux-和-Flux"><a href="#Redux-和-Flux" class="headerlink" title="Redux 和 Flux"></a>Redux 和 Flux</h3><p>Redux 是 Flux 的一种实现，但他们又有所不同，在 Flux 中，Store 可以有多个，但 Redux 有且只能有一个 Store，Flux 中存在 Dispatcher，在 Redux 则没有这个，而是用 reducer 代替了。不多说了，直接往下说 Redux 吧，我快扯不下去 Flux 了=.=</p>
<h3 id="理解Redux"><a href="#理解Redux" class="headerlink" title="理解Redux"></a>理解Redux</h3><p>Redux 由四部分组成：</p>
<ul>
<li>Action</li>
<li>Reducer</li>
<li>Store</li>
<li>Views</li>
</ul>
<p>我们结合具体的应用场景来看</p>
<h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>先从 Action 说起，一个 Action 是一个普通的对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> SET_PAPER_TITLE = <span class="string">'SET_PAPER_TITLE'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_QUESTION = <span class="string">'ADD_QUESTION'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> REMOVE_QUESTION = <span class="string">'REMOVE_QUESTION'</span>;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setPaperTitle</span>(<span class="params">newTitle</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">type</span>: SET_PAPER_TITLE,</div><div class="line">        <span class="attr">value</span>: newTitle</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addQuestion</span>(<span class="params">type</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">type</span>: ADD_QUESTION,</div><div class="line">        <span class="attr">questionType</span>: type</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">removeQuestion</span>(<span class="params">questionId</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">type</span>: REMOVE_QUESTION,</div><div class="line">        <span class="attr">questionId</span>: questionId</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>type 属性是必须的，表示动作类别，其他的参数可以自定。<br>我们先不用管 Action 有什么用，后面会提到。<br><a id="more"></a></p>
<h4 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h4><p>在 Action 这一层中，可以筛选掉脏数据，多余的参数不会传入，真正处理数据是在 Reducer 中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; SET_PAPER_TITLE, ADD_QUESTION, REMOVE_QUESTION, ADD_OPTION, REMOVE_OPTION, SET_QUESTION_TITLE, SET_OPTION_TITLE &#125; <span class="keyword">from</span> <span class="string">'../action/action'</span></div><div class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">paperReducer</span>(<span class="params">state=[], action</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span>(action.type) &#123;</div><div class="line">        <span class="keyword">case</span> SET_PAPER_TITLE:</div><div class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</div><div class="line">                <span class="attr">title</span>: action.value</div><div class="line">            &#125;);</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">questionsReducer</span>(<span class="params">state=[], action</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span>(action.type) &#123;</div><div class="line">        <span class="keyword">case</span> ADD_QUESTION:</div><div class="line">            <span class="keyword">return</span> [</div><div class="line">                ...state,</div><div class="line">                &#123;</div><div class="line">                    <span class="attr">title</span>: <span class="string">''</span>,</div><div class="line">                    <span class="attr">type</span>: action.questionType,</div><div class="line">                    <span class="attr">content</span>: [<span class="string">''</span>,<span class="string">''</span>,<span class="string">''</span>,<span class="string">''</span>]</div><div class="line">                &#125;</div><div class="line">            ];</div><div class="line">        <span class="keyword">case</span> REMOVE_QUESTION:</div><div class="line">            <span class="keyword">return</span> [</div><div class="line">                ...state.slice(<span class="number">0</span>, action.questionId),</div><div class="line">                ...state.slice(action.questionId+<span class="number">1</span>)</div><div class="line">            ];</div><div class="line">        <span class="keyword">case</span> ADD_OPTION:</div><div class="line">        <span class="keyword">case</span> REMOVE_OPTION:</div><div class="line">        <span class="keyword">case</span> SET_QUESTION_TITLE:</div><div class="line">        <span class="keyword">case</span> SET_OPTION_TITLE:</div><div class="line">            <span class="keyword">return</span> [</div><div class="line">                ...state.slice(<span class="number">0</span>, action.questionId),</div><div class="line">                questionReducer(state[action.questionId], action),</div><div class="line">                ...state.slice(action.questionId+<span class="number">1</span>)</div><div class="line">            ];</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> paperApp = combineReducers(&#123;</div><div class="line">    <span class="attr">paper</span>: paperReducer,</div><div class="line">    <span class="attr">questions</span>: questionsReducer</div><div class="line">&#125;);</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> paperApp;</div></pre></td></tr></table></figure></p>
<p>这里列了很多 Action，但在上面的 Action 部分我只提了两个，其他的其实都一样的，就是参数可能有些区别而已。<br>这里就要好好说一笔了，reducer 之所以叫 reducer，一个原因就是他很类似 JavaScript 中数组的 reduce 方法，接收两个参数，一个是当前状态，一个是处理方法。<br>但在 Redux 中，不要直接修改当前状态即 <code>state</code>，而应该返回一个新的 <code>state</code>，而这样做的其中一个好处就是可以实现时间旅行的功能，即可以回溯到任意版本的数据，并且对于判断 <code>state</code> 是否发生修改也很重要，如果是在原引用上修改我们得用 <code>deepEqual</code> 深度遍历来对比值，而如果返回了一个新的对象则可以直接使用 <code>===</code> 来判断两个数据是否一致，不一致则触发更改。reducer 方法应该都能看懂，接下来是 combineReducers 这个。<br>我上面其实涉及到三个 reducer 了，分别是</p>
<ul>
<li>paperReducer</li>
<li>questionsReducer</li>
<li>questionReducer</li>
</ul>
<p>但为了减少空间，我没有把 <code>questionReducer</code> 写出来。其实注意看从29行到32行的四个 Action，我都传入 <code>state</code> 中的部分数据给了 <code>questionReducer</code> 去做处理。因为这些都是涉及一个问题的修改的，所以就单独列出来。这样就不致于一个 reducer 写太多东西。<br>实质上还是两个 reducer 而已，这里的 combineReducers 就是把这两个 reducer 合并在一起。这两个 reducer 一个是处理问卷信息如问卷标题，一个是处理问卷的问题比如新建删除问题，问题修改这些。</p>
<h4 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h4><p>使用 combineReducers 就要求我们 Store 的设计合理，因为 Store 和 reducer 是要对应的，<code>questionsReducer</code> 只要处理问题，而 <code>paperReducer</code> 只要处理问卷本身，所以也就不需要往 <code>paperReducer</code> 传入完整的 <code>state</code> 信息。我们看下 Store。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></div><div class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span></div><div class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></div><div class="line"><span class="keyword">import</span> paperApp <span class="keyword">from</span> <span class="string">'./reducer/reducer'</span></div><div class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./containers/App'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> initialState = &#123;</div><div class="line">    <span class="attr">paper</span>: &#123;</div><div class="line">        <span class="attr">title</span>: <span class="string">'asd'</span>,</div><div class="line">        <span class="attr">time</span>: <span class="string">"2016-7-19"</span>,</div><div class="line">        <span class="attr">author</span>: <span class="string">"Ruiming"</span>,</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">questions</span>: [&#123;</div><div class="line">        <span class="attr">title</span>: <span class="string">''</span>,</div><div class="line">        <span class="attr">type</span>: <span class="string">'radio'</span>,</div><div class="line">        <span class="attr">content</span>: [<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>]</div><div class="line">    &#125;, &#123;</div><div class="line">        <span class="attr">title</span>: <span class="string">''</span>,</div><div class="line">        <span class="attr">type</span>: <span class="string">'checkbox'</span>,</div><div class="line">        <span class="attr">content</span>: [<span class="string">''</span>,<span class="string">''</span>,<span class="string">''</span>,<span class="string">''</span>]</div><div class="line">    &#125;]</div><div class="line">&#125;;</div><div class="line"><span class="keyword">let</span> store = createStore(paperApp, initialState);</div><div class="line"><span class="keyword">let</span> rootElement = <span class="built_in">document</span>.getElementById(<span class="string">'index'</span>);</div><div class="line">render (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">App</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span>,</div><div class="line">    rootElement</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>我们初始一个数据 initialState，调用 createStore 方法需要传入两个参数，分别就是我们上面 combineReducers 后的<code>paperApp</code>和我们的数据。在初始数据中，有两个对象分别是<code>paper</code>和<code>questions</code>，这就刚好和 combineReducers 中的<code>paper</code>和<code>questions</code>对应，从而实现传递部分<code>state</code>。<br>下面的 render 部分是就是渲染部分了， Provider 是 react-redux 提供的一个容器，将 Store 作为属性传递给该容器。</p>
<h4 id="Views"><a href="#Views" class="headerlink" title="Views"></a>Views</h4><p>我们看下 App 的内容<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component, PropTypes &#125; <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></div><div class="line"><span class="keyword">import</span> &#123; addQuestion, addOption, setPaperTitle, setQuestionTitle, setOptionTitle, removeQuestion, removeOption &#125; <span class="keyword">from</span> <span class="string">'../action/action'</span></div><div class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'../components/Header'</span></div><div class="line"><span class="keyword">import</span> NewQuestionBar <span class="keyword">from</span> <span class="string">'../components/NewQuestionBar'</span></div><div class="line"><span class="keyword">import</span> OptionsBar <span class="keyword">from</span> <span class="string">'../components/OptionsBar'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">const</span> &#123; dispatch, title, questions &#125; = <span class="keyword">this</span>.props;</div><div class="line">        <span class="keyword">return</span> &lt;div ref="paper"&gt;</div><div class="line">            &lt;Header title=&#123;title&#125;</div><div class="line">                    setPaperTitle=&#123;(title) =&gt; dispatch(setPaperTitle(title))&#125;</div><div class="line">                /&gt;</div><div class="line">            &lt;NewQuestionBar addQuestion=&#123;(type) =&gt; dispatch(addQuestion(type))&#125; /&gt;</div><div class="line">            &lt;section className="paper"&gt;</div><div class="line">                &lt;ul className="paper-list"&gt;</div><div class="line">                    &#123;questions.map(function(question, i) &#123;</div><div class="line">                        return &lt;OptionsBar content=&#123;question.content&#125;</div><div class="line">                                           addQuestion=&#123;() =&gt; dispatch(addQuestion())&#125;</div><div class="line">                                           addOption=&#123;(questionId) =&gt; dispatch(addOption(questionId))&#125;</div><div class="line">                        /&gt;</div><div class="line">                    &#125;.bind(this))</div><div class="line">                    &#125;</div><div class="line">                &lt;/ul&gt;</div><div class="line">            &lt;/section&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function select(state) &#123;</div><div class="line">    return &#123;</div><div class="line">        paper: state.paper,</div><div class="line">        questions: state.questions</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default connect(select)(App);</div></pre></td></tr></table></figure></p>
<p>上面我去掉了很多部分，只保留了 <code>addQuestion</code> 和 <code>addOption</code> 这两个，我们看下这两个就好了。其实这部分的写法就是 React 写法而已，只是多了个 dispatch 方法。注意下最后的 connect 方法，他的作用是：</p>
<ul>
<li>把所需要的 <code>state</code> 属性挂载到组件的 <code>props</code> 上。</li>
<li>为组件的 <code>props</code> 添加 <code>dispatch</code> 方法。</li>
</ul>
<h3 id="Redux-运行过程"><a href="#Redux-运行过程" class="headerlink" title="Redux 运行过程"></a>Redux 运行过程</h3><p>介绍完了 Redux 的四个部分，接下来就要说下这个运行的流程了。这才是理解 Redux 的关键。</p>
<ol>
<li>用户在视图触发 dispatch 事件</li>
<li>Redux 响应用户操作生成 action </li>
<li>action 传到 store 层，可以使用中间件进行一些处理</li>
<li>action 传 <code>state</code> 和 <code>action</code> 给 reducer 处理</li>
<li>reducer 返回一个新的 <code>state</code></li>
<li>store 读取 reducer 返回的内容，设置新的状态</li>
</ol>
<p>大致就是以上过程，action 是唯一可以改变状态的途径，不仅包括用户的触发，也可以是来自服务器的推送，action 进行预处理后会传到 store，由 store 发送动作给 reducer，带上当前状态和当前动作，reducer 根据动作的 type 来进行不同的处理。注意 action 和 reducer 都是纯函数。</p>
<p>Redux 大致就是这么一回事，我们可以看到所有数据都来自一个对象 Store，这样就方便了调试测试，可以把 Store 就想象成一个数据库。state 只读，只能通过 action 改变，并且必须保证 reducer 是纯函数，所谓纯函数就是相同参数传入无数次他们都返回相同的东西，其实就是内部没有使用外部变量，外部变量总是伴随着不确定性。</p>
<h3 id="React-和-Angular"><a href="#React-和-Angular" class="headerlink" title="React 和 Angular"></a>React 和 Angular</h3><p>React 现在很博人眼球，虚拟DOM提升了页面渲染性能，并且衍生的 React Native 也非常有诱惑力，单向数据流动虽然带来了清晰的逻辑和更高的性能，但降低了开发效率。另外，使用 React 开发的应用天然组件化，也方便了后期的维护。</p>
<p>Angular 是一个功能完善全面的框架，还自带了 $http, ngRoute, jQlite, $q, service 等等。提供了一整套的解决方案，估计这点很合大公司的胃口。并且 Angular 社区成熟活跃，生态完整，目前仍是最流行的前端框架，没有之一，非常适合用来写单页应用。数据双向绑定给开发带来了很大的便利，但双向绑定带来了性能损耗并且脏值检查性能也不好。</p>
<p>对比起来，我还是更喜欢 Angular，他的开发效率高，而且写起来很清晰，虽然他也有一些问题，但是在没有达到一个量级前这些问题是很难被体现出来的。而 React 可能在开发多端或者注重体积或者是在大型应用中可能才会去考虑吧。</p>
<p>另外 Angular2 也实现了虚拟 DOM，同样支持服务端渲染，使用 web worker 提升性能，TypeScript 提升了 JavaScript 项目的健壮性，而 Web Components 无疑是是未来趋势。我对 Angular2 同样满怀期待，我认为 Angular2 未来也会同 Angular1 一样火起来。</p>
<p>计划是再学习 react-router，写一个完整的 React 应用，后端使用 Koa 来开发。不过还是等手头上的东西处理完先吧。</p>
<p>除了 Angular1 和 Angular2 以及 React ，还有 Vue 和 Vue2 以及阿里的 Weex，前端的水深着呢！</p>
<hr>
<p><a href="https://github.com/Lucifier129/Lucifier129.github.io/issues/9" target="_blank" rel="external">深入到源码：解读 redux 的设计思路与用法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚回到家的时候学习了 React 和 Redux，现在才想来总结一下，不知道会不会忘的差不多了…本来是想写一个问卷发布系统的，使用 React 和 Redux 已经完成了基础的几个功能，但是那个代码量…用 Angular 写简直轻轻松松的好吧…然后就去重构项目还有现在学的 Underscore 去了。是时候重新回顾下了。&lt;br&gt;此处主要讲的是 Redux 。&lt;/p&gt;
&lt;h3 id=&quot;关于-Redux&quot;&gt;&lt;a href=&quot;#关于-Redux&quot; class=&quot;headerlink&quot; title=&quot;关于 Redux&quot;&gt;&lt;/a&gt;关于 Redux&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;redux 是facebook 提出的 flux 架构的一种优秀实现；而且不局限于为 react 提供数据状态处理。它是零依赖的，可以配合其他任何框架或者类库一起使用。要想配合 react，还得引入 react-redux。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;关于-Flux&quot;&gt;&lt;a href=&quot;#关于-Flux&quot; class=&quot;headerlink&quot; title=&quot;关于 Flux&quot;&gt;&lt;/a&gt;关于 Flux&lt;/h3&gt;&lt;p&gt;那什么是 Flux 呢？见下图&lt;br&gt;&lt;img src=&quot;/2016/08/01/谈谈React和Redux/flux-overview.png&quot; alt=&quot;flux-overview.png&quot; title=&quot;flux-overview.png&quot;&gt;&lt;br&gt;Flux 可以分为四个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;View: 视图层&lt;/li&gt;
&lt;li&gt;Action: 视图层触发的动作&lt;/li&gt;
&lt;li&gt;Dispatcher: 派发器，用来接受 Actions, 执行回调函数&lt;/li&gt;
&lt;li&gt;Store：数据层，用来存放应用的状态，其变更会触发 View 层更新&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Flux 的最大特点就是单向流动，他的过程大概如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户访问 View ，触发了动作 Action&lt;/li&gt;
&lt;li&gt;Dispatcher 收到 Action ，根据 Action 类别进行相应的处理，处理结束后要求 Store 更新&lt;/li&gt;
&lt;li&gt;Store 进行更新，通知 View 层刷新&lt;/li&gt;
&lt;li&gt;View 层收到通知更新页面&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;额，其实我没有用 Flux，不敢讲太多了，简单的说就是一种单项数据流动的解决方案吧。我是直接学 Redux，对 Flux 也就大概了解这么多了。&lt;/p&gt;
&lt;h3 id=&quot;Redux-和-Flux&quot;&gt;&lt;a href=&quot;#Redux-和-Flux&quot; class=&quot;headerlink&quot; title=&quot;Redux 和 Flux&quot;&gt;&lt;/a&gt;Redux 和 Flux&lt;/h3&gt;&lt;p&gt;Redux 是 Flux 的一种实现，但他们又有所不同，在 Flux 中，Store 可以有多个，但 Redux 有且只能有一个 Store，Flux 中存在 Dispatcher，在 Redux 则没有这个，而是用 reducer 代替了。不多说了，直接往下说 Redux 吧，我快扯不下去 Flux 了=.=&lt;/p&gt;
&lt;h3 id=&quot;理解Redux&quot;&gt;&lt;a href=&quot;#理解Redux&quot; class=&quot;headerlink&quot; title=&quot;理解Redux&quot;&gt;&lt;/a&gt;理解Redux&lt;/h3&gt;&lt;p&gt;Redux 由四部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Action&lt;/li&gt;
&lt;li&gt;Reducer&lt;/li&gt;
&lt;li&gt;Store&lt;/li&gt;
&lt;li&gt;Views&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们结合具体的应用场景来看&lt;/p&gt;
&lt;h4 id=&quot;Action&quot;&gt;&lt;a href=&quot;#Action&quot; class=&quot;headerlink&quot; title=&quot;Action&quot;&gt;&lt;/a&gt;Action&lt;/h4&gt;&lt;p&gt;先从 Action 说起，一个 Action 是一个普通的对象。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; SET_PAPER_TITLE = &lt;span class=&quot;string&quot;&gt;&#39;SET_PAPER_TITLE&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; ADD_QUESTION = &lt;span class=&quot;string&quot;&gt;&#39;ADD_QUESTION&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; REMOVE_QUESTION = &lt;span class=&quot;string&quot;&gt;&#39;REMOVE_QUESTION&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setPaperTitle&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;newTitle&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;type&lt;/span&gt;: SET_PAPER_TITLE,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;value&lt;/span&gt;: newTitle&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;addQuestion&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;type&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;type&lt;/span&gt;: ADD_QUESTION,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;questionType&lt;/span&gt;: type&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;removeQuestion&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;questionId&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;type&lt;/span&gt;: REMOVE_QUESTION,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;questionId&lt;/span&gt;: questionId&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;type 属性是必须的，表示动作类别，其他的参数可以自定。&lt;br&gt;我们先不用管 Action 有什么用，后面会提到。&lt;br&gt;
    
    </summary>
    
      <category term="React" scheme="https://ruiming.github.io/categories/React/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="React" scheme="https://ruiming.github.io/tags/React/"/>
    
      <category term="Redux" scheme="https://ruiming.github.io/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>Underscore 源码学习(四)</title>
    <link href="https://ruiming.github.io/2016/08/01/Underscore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0(%E5%9B%9B)/"/>
    <id>https://ruiming.github.io/2016/08/01/Underscore源码学习(四)/</id>
    <published>2016-08-01T07:37:14.000Z</published>
    <updated>2016-08-04T08:33:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>终于看完了 Underscore 的集合部分了，看 Underscore 源码真的是长见识了，感觉真的受益匪浅。<br>但是集合里面方法也挺多的，我都不知道该拿哪些出来讲下，最近接触了 Redux，就说下 createRedux 这个方法吧，为后面讲 Redux 做个铺垫。<br>先看源码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> createReduce = <span class="function"><span class="keyword">function</span>(<span class="params">dir</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> reducer = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, memo, initial</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</div><div class="line">        length = (keys || obj).length,</div><div class="line">        index = dir &gt; <span class="number">0</span> ? <span class="number">0</span> : length - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(!initial) &#123;</div><div class="line">      memo = obj[keys ? keys[index] : index];</div><div class="line">      index += dir;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(; index &gt;= <span class="number">0</span> &amp;&amp; index &lt; length; index += dir) &#123;</div><div class="line">      <span class="keyword">var</span> currentKey = keys ? keys[index] : index;</div><div class="line">      memo = iteratee(memo, obj[currentKey], currentKey, obj);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> memo;</div><div class="line">  &#125;;</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, memo, context</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> initial = <span class="built_in">arguments</span>.length &gt;= <span class="number">3</span>;</div><div class="line">    <span class="keyword">return</span> reducer(obj, opitimizeCb(iteratee, context, <span class="number">4</span>), memo, initial);</div><div class="line">  &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这是 reduce 函数的工厂函数，用于生成一个 reducer ，dir 是决定方向用的。<br>我们从最后一个 return 开始看起，即<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, memo, context</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> initial = <span class="built_in">arguments</span>.length &gt;= <span class="number">3</span>;</div><div class="line">  <span class="keyword">return</span> reducer(obj, opitimizeCb(iteratee, context, <span class="number">4</span>), memo, initial);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>我们使用 reduce 的时候，如果没有指定 memo 值，这时候参数个数只有两个即 obj 和 iteratee，所以 initial 为 false 表示没有初始化。对于没初始的情况，就是增加了一个 if 语句里面的内容而已，作用是把第一个元素作为 memo 值。<br>接着就是有没有初始化都共用的部分了，通过一个 for 循环把 keys 遍历，并把相应的信息交给 iteratee 去处理，参数 memo 是上一次处理结果。遍历完后把最后的处理结果 memo 返回就完了。<br>这个函数派生了两个方法，即<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_.reduce = _.foldl = _.inject = createReduce(<span class="number">1</span>);</div><div class="line">_.reduceRight = _.foldr = createReduce(<span class="number">-1</span>);</div></pre></td></tr></table></figure></p>
<p>只是方向不同而已。<br>举个例子方便理解些，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = _.reduce([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="function"><span class="keyword">function</span>(<span class="params">accumulator, value, index, collection</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> accmulator + value;</div><div class="line">&#125;, <span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p>结果为 15 这个应该很明显，js 原生也有 reduce 方法，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">left, right</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> left + right;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>我们看下 Underscore 的例子，主要想说明下他的运行过程，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!initial)</div><div class="line">    memo = <span class="number">1</span>; index = <span class="number">1</span>;</div><div class="line">endif</div><div class="line"><span class="keyword">for</span></div><div class="line">    memo = iteratee(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) = <span class="number">3</span>;</div><div class="line">    memo = iteratee(<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) = <span class="number">6</span>;</div><div class="line">    memo = iteratee(<span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) = <span class="number">10</span>;</div><div class="line">    memo = iteratee(<span class="number">10</span>, <span class="number">5</span>, <span class="number">4</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) = <span class="number">15</span>;</div><div class="line">endfor</div><div class="line"><span class="keyword">return</span> memo = <span class="number">15</span>;</div></pre></td></tr></table></figure></p>
<p>额，我也不知道写的是什么东西，只是描述下过程而已，你懂的。<br>剩下的集合部分感觉也没啥好说的了，花点时间看下就可以看懂了=.=。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于看完了 Underscore 的集合部分了，看 Underscore 源码真的是长见识了，感觉真的受益匪浅。&lt;br&gt;但是集合里面方法也挺多的，我都不知道该拿哪些出来讲下，最近接触了 Redux，就说下 createRedux 这个方法吧，为后面讲 Redux 做个铺垫。&lt;br&gt;先看源码&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; createReduce = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;dir&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; reducer = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj, iteratee, memo, initial&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; keys = !isArrayLike(obj) &amp;amp;&amp;amp; _.keys(obj),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        length = (keys || obj).length,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        index = dir &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ? &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; : length - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!initial) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      memo = obj[keys ? keys[index] : index];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      index += dir;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(; index &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; index &amp;lt; length; index += dir) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; currentKey = keys ? keys[index] : index;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      memo = iteratee(memo, obj[currentKey], currentKey, obj);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; memo;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj, iteratee, memo, context&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; initial = &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;.length &amp;gt;= &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; reducer(obj, opitimizeCb(iteratee, context, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;), memo, initial);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这是 reduce 函数的工厂函数，用于生成一个 reducer ，dir 是决定方向用的。&lt;br&gt;我们从最后一个 return 开始看起，即&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj, iteratee, memo, context&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; initial = &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;.length &amp;gt;= &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; reducer(obj, opitimizeCb(iteratee, context, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;), memo, initial);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们使用 reduce 的时候，如果没有指定 memo 值，这时候参数个数只有两个即 obj 和 iteratee，所以 initial 为 false 表示没有初始化。对于没初始的情况，就是增加了一个 if 语句里面的内容而已，作用是把第一个元素作为 memo 值。&lt;br&gt;接着就是有没有初始化都共用的部分了，通过一个 for 循环把 keys 遍历，并把相应的信息交给 iteratee 去处理，参数 memo 是上一次处理结果。遍历完后把最后的处理结果 memo 返回就完了。&lt;br&gt;这个函数派生了两个方法，即&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;_.reduce = _.foldl = _.inject = createReduce(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;_.reduceRight = _.foldr = createReduce(&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;只是方向不同而已。&lt;br&gt;举个例子方便理解些，例如：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; sum = _.reduce([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;], &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;accumulator, value, index, collection&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; accmulator + value;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;结果为 15 这个应该很明显，js 原生也有 reduce 方法，如下：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;].reduce(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;left, right&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; left + right;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Underscore" scheme="https://ruiming.github.io/categories/Underscore/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="Underscore" scheme="https://ruiming.github.io/tags/Underscore/"/>
    
  </entry>
  
</feed>
