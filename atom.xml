<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ruiming&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ruiming.github.io/"/>
  <updated>2016-10-14T11:54:55.587Z</updated>
  <id>https://ruiming.github.io/</id>
  
  <author>
    <name>Ruiming</name>
    <email>ruiming.zhuang@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于前后端分离鉴权的思考</title>
    <link href="https://ruiming.github.io/2016/10/14/%E5%85%B3%E4%BA%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%89%B4%E6%9D%83%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://ruiming.github.io/2016/10/14/关于前后端分离鉴权的思考/</id>
    <published>2016-10-14T11:29:05.000Z</published>
    <updated>2016-10-14T11:54:55.587Z</updated>
    
    <content type="html"><![CDATA[<p>前后端分离项目的 Token 存储问题由来已久，有的人存 Cookie 有的人存 LocalStorage 或 SessionStorage，最近刚把 RSS 订阅器项目的鉴权问题做好，感觉算是目前比较稳妥安全的方案了，分享一下经验。</p>
<p>前端用的是 Angular，后端用的是 Koa，登录注册界面由 Koa 负责，由 Koa 根据用户是否登录来决定首页跳转。我不会一开始就讲我的做法，而是循序渐进的从传统的存储方式逐渐过渡到我的做法当中来。</p>
<h2 id="如何安全的传输用户-token"><a href="#如何安全的传输用户-token" class="headerlink" title="如何安全的传输用户 token"></a>如何安全的传输用户 token</h2><p>这是最传统也是最简单的方式了，前端登录，后端根据用户信息生成一个 token，并保存这个 token 和对应的用户 id，接着把 token 传给用户，存入浏览器 cookie，之后浏览器请求带上这个 cookie，后端根据这个 cookie 来标识用户。</p>
<img src="/2016/10/14/关于前后端分离鉴权的思考/flow-cookie-session.jpg" alt="flow-cookie-session" title="flow-cookie-session">
<p>但这样做问题就很多，如果我们的页面出现了 XSS 漏洞，由于 cookie 可以被 JavaScript 读取，XSS 漏洞会导致用户 token 泄露，而作为后端识别用户的标识，cookie 的泄露意味着用户信息不再安全。</p>
<p>尽管我们通过转义输出内容，使用 CDN 等可以尽量避免 XSS 注入，但谁也不能保证在大型的项目中不会出现这个问题。另外，后端每次都需要根据 token 查出用户 id，这就增加了数据库的查询和存储开销。</p>
<p>在设置 cookie 的时候，其实你还可以设置 httpOnly 以及 secure 项。设置 httpOnly 后 cookie 将不能被 JS 读取，浏览器会自动的把它加在请求的 header 当中，设置 secure 的话，cookie 就只允许通过 HTTPS 传输。</p>
<p>secure 选项可以过滤掉一些使用 HTTP 协议的 XSS 注入，但并不能完全阻止。</p>
<p>httpOnly 选项使得 JS 不能读取到 cookie，那么 XSS 注入的问题也基本不用担心了。但设置 httpOnly 就带来了另一个问题，就是很容易的被 XSRF，即跨站请求伪造。当你浏览器开着这个页面的时候，另一个页面可以很容易的跨站请求这个页面的内容。因为 cookie 默认被发了出去。</p>
<img src="/2016/10/14/关于前后端分离鉴权的思考/CSRF.jpg" alt="CSRF" title="CSRF">
<p>看起来我们不能兼顾。确实，光依靠这一个 token 我们没办法兼顾这两点。既然一个不够，那就两个。于是有了 XSRF-TOKEN，它和作为用户令牌的 token 类似，也是服务器生成的一个散列值。我们把 token 通过 httpOnly 发回去，把 XSRF-TOKEN 直接发回去。我们可以无视 httpOnly 的 cookie 因为我们没法操纵它，但对于这个 XSRF-TOKEN，我们就可以在我们网站的每个请求中都加入到 header 里面去。而服务端就需要检查这个 header 的 XSRF-TOKEN 是否真实有效。</p>
<p>由于 XSRF-TOKEN 以非 httpOnly 的形式存储在 cookie 中，正常情况下只有我们自己的网站可以获取到该 XSRF-TOKEN。这样 XSRF 攻击就变得不太可能了。另外由于用户 token 是通过 httpOnly 形式存储，JS 不可获取，这样也保证了用户 token 的安全。XSS 注入最多只能获取到 XSRF-TOKEN。</p>
<p>但还是有一种可能，XSS 注入取得 XSRF-TOKEN 后在当前页面发送请求出去。本文并不打算讨论 XSRF 和 XSS，明白这两个真正危害的地方就可以知道，这种 XSS 注入取得 XSRF-TOKEN 后发送请求其实并没有带来什么危害。不过呢，还是要看具体情况吧，如果我们的网站有一个投票 XXX 的接口，这个接口的链接被用在 XSS 注入中，那么当所有人打开这个页面的时候，都会自动的朝 XXX 投了一票。</p>
<p>不同于 XSRF， XSRF 可以从其他网站执行该段脚本，而这里只能注入到我们的网站中来执行。因为我们的 JS 也是这样子做的，取出 XSRF-TOKEN 放入请求头部然后发送请求出去，所以这就无法避免了。事实上，由于我们的前端代码都是公开的，无论 JS 层面绕多少个弯，XSS 注入还是可以照着做过来。但好在这种方式其实造成的影响相当有限，并不会比我们常说的 XSS 注入和 XSRF 攻击的危害大，要知道 XSS 注入危害的 cookie 的泄露，但其实这里并没有 cookie 的泄露。</p>
<p>我们再讨论另一个问题，前面也说了，服务器要经常去查询这个 token 对应的是哪一个用户。其实可不可以不要服务器去查询呢？如果我们生成 token 遵循一定的规律，比如我们使用对称加密算法来加密用户 id 形成 token，那么服务端以后其实只要解密该 token 就可以知道用户的 id 是什么了。不过呢，我只是举个例子而已，要是真这么做，只要你的对称加密算法泄露了，所有用户信息都不再安全了。恩，那用非对称加密算法来做呢，由公钥加密生成 token，私钥来解密 token，这样做就安全多了。其实现在有个规范就是这样做的，就是我们接下来要介绍的 JWT。</p>
<a id="more"></a>
<h2 id="Json-Web-Token"><a href="#Json-Web-Token" class="headerlink" title="Json Web Token"></a>Json Web Token</h2><p>接下来我们就简单介绍 JWT 这个东西，全称叫 Json Web Token。</p>
<h3 id="JWT-简介"><a href="#JWT-简介" class="headerlink" title="JWT 简介"></a>JWT 简介</h3><p>JWT 是一个开放标准(<a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="external">RFC 7519</a>)，它定义了一种用于简洁，自包含的用于通信双方之间以 JSON 对象的形式安全传递信息的方法。JWT 可以使用 HMAC 算法或者是 RSA 的公钥密钥对进行签名。它具备两个特点：</p>
<ul>
<li><p>简洁(Compact) </p>
<p>可以通过URL, POST 参数或者在 HTTP header 发送，因为数据量小，传输速度快</p>
</li>
<li><p>自包含(Self-contained)</p>
<p>负载中包含了所有用户所需要的信息，避免了多次查询数据库</p>
</li>
</ul>
<h3 id="JWT-组成"><a href="#JWT-组成" class="headerlink" title="JWT 组成"></a>JWT 组成</h3><p>JWT 由 Header, Payload, Signature 三部分组成，即头部，负载，签名，长这样：</p>
<img src="/2016/10/14/关于前后端分离鉴权的思考/jwt.jpeg" alt="jwt" title="jwt">
<ul>
<li><p>Header 头部</p>
<p>头部包含了两部分，token 类型和采用的加密算法</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</div><div class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它会使用 Base64Url 编码组成 JWT 结构的第一部分</p>
</li>
<li><p>Payload</p>
<p>这部分就是我们存放信息的地方了，你可以把用户 ID 等信息放在这里，JWT 规范里面对这部分有进行了比较详细的介绍，常用的由 iss（签发者），exp（过期时间），sub（面向的用户），aud（接收方），iat（签发时间）。这些我们应该规范的使用，因为他们可能是在校验中使用到了（猜测，表示我一个也没用到 =.= ）</p>
<p>例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</div><div class="line">  <span class="attr">"admin"</span>: <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样的，它会使用 Base64Url 编码组成 JWT 结构的第二部分</p>
</li>
<li><p>Signature</p>
<p>前面两部分都是使用 Base64Url 进行编码的，即客户端可以解开知道里面的信息。Signature 需要使用编码后的 header 和 payload 以及我们提供的一个密钥，然后使用 header 中指定的签名算法进行签名。签名的作用是保证 JWT 没有被篡改过。</p>
</li>
</ul>
<p>三个部分通过 <code>.</code> 连接在一起就是我们的 JWT 了，它可能长这个样子：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eyJhbGciOiJIUzI<span class="number">1</span><span class="symbol">NiIsInR5</span>cCI<span class="number">6</span>IkpX<span class="attr">VCJ9</span>.eyJpZCI<span class="number">6</span>IjU<span class="number">3</span>ZmVmMTY<span class="number">0</span>ZTU<span class="number">0</span>YWY<span class="number">2</span><span class="symbol">NGZmYzUzZGJkNSIsInhzcmYiOiI0</span>ZWE<span class="number">1</span>YzUwOGE<span class="number">2</span><span class="symbol">NTY2</span>ZTc<span class="number">2</span>MjQw<span class="symbol">NTQzZjhmZWIwNmZkNDU3</span><span class="symbol">Nzc3</span>YmUzOTU<span class="number">0</span>OW<span class="name">M0</span>MDE<span class="number">2</span><span class="symbol">NDM2</span>YWZkYTY<span class="number">1</span>ZDIzMzBlIiwiaWF<span class="number">0</span>Ijox<span class="symbol">NDc2</span><span class="symbol">NDI3</span>OTMzfQ.PA<span class="number">3</span>QjeyZSUh<span class="number">7</span>H<span class="number">0</span>GfE<span class="number">0</span>vJaKW<span class="number">4</span>LjKJuC<span class="number">3</span>dVLQiY<span class="number">4</span>hii<span class="number">8</span>s</div></pre></td></tr></table></figure>
<p>长度貌似和你的加密算法和私钥有关系。其实到这一步可能就有人会想了，HTTP 请求总会带上 token，这样这个 token 传来传去占用不必要的带宽啊。如果你这么想了，那你可以去了解下 HTTP2，HTTP2 对头部进行了压缩，相信也解决了这个问题。</p>
<h3 id="JWT-使用"><a href="#JWT-使用" class="headerlink" title="JWT 使用"></a>JWT 使用</h3><p>JWT 生成了，怎么使用就看你了，不过还是有一点要求的。当访问需要 JWT 验证的 API 时，需要把该 JWT 放入头部的 Authorization 中</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">Authorization:</span> Bearer <span class="params">&lt;token&gt;</span></div></pre></td></tr></table></figure>
<p>注意 <code>Bearer</code> 是必须的，中间有一个空格，后面跟着 JWT，这样服务端就可以从 Authorization 取出来用了。当然了，你也可以完全爱怎么来就怎么来。但是按照规范你可以省很多事情。</p>
<p>简单的 JWT 流程是这样的，不带 XSRF 的，没有找到带 XSRF 的图 =.=</p>
<img src="/2016/10/14/关于前后端分离鉴权的思考/tokens-new.png" alt="tokens-new" title="tokens-new">
<h2 id="JWT-实践"><a href="#JWT-实践" class="headerlink" title="JWT 实践"></a>JWT 实践</h2><p>刚才前面也说了，前端用的是 Angular，后端用的是 Koa，登录注册界面由 Koa 负责，由 Koa 根据用户是否登录来决定首页跳转。首先要强调下，下面说的不是唯一的方式，也不是最好的方式，而只是我自己这么用了并且我认为挺稳妥的。我在 Koa 中使用了两个模块，<a href="https://github.com/auth0/node-jsonwebtoken" target="_blank" rel="external">jsonwebtoken</a> 和 <a href="https://github.com/koajs/jwt/tree/koa-v2" target="_blank" rel="external">koa-jwt</a>。我以登录为例简单说下整个流程。</p>
<h3 id="登录，生成-JWT"><a href="#登录，生成-JWT" class="headerlink" title="登录，生成 JWT"></a>登录，生成 JWT</h3><p>在说登录的处理之前，我想先强调这个登录页面还是后端(ejs)来渲染的，而不是前端来渲染。这个其实也会影响到我们存储 token 的考虑。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">router.get([<span class="string">'/'</span>, <span class="string">'/login'</span>], <span class="keyword">async</span> (ctx, next) =&gt; &#123;</div><div class="line">    <span class="keyword">if</span>(ctx.cookies.get(<span class="string">'jwt'</span>)) &#123;</div><div class="line">        <span class="keyword">let</span> token = jwt.decode(ctx.cookies.get(<span class="string">'jwt'</span>));</div><div class="line">        <span class="keyword">if</span>(token.id) &#123;</div><div class="line">            <span class="keyword">let</span> result = <span class="keyword">await</span> UserModel.findById(token.id);</div><div class="line">            <span class="keyword">if</span>(result &amp;&amp; result._id) <span class="keyword">await</span> send(ctx, <span class="string">'./public/index.html'</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ctx.cookies.set(<span class="string">'jwt'</span>, <span class="literal">null</span>, &#123;overwrite: <span class="literal">true</span>, expires: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;);</div><div class="line">            ctx.render(<span class="string">'login.ejs'</span>, &#123;err: <span class="string">'JWT 验证失败'</span>&#125;);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">await</span> ctx.render(<span class="string">'login.ejs'</span>);  </div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当用户访问网站主页或者登录页面的时候，首先要先判断下是否已经有效登录了，如果是，那么跳转到 Angular 中去，否则跳转到登录页面。因为我想法是做一个主页，这个主页不需要加载太多类库，只是简单的展示页面和登录注册页面，用户登录或注册成功后在跳转到 Angular 的入口文件去。</p>
<p>接下来就是真正的登录接口了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">exports.login = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</div><div class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> UserModel.findOne(&#123;</div><div class="line">        email: ctx.request.body.email, </div><div class="line">        password: SHA256(ctx.request.body.password).toString()&#125;);</div><div class="line">    <span class="keyword">let</span> xsrf = SHA256(_.random(<span class="number">999999999</span>)).toString();</div><div class="line">    <span class="keyword">if</span>(result &amp;&amp; result._id) &#123;</div><div class="line">        <span class="keyword">let</span> token = jwt.sign(&#123;id: result._id, xsrf: xsrf&#125;, config.app.secretKey);</div><div class="line">        ctx.cookies.set(<span class="string">"XSRF-TOKEN"</span>, xsrf, &#123;httpOnly: <span class="literal">false</span>, overwrite: <span class="literal">true</span>, expires: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() + <span class="number">5184000000</span>)&#125;);</div><div class="line">        ctx.cookies.set(<span class="string">"jwt"</span>, token, &#123;httpOnly: <span class="literal">true</span>, overwrite: <span class="literal">true</span>, expires: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() + <span class="number">5184000000</span>)&#125;);</div><div class="line">        <span class="keyword">await</span> ctx.redirect(<span class="string">'/'</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">let</span> exist = <span class="keyword">await</span> UserModel.findOne(&#123;email: ctx.request.body.email&#125;);</div><div class="line">        <span class="keyword">if</span>(exist &amp;&amp; exist._id)  ctx.throw(<span class="number">401</span>, <span class="string">'密码错误'</span>);</div><div class="line">        <span class="keyword">else</span> ctx.throw(<span class="number">401</span>, <span class="string">'邮箱未注册'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>恩，熟悉 Node 的应该看懂没啥问题。这里有个变量 <code>xsrf</code> ，作用前面我们已经说了，还有变量 <code>token</code> 就是 JWT 了。然后我们把他设置到 cookie 中，注意 <code>xsrf</code> 不能设置 <code>httpOnly</code> 而 <code>token</code> 需要设置为 <code>httpOnly</code>，不要忘了把 <code>xsrf</code> 也放入 JWT 的 payload 部分中去，这里 payload 存储了用户 id 和当前的 <code>xsrf</code>。</p>
<h3 id="请求带上-XSRF"><a href="#请求带上-XSRF" class="headerlink" title="请求带上 XSRF"></a>请求带上 XSRF</h3><p>我们需要在以后的每个请求都带上 XSRF-TOKEN，具体操作就是把 cookie 中的 XSRF-TOKEN 取出来，放入请求的 X-XSRF-TOKEN 头部中，然后发送出去就好了。如果你用的是 Angular，其实你什么都不需要做了，因为这一步 Angular 已经帮你做好了，前提是你的 xsrf 必须放到 cookie 中的 XSRF-TOKEN 这个里面。如果你用的不是 Angular，那你就自己查下怎么做吧，这一步并不难做到。</p>
<h3 id="设置-header-和校验-XSRF"><a href="#设置-header-和校验-XSRF" class="headerlink" title="设置 header 和校验 XSRF"></a>设置 header 和校验 XSRF</h3><p>前面说了，我们需要把 JWT 放到请求的 <code>Authorization</code> 头部中，但是由于我们对 JWT 设置了 <code>httpOnly</code> ，所以这个操作几乎就不太可能了。但别忘了我们可以在服务端做这一步，与此同时我们也可以把校验 <code>XSRF</code> 也做了，这里先不需要校验 JWT。</p>
<p>如果熟悉 Koa 的话就清楚 Koa 的中间件思路。我们在较顶层的位置写入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// XSRF 检测，处理客户端未授权问题</span></div><div class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</div><div class="line">    <span class="keyword">let</span> token = ctx.cookies.get(<span class="string">'jwt'</span>), xsrf = ctx.request.headers[<span class="string">'x-xsrf-token'</span>];</div><div class="line">    ctx.request.header.authorization = <span class="string">'Bearer '</span> + token;</div><div class="line">    <span class="comment">// 当 JWT 存在且访问 API 时，检测 XSRF </span></div><div class="line">    <span class="keyword">if</span>(token !== <span class="keyword">void</span> <span class="number">0</span> &amp;&amp; <span class="regexp">/^\/api\//</span>.test(ctx.url)) &#123;;</div><div class="line">        <span class="keyword">let</span> verify = <span class="built_in">Promise</span>.promisify(jwt.verify);</div><div class="line">        <span class="keyword">await</span> verify(token, config.app.secretKey).then(<span class="keyword">async</span> (data) =&gt; &#123;</div><div class="line">            <span class="keyword">if</span>(xsrf !== data.xsrf) &#123;</div><div class="line">                ctx.cookies.set(<span class="string">"XSRF-TOKEN"</span>, <span class="literal">null</span>, &#123;overwrite: <span class="literal">true</span>, expires: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;);</div><div class="line">                ctx.cookies.set(<span class="string">"jwt"</span>, <span class="literal">null</span>, &#123;overwrite: <span class="literal">true</span>, expires: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;);</div><div class="line">                ctx.status = <span class="number">401</span>;</div><div class="line">                ctx.body =  &#123; success: <span class="literal">false</span>, message: <span class="string">'用户验证失败'</span>&#125;;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">await</span> next();</div><div class="line">            &#125;</div><div class="line">        &#125;, err =&gt; &#123;</div><div class="line">            ctx.cookies.set(<span class="string">"XSRF-TOKEN"</span>, <span class="literal">null</span>, &#123;overwrite: <span class="literal">true</span>, expires: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;);</div><div class="line">            ctx.cookies.set(<span class="string">"jwt"</span>, <span class="literal">null</span>, &#123;overwrite: <span class="literal">true</span>, expires: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;)</div><div class="line">            ctx.status = <span class="number">401</span>;</div><div class="line">            ctx.body = &#123; success: <span class="literal">false</span>, message: <span class="string">'用户验证失败'</span>&#125;;</div><div class="line">        &#125;);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">await</span> next();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>最前面几行就是设置 header，可以看到非常简单。if 语句进来就是检验 <code>XSRF</code> 了，我的逻辑是只有用户请求 API 的时候并且 JWT 存在的时候才做检测。我们后面有对 JWT 的检测所以这里不需要做，如果 JWT 不存在或者方位的不是 API 直接 next 就好了。</p>
<p>这里调用了 <code>jwt.verify</code> 方法取出了 payload 的内容，这个方法是 <code>jsonwebtoken</code> 这个模块提供的。</p>
<h3 id="检验-JWT"><a href="#检验-JWT" class="headerlink" title="检验 JWT"></a>检验 JWT</h3><p>有一点需要注意的是，有些资源我们允许用户无需登录就进行访问。例如我们前面的登录注册界面，还要像静态资源等等。使用 <code>koa-jwt</code> 可以很方便的做这件事情。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">app.use(handel.routes())</div><div class="line">   .use(handel.allowedMethods());</div><div class="line"></div><div class="line">app.use(jwt(&#123; secret: config.app.secretKey, algorithm: <span class="string">'RS256'</span> &#125;).unless(&#123; path: [<span class="regexp">/^\/css|js|img|fonts/</span>] &#125;));</div><div class="line"></div><div class="line">app.use(api.routes())</div><div class="line">   .use(api.allowedMethods());</div></pre></td></tr></table></figure>
<p><code>handel</code> 这个路由是我的登录注册页面和接口这些，而 <code>api</code> 就是 Angular 中需要用到的一系列接口。中间我们加入了一句话。这里的 <code>jwt</code> 是 <code>koa-jwt</code> 模块。</p>
<p>这些顺序不能乱，koa 中间件的加载是按自顶向下的顺序的，所以我们 <code>handel</code> 这里并不要 jwt 检测，而后面则需要。而我们前面说的 xsrf 检测和 header 处理自然是要放在更前的位置了。这里的 <code>path</code> 你可以根据需要修改。具体的用法参考文档就好了。</p>
<p>整个流程就完了，这个就实现了我们前面探讨的成果。既保护了 token 的安全，又防止了 XSRF 攻击。当然了我不敢说绝对安全，根本就没有绝对安全的东西。但目前这样的鉴权系统应该算马马虎虎了。</p>
<p>如果你的登录注册也是放在前端（比如由 Angular 来做），那你也可以像我上面说的这么做，或者可以把 jwt 作为登录请求的 response 返回，不过我不觉得这是一种安全的方式，关于其他的存储方式参考我后面给的链接吧，我就不多介绍了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实关于 JWT 存放到哪里一直由很多讨论，有人说存放到本地存储，有人说存 cookie。但我觉得上面我说的这种方式是挺稳妥的，如果你有什么意见和看法欢迎提出。参考资料也附出了比较热门的关于 jwt 存储位置的讨论文章，可以看下。</p>
<hr>
<p>参考资料：</p>
<ul>
<li><a href="https://jwt.io/introduction/" target="_blank" rel="external">jwt.io</a></li>
<li><a href="https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage" target="_blank" rel="external">Where to Store your JWTs – Cookies vs HTML5 Web Storage</a></li>
<li><a href="http://stackoverflow.com/questions/27067251/where-to-store-jwt-in-browser-how-to-protect-against-csrf" target="_blank" rel="external">Where to store JWT in browser? How to protect against CSRF?</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前后端分离项目的 Token 存储问题由来已久，有的人存 Cookie 有的人存 LocalStorage 或 SessionStorage，最近刚把 RSS 订阅器项目的鉴权问题做好，感觉算是目前比较稳妥安全的方案了，分享一下经验。&lt;/p&gt;
&lt;p&gt;前端用的是 Angular，后端用的是 Koa，登录注册界面由 Koa 负责，由 Koa 根据用户是否登录来决定首页跳转。我不会一开始就讲我的做法，而是循序渐进的从传统的存储方式逐渐过渡到我的做法当中来。&lt;/p&gt;
&lt;h2 id=&quot;如何安全的传输用户-token&quot;&gt;&lt;a href=&quot;#如何安全的传输用户-token&quot; class=&quot;headerlink&quot; title=&quot;如何安全的传输用户 token&quot;&gt;&lt;/a&gt;如何安全的传输用户 token&lt;/h2&gt;&lt;p&gt;这是最传统也是最简单的方式了，前端登录，后端根据用户信息生成一个 token，并保存这个 token 和对应的用户 id，接着把 token 传给用户，存入浏览器 cookie，之后浏览器请求带上这个 cookie，后端根据这个 cookie 来标识用户。&lt;/p&gt;
&lt;img src=&quot;/2016/10/14/关于前后端分离鉴权的思考/flow-cookie-session.jpg&quot; alt=&quot;flow-cookie-session&quot; title=&quot;flow-cookie-session&quot;&gt;
&lt;p&gt;但这样做问题就很多，如果我们的页面出现了 XSS 漏洞，由于 cookie 可以被 JavaScript 读取，XSS 漏洞会导致用户 token 泄露，而作为后端识别用户的标识，cookie 的泄露意味着用户信息不再安全。&lt;/p&gt;
&lt;p&gt;尽管我们通过转义输出内容，使用 CDN 等可以尽量避免 XSS 注入，但谁也不能保证在大型的项目中不会出现这个问题。另外，后端每次都需要根据 token 查出用户 id，这就增加了数据库的查询和存储开销。&lt;/p&gt;
&lt;p&gt;在设置 cookie 的时候，其实你还可以设置 httpOnly 以及 secure 项。设置 httpOnly 后 cookie 将不能被 JS 读取，浏览器会自动的把它加在请求的 header 当中，设置 secure 的话，cookie 就只允许通过 HTTPS 传输。&lt;/p&gt;
&lt;p&gt;secure 选项可以过滤掉一些使用 HTTP 协议的 XSS 注入，但并不能完全阻止。&lt;/p&gt;
&lt;p&gt;httpOnly 选项使得 JS 不能读取到 cookie，那么 XSS 注入的问题也基本不用担心了。但设置 httpOnly 就带来了另一个问题，就是很容易的被 XSRF，即跨站请求伪造。当你浏览器开着这个页面的时候，另一个页面可以很容易的跨站请求这个页面的内容。因为 cookie 默认被发了出去。&lt;/p&gt;
&lt;img src=&quot;/2016/10/14/关于前后端分离鉴权的思考/CSRF.jpg&quot; alt=&quot;CSRF&quot; title=&quot;CSRF&quot;&gt;
&lt;p&gt;看起来我们不能兼顾。确实，光依靠这一个 token 我们没办法兼顾这两点。既然一个不够，那就两个。于是有了 XSRF-TOKEN，它和作为用户令牌的 token 类似，也是服务器生成的一个散列值。我们把 token 通过 httpOnly 发回去，把 XSRF-TOKEN 直接发回去。我们可以无视 httpOnly 的 cookie 因为我们没法操纵它，但对于这个 XSRF-TOKEN，我们就可以在我们网站的每个请求中都加入到 header 里面去。而服务端就需要检查这个 header 的 XSRF-TOKEN 是否真实有效。&lt;/p&gt;
&lt;p&gt;由于 XSRF-TOKEN 以非 httpOnly 的形式存储在 cookie 中，正常情况下只有我们自己的网站可以获取到该 XSRF-TOKEN。这样 XSRF 攻击就变得不太可能了。另外由于用户 token 是通过 httpOnly 形式存储，JS 不可获取，这样也保证了用户 token 的安全。XSS 注入最多只能获取到 XSRF-TOKEN。&lt;/p&gt;
&lt;p&gt;但还是有一种可能，XSS 注入取得 XSRF-TOKEN 后在当前页面发送请求出去。本文并不打算讨论 XSRF 和 XSS，明白这两个真正危害的地方就可以知道，这种 XSS 注入取得 XSRF-TOKEN 后发送请求其实并没有带来什么危害。不过呢，还是要看具体情况吧，如果我们的网站有一个投票 XXX 的接口，这个接口的链接被用在 XSS 注入中，那么当所有人打开这个页面的时候，都会自动的朝 XXX 投了一票。&lt;/p&gt;
&lt;p&gt;不同于 XSRF， XSRF 可以从其他网站执行该段脚本，而这里只能注入到我们的网站中来执行。因为我们的 JS 也是这样子做的，取出 XSRF-TOKEN 放入请求头部然后发送请求出去，所以这就无法避免了。事实上，由于我们的前端代码都是公开的，无论 JS 层面绕多少个弯，XSS 注入还是可以照着做过来。但好在这种方式其实造成的影响相当有限，并不会比我们常说的 XSS 注入和 XSRF 攻击的危害大，要知道 XSS 注入危害的 cookie 的泄露，但其实这里并没有 cookie 的泄露。&lt;/p&gt;
&lt;p&gt;我们再讨论另一个问题，前面也说了，服务器要经常去查询这个 token 对应的是哪一个用户。其实可不可以不要服务器去查询呢？如果我们生成 token 遵循一定的规律，比如我们使用对称加密算法来加密用户 id 形成 token，那么服务端以后其实只要解密该 token 就可以知道用户的 id 是什么了。不过呢，我只是举个例子而已，要是真这么做，只要你的对称加密算法泄露了，所有用户信息都不再安全了。恩，那用非对称加密算法来做呢，由公钥加密生成 token，私钥来解密 token，这样做就安全多了。其实现在有个规范就是这样做的，就是我们接下来要介绍的 JWT。&lt;/p&gt;
    
    </summary>
    
      <category term="安全" scheme="https://ruiming.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Angular" scheme="https://ruiming.github.io/tags/Angular/"/>
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="JWT" scheme="https://ruiming.github.io/tags/JWT/"/>
    
      <category term="Koa" scheme="https://ruiming.github.io/tags/Koa/"/>
    
  </entry>
  
  <entry>
    <title>编译原理与PEG.js</title>
    <link href="https://ruiming.github.io/2016/10/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%8EPEG-js/"/>
    <id>https://ruiming.github.io/2016/10/07/编译原理与PEG-js/</id>
    <published>2016-10-07T08:54:32.000Z</published>
    <updated>2016-10-28T08:10:58.733Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><p>这学期开始上编译原理这门课，比较纳闷的一点是老师要求用 Java。作为一个想学好编译原理的 Java 黑，自然要寻找另一门可以进行实践的语言，编译在 JavaScript 中应用非常广泛，几乎所有主流的语言都可以编译到 JavaScript，Babel 编译 ES6 到 ES5，以及 CofferScript, TypeScript, JSX 等等编译为 JavaScript。另外，JavaScript 作为一门函数第一公民的语言，我想用来做编译也是特别方便的。一开始看了 Jison，感觉还是挺简单的，不过现在貌似流行 PEG.js，老实说我并不知道他们区别，我还只是一个初学者，或者初学者也算不上，因为最近一个月根本没好好听课 =.=</p>
<p>有几个重要的概念先罗列下：</p>
<ol>
<li><p>词法分析(Lexical analysis 或 Scanning)</p>
<p>词法分析是编译的第一个阶段，用于读入组成源程序的字符流，并把它们组织成为有意义的语素的序列</p>
</li>
<li><p>语法分析(Syntax analysis 或 Parsing)</p>
<p>语法分析使用词法分析器生成的各个词法单元的第一个分量来创建树形的中间表示(语法树)</p>
</li>
<li><p>语义分析(Syntax analysis)</p>
<p>使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致，同时也收集类型信息(类型检查)</p>
</li>
<li><p>Lex(Lexical Analyzar)</p>
<p>Lex 是一个产生词法分析器的程序，它输入描述构词规则的一系列正则表达式，然后构建有穷自动机和这个有穷自动机的一个驱动程序，进而生成一个词法分析程序</p>
</li>
<li><p>Yacc(Yet Another Compiler Compiler)</p>
<p>Yacc 是 Unix/Linux 上一个用来生成编译器的编译器，Yacc 的输入是巴科斯范式(BNF)表达的语法规则以及语法规约的处理代码(Lex 生成)。Lex 负责词法解析，Yacc 负责语法解析</p>
</li>
<li><p>Bison</p>
<p>Bison 是 Yacc 的一个GNU 执行/扩展</p>
</li>
<li><p>Flex</p>
<p>Flex 是 Lex 的继承者</p>
</li>
<li><p>其他</p>
<blockquote>
<p>Mysql 中的 sql 分析器只用了 Yacc 而没有使用 Lex，Go 的语法分析器也一样，只使用了 Bison 没有使用 Flex；而 PHP 则同时使用了 Flex 和 Bison。目前来看，应该是正则在效率上还是有些问题的，因此对于效率要求比较高的一些应用宁愿自己来写 Lex 功能而不会直接使用 Lex。</p>
</blockquote>
</li>
</ol>
<h1 id="解析表达式"><a href="#解析表达式" class="headerlink" title="解析表达式"></a>解析表达式</h1><p>在了解 PEG.js 之前有必要先了解下 <a href="https://zh.wikipedia.org/wiki/%E8%A7%A3%E6%9E%90%E8%A1%A8%E8%BE%BE%E6%96%87%E6%B3%95" target="_blank" rel="external">PEG</a>（解析表达文法），以及它与 CFG（上下文无关文法）的区别。以下摘选<a href="https://zh.wikipedia.org/wiki/%E8%A7%A3%E6%9E%90%E8%A1%A8%E8%BE%BE%E6%96%87%E6%B3%95" target="_blank" rel="external">维基百科</a>上面关于解析表达式的解释</p>
<blockquote>
<p>解析表达文法里面的每一个非终结符本质上表示递归下降解析器里面的一个解析<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0" target="_blank" rel="external">函数</a>，其对应的解析表达式展示了这个函数包含的代码内容。概念上，每一个解析函数接受一个输入字符串作为参数，返回以下其中一个结果:</p>
<ul>
<li>成功，函数可能向前移动或者“消耗”一个或多个输入字符串的字符</li>
<li>失败，不消耗任何字符</li>
</ul>
<p>一个<strong>非终结符</strong>有可能成功但是不消耗任何输入字符，这也是一种不同于失败的结果。</p>
<p>只由一个<strong>终结符</strong>组成的原子解析表达式：成功，如果输入字符串的第一个字符就是定义中的终结符，这种情况下消耗这个输入字符；否之失败。由空字符串组成的原子解析表达式总是成功并且不消耗任何输入。只由一个非终结符A组成的原子解析表达式表示对非终结符A的解析函数的<a href="https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92" target="_blank" rel="external">递归</a>调用。</p>
<p><strong>序列</strong>操作符 <em>e</em>1<em>e</em>2 首先调用 <em>e</em>1， 如果 <em>e</em>1成功， 接着对 <em>e</em>1 消耗剩下的输入字符串调用 <em>e</em>2， 最后返回结果。如果 <em>e</em>1 或者 <em>e</em>2 失败，那么序列表达式 <em>e</em>1<em>e</em>2 失败。</p>
<p><strong>选择</strong>操作符 <em>e</em>1 / <em>e</em>2 首先调用 <em>e</em>1， 如果 <em>e</em>1成功， 立刻返回结果。否则如果 <em>e</em>1 失败，选择操作符<a href="https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BA%AF" target="_blank" rel="external">回溯</a>到输入字符串匹配 <em>e</em>1 的原始位置，调用 <em>e</em>2， 最后返回 <em>e</em>2 结果。</p>
<p><strong>零个或多个</strong>，<strong>一个或多个</strong>，和<strong>可选</strong>操作符分别消耗零个或多个，一个或多个，或者零个或一个连续重复的子表达式e。与上下文无关文法和正则表达式不同的 是，尽管如此，在PEG里这些操作符总是执行贪婪的行为，那就是消耗尽可能多的输入，而且绝对不回溯。（正则表达式一开始执行贪婪匹配，但是如果整个正则表达式失败后，会回退并尝试短一些的匹配。）例如，解析表达式a<em>总是尽可能多的消耗输入字符串中连续出现的a，解析表达式(a</em> a)则必然会失败因为前半部分a*绝对不会留下一丁点a给后半部分去匹配。</p>
<p>最后，肯定断言和否定断言实现了句法断言。&amp;e 表达式调用子表达式e，如果e成功，则返回成功；否则返回失败。无论结果如何都不消耗任何字符。反之，当e失败时！e 表达式成功，e成功时！e 表达式失败， 同样无论结果如何都不消耗任何字符。因为向前判断的子表达式e 可以任意的复杂，所以断言表达式提供了强大的句法向前判断和去除二义性的能力。</p>
</blockquote>
<h1 id="PEG-js"><a href="#PEG-js" class="headerlink" title="PEG.js"></a>PEG.js</h1><p><em>本着从没有翻译过技术文档和觉得翻译一下应该对文档会更加深入了解的想法来翻译，译文可能存在大量错误和不流畅的地方，建议自己阅读官方文档，本译文仅供参考，欢迎对错误指正。以下翻译：</em></p>
<p>PEG.js 是一个基于 JavaScript 的简单的解析器生成器，它用来生成一个快速且具备完善错误报告的解析器。你可以用它来处理复杂的数据或计算机语言，已经轻松的构造变换器，解释器，编译器以及其他的工具。</p>
<a id="more"></a>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>简单和具有表现力的语法符号</li>
<li>集成了词法分析( lexcial )和语义分析( syntactical )</li>
<li>具备优良的错误报告</li>
<li>基于解析表达式语法的形式，比传统的 LL(k) 和 LR(k) 解析器更强大</li>
<li>可以用于浏览器，命令行，或者通过 JavaScript 的 API</li>
</ul>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p><a href="http://pegjs.org/online" target="_blank" rel="external">在线版本</a> 是生成一个解析器最简单的方式，只要输入你定义的语法，尝试解析少量的输入，下载生成的解析后的代码。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>如果要使用 <code>pegj</code> 命令，全局安装 PEG.js</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g pegjs</div></pre></td></tr></table></figure>
<p>如果要使用 JavaScript 的 API，本地安装 PEG.js</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install pegjs</div></pre></td></tr></table></figure>
<p>如果你两者都需要，那么两种方式都安装即可</p>
<h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p><a href="http://pegjs.org/#download" target="_blank" rel="external">下载</a> PEG.js 库(普通或者压缩的版本) 或者通过 Bower 安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bower install pegjs</div></pre></td></tr></table></figure>
<h2 id="生成一个解析器"><a href="#生成一个解析器" class="headerlink" title="生成一个解析器"></a>生成一个解析器</h2><p>PEG.js 根据一个你希望解析的输入的语法以及你指定的返回结果(对匹配的进行语义分析)生成解析器。最后生成解析器本质上只是一个带有一些简单 API 的 JavaScript 对象。</p>
<h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p>想要根据你的语法生成一个解析器，使用 <code>pegjs</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pegjs arithmetics.pegjs</div></pre></td></tr></table></figure>
<p>这将会把解析器代码写入一个以 ‘.js’ 为扩展名的相同文件名文件中， 你也可以自己指定输出：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">pegjs</span> <span class="selector-tag">-o</span> <span class="selector-tag">arithmetics-parser</span><span class="selector-class">.js</span> <span class="selector-tag">arithmetics</span><span class="selector-class">.pegjs</span></div></pre></td></tr></table></figure>
<p>如果你省略了输入和输出文件，那么将会使用标准的输入输出</p>
<p>默认下，解析器的生成采用了 Node.js 的模块格式，你可以使用 <code>--format</code> 选项来覆盖。</p>
<p>你可以调整一下几个选项：</p>
<ul>
<li><code>--allowed-start-rules</code> – 逗号相隔的会被用来解析的规则（默认为第一个规则）</li>
<li><code>--cache</code> – 让解析器缓存结果，避免在极端情况下出现了指数级的解析时间而降低解析器速度</li>
<li><code>--dependency</code> – 给解析器指定依赖（可以多次指定）</li>
<li><code>--export-var</code> – 指定一个全局变量名称，当没有进行模块到处时，解析器对象会以该名称命名</li>
<li><code>--extra-options</code> – 其他的传递给 <code>peg.generate</code> 的选项（JSON 格式）</li>
<li><code>--extra-options-file</code> – 同上，只不过选项保存在文件里面</li>
<li><code>--format</code> – 指定解析器的到导出格式，如 <code>amd</code>， <code>commonjs</code>，<code>globals</code>，<code>umd</code>（默认: <code>commonjs</code>）</li>
<li><code>--optimize</code> – 在优化解析速度（<code>speed</code>）和代码大小（<code>size</code>）之间进行选择（默认：<code>speed</code>）</li>
<li><code>--plugin</code> – 让 PEG.js 使用一个指定的插件（可以多次指定）</li>
<li><code>--trace</code> – 让解析器跟踪其运行情况</li>
</ul>
<h3 id="JavaScript-API"><a href="#JavaScript-API" class="headerlink" title="JavaScript API"></a>JavaScript API</h3><p>在 Node.js 中，需要引入 PEG.js 这个模块</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> peg = <span class="built_in">require</span>(<span class="string">'pegjs'</span>);</div></pre></td></tr></table></figure>
<p>在浏览器中，通过 <code>&lt;script&gt;</code> 标签引入 PEG.js 库到你的网页中。如果 PEG.js 使用 AMD 模块化方案，它会把模块定义在一个变量上面，否则他的 API 将会挂载在全局对象 <code>peg</code> 中</p>
<p>为了生成一个解析器，调用 <code>peg.generate</code> 方法并把你的语法作为参数传递进去</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> parser = peg.generate(<span class="string">"start = ('a'/'b')+"</span>);</div></pre></td></tr></table></figure>
<p>这个方法会返回解析器对象或者返回源码（取决于你的 <code>output</code> 参数 – 参见下文）。如果语法非法它将抛出错误，错误会包含 <code>message</code> 属性，它携带更详细的错误信息</p>
<p>你可以传入以下选项组成的对象作为 <code>peg.generate</code> 的第二个参数，以下选项是受支持的：</p>
<ul>
<li><code>allowedStartRules</code> – 指定解析器从哪个规则开始解析（默认：语法中的第一个规则）</li>
<li><code>cache</code> – 如果为 <code>true</code>，解析器会缓存结果以避免指数级的解析时间影响解析器效率（默认：<code>false</code>）</li>
<li><code>dependencies</code> – 解析需要的依赖，它的值为一个变量与依赖模块映射的对象。解析器通过这些变量来使用那些模块。只有当 <code>format</code> 被设置为 <code>amd</code>，<code>commonjs</code> 或者 <code>umd</code> （默认：<code>{}</code>）时才有效。</li>
<li><code>exportVar</code> – 一个全局对象名，当没有进行模块导出时，解析器对象会以该名称命名</li>
<li><code>format</code> – 生成的解析器的导出格式（”amd”，”bare”，”commonjs”，”globals”，”umd”），只有当 <code>output</code> 设置为 <code>source</code> 时（默认：<code>null</code>）才有效</li>
<li><code>optimize</code> – 在优化解析速度（<code>speed</code>）和代码大小（<code>size</code>）之间进行选择（默认：<code>speed</code>）</li>
<li><code>output</code> – 如果设置为 <code>parser</code>，这个方法将返回解析器对象；如果设置为 <code>source</code>，它会以字符串的形式返回生成的解析器的源码（默认：<code>parser</code>）</li>
<li><code>plugin</code> – 让 PEG.js 使用一个指定的插件（可以多次指定）</li>
<li><code>trace</code> – 让解析器跟踪其运行情况</li>
</ul>
<h2 id="使用解析器"><a href="#使用解析器" class="headerlink" title="使用解析器"></a>使用解析器</h2><p>使用生成的解析器的方法十分简单，只要调用它的 <code>parse</code> 方法并把参数作为一个字符串传入即可。该方法会返回解析的结果（确切的值取决于你的生成该解析器的语法）或者抛出错误（如果你的输入非法）。抛出的错误信息带有 <code>location</code>，<code>expected</code>，<code>found</code> 以及包含更多错误信息的 <code>message</code> </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">parser.parse(<span class="string">"abba"</span>);		<span class="comment">// returns ["a", "b", "b", "a"]</span></div><div class="line">parser.parse(<span class="string">"abcd"</span>);		<span class="comment">// throws an exception</span></div></pre></td></tr></table></figure>
<p>你还可以通过传入第二个参数来调整解析行为，该参数是一个支持以下可选项的对象：</p>
<ul>
<li><code>startRule</code> – 从这个规则开始解析</li>
<li><code>tracer</code> – 追踪解析行为</li>
</ul>
<p>解析器也支持你自定义的选项</p>
<h2 id="句法和语义"><a href="#句法和语义" class="headerlink" title="句法和语义"></a>句法和语义</h2><p>PEG.js 的句法不是面向行的，并且会忽略标记（token）之间的空白，这一点和 JavaScript 相似。你也可以使用 JavaScript 风格的注释（<code>//...</code> 和 <code>/*...*/</code>）</p>
<p>让我们看一个简单的可以识别形如 <code>2*(3+4)</code> 这样的表达式的语法。根据这个语法生成的解析器可以计算该表达式的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">start</div><div class="line">  = additive</div><div class="line"></div><div class="line">additive</div><div class="line">  = left:multiplicative <span class="string">"+"</span> right:additive &#123; <span class="keyword">return</span> left + right; &#125;</div><div class="line">  / multiplicative</div><div class="line"></div><div class="line">multiplicative</div><div class="line">  = left:primary <span class="string">"*"</span> right:multiplicative &#123; <span class="keyword">return</span> left * right; &#125;</div><div class="line">  / primary</div><div class="line"></div><div class="line">primary</div><div class="line">  = integer</div><div class="line">  / <span class="string">"("</span> additive:additive <span class="string">")"</span> &#123; <span class="keyword">return</span> additive; &#125;</div><div class="line"></div><div class="line">integer <span class="string">"integer"</span></div><div class="line">  = digits:[<span class="number">0</span><span class="number">-9</span>]+ &#123; <span class="keyword">return</span> <span class="built_in">parseInt</span>(digits.join(<span class="string">""</span>), <span class="number">10</span>); &#125;</div></pre></td></tr></table></figure>
<p>在顶层，语法包含了规则（在我们的例子中，有五条规则）。每条规则都由一个名字（例如 <code>integer</code>）来区分它们，并且还有一个解析表达式（例如 <code>digits:[0-9]+ { return parseInt(digits.join(&quot;&quot;), 10); }</code>）来定义一个对输入文本的匹配，你还可以在其中包含你的 JavaScript 代码来处理被成功匹配到的文本。规则可以包含别名以便于错误提示（例如上面的例子中，只有 <code>integer</code> 规则具有别名）。解析将从第一条规则，这条规则也叫作 <em>start rule</em></p>
<p>一个规则名必须是一个 JavaScript 标识符，它后面跟着一个 <code>=</code> 和解析表达式。如果这个规则名有一个别名，它作为一个 JavaScript 字符串书写在规则名和 <code>=</code> 之间。规则之间需要用空格分割开，但在解析表达式后面跟着 <code>;</code> 也是可以的。</p>
<p>你可以在第一个规则前初始化一些用 <code>{}</code> 闭合的 JavaScript 代码。这些代码会在解析器开始解析之前先执行。在初始化操作中定义的变量名和函数可以在规则操作和语义谓词中直接使用，同时他们也可以直接访问通过 <code>options</code> 传递进来的对象。初始化过程中括号必须严格闭合。比如我们来看一个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">makeInteger</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(o.join(<span class="string">""</span>), <span class="number">10</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">start</div><div class="line">  = additive</div><div class="line"></div><div class="line">additive</div><div class="line">  = left:multiplicative <span class="string">"+"</span> right:additive &#123; <span class="keyword">return</span> left + right; &#125;</div><div class="line">  / multiplicative</div><div class="line"></div><div class="line">multiplicative</div><div class="line">  = left:primary <span class="string">"*"</span> right:multiplicative &#123; <span class="keyword">return</span> left * right; &#125;</div><div class="line">  / primary</div><div class="line"></div><div class="line">primary</div><div class="line">  = integer</div><div class="line">  / <span class="string">"("</span> additive:additive <span class="string">")"</span> &#123; <span class="keyword">return</span> additive; &#125;</div><div class="line"></div><div class="line">integer <span class="string">"integer"</span></div><div class="line">  = digits:[<span class="number">0</span><span class="number">-9</span>]+ &#123; <span class="keyword">return</span> makeInteger(digits); &#125;</div></pre></td></tr></table></figure>
<p>规则的解析表达式用来匹配输入的文本。这里由好几种类型的表达式 – 匹配字符或字符类，显示可选部分和重复等等。表达式中也可以包含其他规则的引用。详细介绍见下文。</p>
<p>如果一个表达式成功的匹配到了一个输入流的部分文本，它会产生一个匹配结果，这是一个 JavaScript 值。例如：</p>
<ul>
<li>一个匹配字符串的表达式生成一个包含被匹配串的 JavaScript 字符串</li>
<li>一个匹配包含子表达式的字符串的表达式生成一个含有全部被匹配项的 JavaScript 数组</li>
</ul>
<p>当在表达式中使用规则名时，它将递归的解析下去并最终返回全部解析完成的结果</p>
<p>一个特殊的情况是解析表达式是一个解析行为 – 一段 JavaScript 代码包含在 <code>{}</code> 里面。它会处理匹配到的文本串并返回处理的结果，这个值是也被认为是表达式匹配的结果（换句话说，解析行为是对被匹配文本的一个变换器）</p>
<p>在我们的算术例子中由几个解析行为。比如这个表达式 <code>digits:[0-9] + { return parseInt(digits.join(&quot;&quot;), 10); }</code>，它处理 [0-9]+ 匹配的结果，这个结果是一个包含匹配的数字字符串组成的数组，它作为参数传入到该后面的行为被拼接成为一个 JavaScript <code>number</code> 对象后返回</p>
<h2 id="解析表达式类型"><a href="#解析表达式类型" class="headerlink" title="解析表达式类型"></a>解析表达式类型</h2><p>解析表达式有好几种类型，他们当中可能有些还包含子表达式从而形成一个递归结构</p>
<p>“<em>literal</em>“</p>
<p>‘<em>literal</em>‘</p>
<p>解析表达式会精确匹配字符串并返回，该字符串的句法和 JavaScript 一样。在字符串后面追加 <code>i</code> 使得匹配区分大小写</p>
<p><em>.</em></p>
<p>匹配一个字符并作为一个字符串返回</p>
<p><em>[characters]</em></p>
<p>从一个集合中匹配一个字符并作为一个字符串返回。集合中的字符可以以和 JavaScript 字符串相同的方式进行转义处理。集合中的字符也可以包含范围（例如 [a-z] 表示匹配一个小写字母）。在字符前面加上 <code>^</code> 表示取反（例如：<code>[^a-z]</code> 表示匹配一个非小写字母）。在右括号后面添加 <code>i</code> 可以让匹配区分大小写</p>
<p><em>rule</em></p>
<p>递归的匹配一个解析表达式规则并返回匹配的结果</p>
<p><em>( expression )</em></p>
<p>匹配一个子表达式并返回匹配的结果</p>
<p><em>expression *</em></p>
<p>匹配表达式零次或多次并以数组的形式返回匹配结果。这个匹配是贪婪匹配，即解析器会尽可能的进行多次匹配。不像正则表达式，解析表达式没有回溯</p>
<p><em>expression +</em></p>
<p>匹配表达式一次或多次并以数组的形式返回匹配结果。这个匹配是贪婪匹配，即解析器会尽可能的进行多次匹配。不像正则表达式，解析表达式没有回溯</p>
<p><em>expression ?</em></p>
<p>尝试匹配表达式，如果匹配成功，返回匹配的结果，否则返回 <code>null</code>。不像正则表达式，解析表达式没有回溯</p>
<p><em>&amp; expression</em></p>
<p>尝试匹配表达式，如果匹配成功，只返回 <code>undefined</code> 并且不消耗任何输入，否则认为匹配是失败的</p>
<p><em>! expression</em></p>
<p>尝试匹配表达式，如果匹配不成功，只返回 <code>undefined</code> 并且不消耗任何输入，否则认为匹配是失败的</p>
<p><code>&amp; { predicate }</code></p>
<p><code>predicate</code> 是一段 JavaScript 代码，可以理解为是它是在一个函数里面等待执行。它会把前面表达式匹配得到的结果作为它的参数。它通过 <code>return</code> 来返回 JavaScript 值。If the returned value evaluates to <code>true</code> in boolean context，返回 <code>undefined</code> 并且不消耗任何输入，否则认为匹配是失败的</p>
<p>在 <code>predicate</code> 中的代码可以访问初始化时定义的变量和方法</p>
<p>在 <code>predicate</code> 中的代码可以通过调用 <code>location</code> 函数来访问当前位置信息，它会返回一个像下面这样的对象：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  start: &#123; offset: 23, line: 5, column: 6 &#125;,</div><div class="line">  end: &#123; offset: 23, line: 5, colume: 6&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>start</code> 和 <code>end</code> 都指向当前解析的位置，<code>offset</code> 为一个从 0 开始的偏移值，<code>line</code> 和 <code>column</code> 为从 1 开始的行号和列号</p>
<p>在 <code>pedicate</code> 中的代码可以通过 <code>options</code> 变量来访问解析器被调用时传递进来的选项对象</p>
<p>注意括号必须严格闭合</p>
<p><em>! { predicate }</em></p>
<p><code>predicate</code> 是一段 JavaScript 代码，可以理解为是它是在一个函数里面等待执行。它会把前面表达式匹配得到的结果作为它的参数。它通过 <code>return</code> 来返回 JavaScript 值。If the returned value evaluates to <code>false</code> in boolean context，返回 <code>undefined</code> 并且不消耗任何输入，否则认为匹配是失败的</p>
<p>在 <code>predicate</code> 中的代码可以访问初始化时定义的变量和方法</p>
<p>在 <code>predicate</code> 中的代码可以通过调用 <code>location</code> 函数来访问当前位置信息，它会返回一个像下面这样的对象：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  start: &#123; offset: 23, line: 5, column: 6 &#125;,</div><div class="line">  end: &#123; offset: 23, line: 5, colume: 6&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>start</code> 和 <code>end</code> 都指向当前解析的位置，<code>offset</code> 为一个从 0 开始的偏移值，<code>line</code> 和 <code>column</code> 为从 1 开始的行号和列号</p>
<p>在 <code>pedicate</code> 中的代码可以通过 <code>options</code> 变量来访问解析器被调用时传递进来的选项对象</p>
<p>注意括号必须严格闭合</p>
<p><em>$ expression</em></p>
<p>尝试匹配表达式，如果匹配成功，返回匹配的文本而不是匹配的结果</p>
<p><em>label: expression</em></p>
<p>匹配表达式并使用 <code>label</code> 来保存匹配结果，<code>label</code> 必须是一个 JavaScript 符号</p>
<p>符号表达式通常和解析行为一起使用，表达式匹配结果保存在符号中，解析行为通过符号来访问匹配结果</p>
<p><em>expression_1</em> <em>expression_2</em> … <em>expression_n</em></p>
<p>匹配一连串表达式并把匹配结果作为一个数组返回</p>
<p><em>expression { action }</em></p>
<p>匹配表达式，如果匹配成功，则执行表达式，否则认为匹配是失败的</p>
<p><code>action</code> 是一段 JavaScript 代码，可以理解为是它是在一个函数里面等待执行。它会把前面表达式匹配得到的结果作为它的参数。它通过 <code>return</code> 来返回 JavaScript 值。返回值是匹配的结果。</p>
<p>为了便于查错，<code>action</code> 里面可以调用 <code>expected</code> 函数来让解析器抛出一个错误。这个函数有两个参数，一个描述当前位置预期的结果和可选的当前位置的信息（默认为 <code>location</code> 函数调用返回的结果 – 见下文）。这个描述会作为抛出错误信息的一部分</p>
<p><code>action</code> 里面也可以调用 <code>error</code> 函数，同样也会让编译器抛出错误。这个函数也由两个参数 – 错误信息和可选的位置信息（默认为 <code>location</code> 函数调用返回的结果 – 见下文）。错误信息将被抛出的错误所使用</p>
<p><code>action</code> 里面的代码也可以访问语法初始化时的定义的变量和方法。注意必须严格括号闭合</p>
<p><code>action</code> 里面的代码也可以通过 <code>text</code> 函数来访问前面表达式匹配的字符串</p>
<p><code>action</code> 里面的代码也可以通过调用 <code>location</code> 函数来访问当前位置信息，它会返回一个像下面这样的对象：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  start: &#123; offset: 23, line: 5, column: 6 &#125;,</div><div class="line">  end: &#123; offset: 25, line: 5, colume: 8&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>start</code> 执行表达式开始的位置，而 <code>end</code> 指向表达式结束的位置。<code>offset</code> 是从 0 开始的偏移值，<code>line</code> 和 <code>column</code> 是从 1 开始的行数和列数</p>
<p><code>action</code> 里面的代码可以通过 <code>options</code> 变量来访问解析器被调用时传递进来的选项对象</p>
<p>注意括号必须严格闭合</p>
<p><em>expression_1 / expression_2 / … / expression_n</em></p>
<p>尝试匹配第一个表达式，如果没有匹配到，则尝试第二个，以此类推。最后返回第一个匹配成功的表达式匹配的结果。如果没有成功匹配的表达式，则认为匹配失败。</p>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>解析器生成器和生成的解析器都可以在以下环境中运行：</p>
<ul>
<li>Node.js 4+</li>
<li>Internet Explorer 8+</li>
<li>Edge</li>
<li>Firefox</li>
<li>Chrome</li>
<li>Safari</li>
<li>Opera</li>
</ul>
<h2 id="Development"><a href="#Development" class="headerlink" title="Development"></a>Development</h2><ul>
<li><a href="http://pegjs.org/" target="_blank" rel="external">Project website</a></li>
<li><a href="https://github.com/pegjs/pegjs/wiki" target="_blank" rel="external">Wiki</a></li>
<li><a href="https://github.com/pegjs/pegjs" target="_blank" rel="external">Source code</a></li>
<li><a href="https://github.com/pegjs/pegjs/issues" target="_blank" rel="external">Issue tracker</a></li>
<li><a href="http://groups.google.com/group/pegjs" target="_blank" rel="external">Google Group</a></li>
<li><a href="http://twitter.com/peg_js" target="_blank" rel="external">Twitter</a></li>
</ul>
<p>PEG.js is developed by <a href="http://majda.cz/" target="_blank" rel="external">David Majda</a> (<a href="http://twitter.com/dmajda" target="_blank" rel="external">@dmajda</a>). The <a href="https://github.com/pegjs/bower" target="_blank" rel="external">Bower package</a> is maintained by <a href="http://www.michel-kraemer.com/" target="_blank" rel="external">Michel Krämer</a> (<a href="https://twitter.com/michelkraemer" target="_blank" rel="external">@michelkraemer</a>).</p>
<p>You are welcome to contribute code. Unless your contribution is really trivial you should get in touch with me first — this can prevent wasted effort on both sides. You can send code both as a patch or a GitHub pull request.</p>
<p>Note that PEG.js is still very much work in progress. There are no compatibility guarantees until version 1.0.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;编译原理&quot;&gt;&lt;a href=&quot;#编译原理&quot; class=&quot;headerlink&quot; title=&quot;编译原理&quot;&gt;&lt;/a&gt;编译原理&lt;/h1&gt;&lt;p&gt;这学期开始上编译原理这门课，比较纳闷的一点是老师要求用 Java。作为一个想学好编译原理的 Java 黑，自然要寻找另一门可以进行实践的语言，编译在 JavaScript 中应用非常广泛，几乎所有主流的语言都可以编译到 JavaScript，Babel 编译 ES6 到 ES5，以及 CofferScript, TypeScript, JSX 等等编译为 JavaScript。另外，JavaScript 作为一门函数第一公民的语言，我想用来做编译也是特别方便的。一开始看了 Jison，感觉还是挺简单的，不过现在貌似流行 PEG.js，老实说我并不知道他们区别，我还只是一个初学者，或者初学者也算不上，因为最近一个月根本没好好听课 =.=&lt;/p&gt;
&lt;p&gt;有几个重要的概念先罗列下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;词法分析(Lexical analysis 或 Scanning)&lt;/p&gt;
&lt;p&gt;词法分析是编译的第一个阶段，用于读入组成源程序的字符流，并把它们组织成为有意义的语素的序列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;语法分析(Syntax analysis 或 Parsing)&lt;/p&gt;
&lt;p&gt;语法分析使用词法分析器生成的各个词法单元的第一个分量来创建树形的中间表示(语法树)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;语义分析(Syntax analysis)&lt;/p&gt;
&lt;p&gt;使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致，同时也收集类型信息(类型检查)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Lex(Lexical Analyzar)&lt;/p&gt;
&lt;p&gt;Lex 是一个产生词法分析器的程序，它输入描述构词规则的一系列正则表达式，然后构建有穷自动机和这个有穷自动机的一个驱动程序，进而生成一个词法分析程序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Yacc(Yet Another Compiler Compiler)&lt;/p&gt;
&lt;p&gt;Yacc 是 Unix/Linux 上一个用来生成编译器的编译器，Yacc 的输入是巴科斯范式(BNF)表达的语法规则以及语法规约的处理代码(Lex 生成)。Lex 负责词法解析，Yacc 负责语法解析&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Bison&lt;/p&gt;
&lt;p&gt;Bison 是 Yacc 的一个GNU 执行/扩展&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Flex&lt;/p&gt;
&lt;p&gt;Flex 是 Lex 的继承者&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其他&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Mysql 中的 sql 分析器只用了 Yacc 而没有使用 Lex，Go 的语法分析器也一样，只使用了 Bison 没有使用 Flex；而 PHP 则同时使用了 Flex 和 Bison。目前来看，应该是正则在效率上还是有些问题的，因此对于效率要求比较高的一些应用宁愿自己来写 Lex 功能而不会直接使用 Lex。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;解析表达式&quot;&gt;&lt;a href=&quot;#解析表达式&quot; class=&quot;headerlink&quot; title=&quot;解析表达式&quot;&gt;&lt;/a&gt;解析表达式&lt;/h1&gt;&lt;p&gt;在了解 PEG.js 之前有必要先了解下 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%A7%A3%E6%9E%90%E8%A1%A8%E8%BE%BE%E6%96%87%E6%B3%95&quot;&gt;PEG&lt;/a&gt;（解析表达文法），以及它与 CFG（上下文无关文法）的区别。以下摘选&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%A7%A3%E6%9E%90%E8%A1%A8%E8%BE%BE%E6%96%87%E6%B3%95&quot;&gt;维基百科&lt;/a&gt;上面关于解析表达式的解释&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;解析表达文法里面的每一个非终结符本质上表示递归下降解析器里面的一个解析&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0&quot;&gt;函数&lt;/a&gt;，其对应的解析表达式展示了这个函数包含的代码内容。概念上，每一个解析函数接受一个输入字符串作为参数，返回以下其中一个结果:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;成功，函数可能向前移动或者“消耗”一个或多个输入字符串的字符&lt;/li&gt;
&lt;li&gt;失败，不消耗任何字符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个&lt;strong&gt;非终结符&lt;/strong&gt;有可能成功但是不消耗任何输入字符，这也是一种不同于失败的结果。&lt;/p&gt;
&lt;p&gt;只由一个&lt;strong&gt;终结符&lt;/strong&gt;组成的原子解析表达式：成功，如果输入字符串的第一个字符就是定义中的终结符，这种情况下消耗这个输入字符；否之失败。由空字符串组成的原子解析表达式总是成功并且不消耗任何输入。只由一个非终结符A组成的原子解析表达式表示对非终结符A的解析函数的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92&quot;&gt;递归&lt;/a&gt;调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;序列&lt;/strong&gt;操作符 &lt;em&gt;e&lt;/em&gt;1&lt;em&gt;e&lt;/em&gt;2 首先调用 &lt;em&gt;e&lt;/em&gt;1， 如果 &lt;em&gt;e&lt;/em&gt;1成功， 接着对 &lt;em&gt;e&lt;/em&gt;1 消耗剩下的输入字符串调用 &lt;em&gt;e&lt;/em&gt;2， 最后返回结果。如果 &lt;em&gt;e&lt;/em&gt;1 或者 &lt;em&gt;e&lt;/em&gt;2 失败，那么序列表达式 &lt;em&gt;e&lt;/em&gt;1&lt;em&gt;e&lt;/em&gt;2 失败。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;选择&lt;/strong&gt;操作符 &lt;em&gt;e&lt;/em&gt;1 / &lt;em&gt;e&lt;/em&gt;2 首先调用 &lt;em&gt;e&lt;/em&gt;1， 如果 &lt;em&gt;e&lt;/em&gt;1成功， 立刻返回结果。否则如果 &lt;em&gt;e&lt;/em&gt;1 失败，选择操作符&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BA%AF&quot;&gt;回溯&lt;/a&gt;到输入字符串匹配 &lt;em&gt;e&lt;/em&gt;1 的原始位置，调用 &lt;em&gt;e&lt;/em&gt;2， 最后返回 &lt;em&gt;e&lt;/em&gt;2 结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;零个或多个&lt;/strong&gt;，&lt;strong&gt;一个或多个&lt;/strong&gt;，和&lt;strong&gt;可选&lt;/strong&gt;操作符分别消耗零个或多个，一个或多个，或者零个或一个连续重复的子表达式e。与上下文无关文法和正则表达式不同的 是，尽管如此，在PEG里这些操作符总是执行贪婪的行为，那就是消耗尽可能多的输入，而且绝对不回溯。（正则表达式一开始执行贪婪匹配，但是如果整个正则表达式失败后，会回退并尝试短一些的匹配。）例如，解析表达式a&lt;em&gt;总是尽可能多的消耗输入字符串中连续出现的a，解析表达式(a&lt;/em&gt; a)则必然会失败因为前半部分a*绝对不会留下一丁点a给后半部分去匹配。&lt;/p&gt;
&lt;p&gt;最后，肯定断言和否定断言实现了句法断言。&amp;amp;e 表达式调用子表达式e，如果e成功，则返回成功；否则返回失败。无论结果如何都不消耗任何字符。反之，当e失败时！e 表达式成功，e成功时！e 表达式失败， 同样无论结果如何都不消耗任何字符。因为向前判断的子表达式e 可以任意的复杂，所以断言表达式提供了强大的句法向前判断和去除二义性的能力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;PEG-js&quot;&gt;&lt;a href=&quot;#PEG-js&quot; class=&quot;headerlink&quot; title=&quot;PEG.js&quot;&gt;&lt;/a&gt;PEG.js&lt;/h1&gt;&lt;p&gt;&lt;em&gt;本着从没有翻译过技术文档和觉得翻译一下应该对文档会更加深入了解的想法来翻译，译文可能存在大量错误和不流畅的地方，建议自己阅读官方文档，本译文仅供参考，欢迎对错误指正。以下翻译：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;PEG.js 是一个基于 JavaScript 的简单的解析器生成器，它用来生成一个快速且具备完善错误报告的解析器。你可以用它来处理复杂的数据或计算机语言，已经轻松的构造变换器，解释器，编译器以及其他的工具。&lt;/p&gt;
    
    </summary>
    
      <category term="PEG" scheme="https://ruiming.github.io/categories/PEG/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="Compiler" scheme="https://ruiming.github.io/tags/Compiler/"/>
    
      <category term="PEG.js" scheme="https://ruiming.github.io/tags/PEG-js/"/>
    
  </entry>
  
  <entry>
    <title>Angular 最佳实践总结 (一)</title>
    <link href="https://ruiming.github.io/2016/09/29/Angular%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%20(%E4%B8%80)/"/>
    <id>https://ruiming.github.io/2016/09/29/Angular 最佳实践总结 (一)/</id>
    <published>2016-09-29T06:45:13.000Z</published>
    <updated>2016-09-30T03:10:31.796Z</updated>
    
    <content type="html"><![CDATA[<p>搞了快一年的 Angular，Angular 真的是一个非常强大非常齐全非常好用的框架，而且拥有强大的社区支持，虽然踩了很多坑，但是仍然无悔学习了这样一个框架。Angular 2 已经正式发布了，我也打算学 Angular2 去了，现在手头上还有一个用 Angular 的项目，这个项目我是想把我学到的很多 Angular 的最佳实践都用进去，借此我就想干脆也写几篇博客总结下好了，我写的比较散，想到什么就说什么。</p>
<h2 id="使用单次绑定或单向绑定"><a href="#使用单次绑定或单向绑定" class="headerlink" title="使用单次绑定或单向绑定"></a>使用单次绑定或单向绑定</h2><p>从 Angular 1.3 开始就有了 once-time binding，Angular 1.5 开始支持了指令和组件的 one-way binding。看看他们的用法：</p>
<p>单次绑定很简单，加上<code>::</code> 就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;p&gt;&#123;&#123;::vm.title&#125;&#125;&lt;<span class="regexp">/p&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>An expression that starts with <code>::</code> is considered a one-time expression. One-time expressions will stop recalculating once they are stable, which happens after the first digest if the expression result is a non-undefined value (see value stabilization algorithm below).</p>
</blockquote>
<p>当 digest 结束之后并且单次绑定的值不为 undefined 时，这个值将不再被监听。官方称这个算法为 <code>Value stabilization algorithm</code> 还解释了一下。看到这个，再想起 Angular 源码那注释，觉得真的业界良心啊。想具体了解下单次绑定，出门右转 -&gt; <a href="https://docs.angularjs.org/guide/expression" target="_blank" rel="external">docs.angularjs</a></p>
<p>在视图进行单向绑定也很简单，使用 <code>ng-bind</code> 就可以了，这里主要说的是指令和组件中的单向绑定。</p>
<p>其实 Angular1 还是不断再发展，现在最新的是 1.5.9，加了很多新的东西，也做了很多性能优化。单向绑定也是 1.5 之后才引入的新东西。1.5 也引入了一个新的东西叫 component，和 directive 差不多，具体我没用过我也不太了解，不过写法简洁了很多。单向绑定主要就是用于 component 和 directive 的。</p>
<p>随便找个比较简单的例子来说下，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="meta">  'use strict'</span>;</div><div class="line">  <span class="keyword">var</span> app = angular.module(<span class="string">'app'</span>);</div><div class="line"></div><div class="line">  app.component(<span class="string">'menuBar'</span>, &#123;</div><div class="line">    <span class="comment">// defines a two way binding in and out of the component</span></div><div class="line">    bindings: &#123;</div><div class="line">      brand:<span class="string">'&lt;'</span></div><div class="line">     &#125;,</div><div class="line">    <span class="comment">// Load the template</span></div><div class="line">    templateUrl: <span class="string">'/js/components/appComponent.html'</span>,</div><div class="line">    controller: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// A list of menus</span></div><div class="line">      <span class="keyword">this</span>.menu = [&#123;</div><div class="line">        name: <span class="string">"Home"</span>,</div><div class="line">        component: <span class="string">"home"</span></div><div class="line">      &#125;, &#123;</div><div class="line">        name: <span class="string">"About"</span>,</div><div class="line">        component: <span class="string">"about"</span></div><div class="line">      &#125;, &#123;</div><div class="line">        name: <span class="string">"Contact"</span>,</div><div class="line">        component: <span class="string">"contact"</span></div><div class="line">      &#125;];</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>单向绑定就上面的 <code>&lt;</code> ，我们知道一般有 <code>@</code>, <code>=</code>, <code>&amp;</code> 三种方式，分别表示绑定字面量，绑定表达式，绑定事件，而新增的 <code>&lt;</code> 是用来实现单向绑定的。上面这段代码是从别的地方找来的，由于我自己没有使用过，所以暂时不过多介绍，晚点搞清楚了再补充下。</p>
<h2 id="谨慎使用-interval"><a href="#谨慎使用-interval" class="headerlink" title="谨慎使用 $interval"></a>谨慎使用 $interval</h2><p>如果我们要实现实时显示当前时间的效果，可以有下面三种方式:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">vm.time = <span class="built_in">Date</span>.now();</div><div class="line"></div><div class="line"><span class="comment">// 方式一</span></div><div class="line">setInterval(() =&gt; &#123;</div><div class="line">  vm.time = <span class="built_in">Date</span>.now();</div><div class="line">  $scope.$digest();</div><div class="line">&#125;, <span class="number">1000</span>);</div><div class="line"></div><div class="line"><span class="comment">// 方式二</span></div><div class="line">setInterval(() =&gt; &#123;</div><div class="line">  $scope.$apply(() =&gt; &#123;</div><div class="line">    vm.time = <span class="built_in">Date</span>.now();</div><div class="line">  &#125;)</div><div class="line">&#125;, <span class="number">1000</span>);</div><div class="line"></div><div class="line"><span class="comment">// 方式三</span></div><div class="line">$interval(() =&gt; &#123;</div><div class="line">  vm.time = <span class="built_in">Date</span>.now();</div><div class="line">&#125;, <span class="number">1000</span>);</div></pre></td></tr></table></figure>
<p>考虑到页面还有其他双向绑定量，你觉得上面三种方式哪种性能消耗会小一点？</p>
<p>我这边测试了下，三种方式导致当前 digest 所执行的 watcher 表达式数量分别是　方式一 (34) &lt; 方式二 (140) = 方式三 (140)。</p>
<img src="/2016/09/29/Angular%20最佳实践总结%20(一)/方式一.png" alt="方式一" title="方式一">
<img src="/2016/09/29/Angular%20最佳实践总结%20(一)/方式二.png" alt="方式二" title="方式二">
<img src="/2016/09/29/Angular%20最佳实践总结%20(一)/方式三.png" alt="方式三" title="方式三">
<p>我感觉有种被骗的感觉，我记得大家都说不要手动调用 <code>$digest</code> 啊要用 <code>$apply</code> 啊… 但事实是这里的方式一是性能最好的，如果要说原因，那是因为<code>$scope.$digest()</code> 只会触发当前 scope 进行 digest，而其余的就会从 <code>$rootScope</code> 下来整个都进行 digest，对于我们这里只是想要实现时间变化的需求来说就显得有点多于了，这种情况下还是方式一合适些。当然了你也可以用原生 JS 来写，但这样就使用不了 Angular 的日期格式化功能了~</p>
<p>不少人认为 Angular 脏检查是轮询，如果不加限制使用 <code>$interval</code>，不就和轮询没区别了。所以能少用就少用，这里不用 <code>$interval</code> 是因为它会在每次循环结束自动调用 <code>$rootScope</code> 上面的 digest，因此使用 setInterval，如果你不触发 digest，那么这个数据的变化是不会同步到视图中的，所以我们手动的触发了当前作用于的 digest。</p>
<h2 id="ng-repeat-使用-trackby-优化"><a href="#ng-repeat-使用-trackby-优化" class="headerlink" title="ng-repeat 使用 trackby 优化"></a>ng-repeat 使用 trackby 优化</h2><p>Angular 会为每个 watch 变量生成一个 <code>hashkey</code>，并使用他来跟踪其值的变化，当我们使用 ng-repeat 时，如果数组的内容发生了变化，Angular 不会重新销毁和渲染整个 DOM，而是找出变化的一部分做出修改，由于 <code>hashkey</code> 是根据节点内容产生的，这意味着我们的数组中不能有完全一样的两个节点存在。并且当数组的子项为对象时，用一个类似的新的数组覆盖它会导致 Angular 销毁并重新渲染整个 DOM。我们试一试便知。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 不使用 track by --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">ng-repeat</span>=<span class="string">"item in items"</span>&gt;</span></div><div class="line">  &#123;&#123;item.value&#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 使用 track by --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">ng-repeat</span>=<span class="string">"item in vm.items track by item.key"</span>&gt;</span></div><div class="line">  &#123;&#123;item.value&#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure>
<p>我们在控制器里面这样写看下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vm.items = [&#123;key: <span class="number">1</span>, value: <span class="number">2</span>&#125;, &#123;key: <span class="number">3</span>, value: <span class="number">4</span>&#125;, &#123;key: <span class="number">5</span>, value: <span class="number">6</span>&#125;];</div><div class="line">$timeout(() =&gt; vm.items = [&#123;key: <span class="number">1</span>, value: <span class="number">2</span>&#125;, &#123;key: <span class="number">3</span>, value: <span class="number">4</span>&#125;, &#123;key: <span class="number">5</span>, value: <span class="number">6</span>&#125;], <span class="number">2000</span>);</div><div class="line">$timeout(() =&gt; vm.items.push(&#123;key: <span class="number">7</span>, value: <span class="number">8</span>&#125;), <span class="number">3000</span>);</div></pre></td></tr></table></figure>
<p>可以自己试一试，然后调出开发者工具查看下 DOM 的变化</p>
<p>结果是：</p>
<ul>
<li><p>不使用 track by</p>
<p>2 秒后重新渲染全部子节点，3 秒后添加渲染了一个新节点。</p>
</li>
<li><p>使用 track by</p>
<p>2 秒后没变化，3秒后添加渲染了一个新节点。</p>
</li>
</ul>
<p>他们的区别就在数组重新赋值上面，还有就是数组必须是一个由对象组成的数组。在有些情况下，我们可能需要使用一个新的数组覆盖旧的数组，而他们之间可能有部分是相同的，如果我们使用 trackBy，Angular 就可以利用这一部分已经渲染好的 DOM，从而达到了优化的目的。</p>
<p>如果没有特别的唯一标识可以指定，也可以直接使用 <code>track by $index</code>，也可以起到一样的作用。</p>
<a id="more"></a>
<h2 id="关闭调试信息"><a href="#关闭调试信息" class="headerlink" title="关闭调试信息"></a>关闭调试信息</h2><p>据说这个方法很多人都不知道？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$compileProvider.debugInfoEnabled(<span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p>这样就可以关闭 Angular 插在视图里面的任何辅助调试信息例如 <code>ng-if</code> 和 <code>ng-repeat</code> 等注释以及 <code>ng-binding</code> 等 CSS 类。上线的时候关掉会比较好一点。</p>
<h2 id="使用超级强大的-interceptors"><a href="#使用超级强大的-interceptors" class="headerlink" title="使用超级强大的 interceptors"></a>使用超级强大的 interceptors</h2><p>这个在做全局请求和相应处理时特别强大，通过它我们可以实现统一修改每个请求的 header，对返回的结果进行处理，全局 HTTP 错误响应处理等等。用法也相当简单：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$httpProvider.interceptors.push(function($q) &#123;</div><div class="line">  return &#123;</div><div class="line">    'request': function(config) &#123;</div><div class="line">      </div><div class="line">    &#125;,</div><div class="line">    'requestError': function(rejection) &#123;</div><div class="line">      </div><div class="line">    &#125;,</div><div class="line">    ‘response': function(response) &#123;</div><div class="line">      </div><div class="line">    &#125;,</div><div class="line">    'responseError': function(rejection) &#123;</div><div class="line">      </div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>额，举个粟子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    angular</div><div class="line">        .module(<span class="string">'app'</span>)</div><div class="line">        .factory(<span class="string">'tokenInjector'</span>, tokenInjector);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">tokenInjector</span>(<span class="params">$injector, $q, $cookies, $cacheFactory, $timeout</span>) </span>&#123;</div><div class="line">        <span class="keyword">let</span> jwt = <span class="literal">undefined</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            request: <span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</div><div class="line">                <span class="keyword">if</span>(<span class="keyword">void</span> <span class="number">0</span> === jwt) &#123;</div><div class="line">                    jwt = $cookies.get(<span class="string">'jwt'</span>);</div><div class="line">                &#125;</div><div class="line">                config.headers[<span class="string">'Authorization'</span>] = <span class="string">"Bearer "</span> + jwt;</div><div class="line">                <span class="keyword">return</span> $q.when(config);</div><div class="line">            &#125;,</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<p>上面新建了一个 <code>tokenInjector</code>，之后我们这样使用就可以了:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$httpProvider.interceptors.push(tokenInjector);</div></pre></td></tr></table></figure>
<p>作用就是实现每次请求都自动把 token 添加到 header 的 Aturhorization 中。除此之外还可以做好多好多东西，这里就不详细介绍下去了。</p>
<h2 id="使用-ui-router-替代-ngRoute"><a href="#使用-ui-router-替代-ngRoute" class="headerlink" title="使用 ui-router 替代 ngRoute"></a>使用 ui-router 替代 ngRoute</h2><p>自从用了 ui-router 就再也回不去 ngRoute 了，ui-router 使用状态来进行转移，支持多视图和嵌套视图，使用方法更加灵活，并且也有更加丰富的 API。多视图，嵌套视图你知道意味什么吧，这些 ngRoute 做不到，官方现在也是主推 ui-router，前段时间 ui-router 已经出了新的 1.0 版本，相信大部分开发者还是在用老版本吧，可以考虑迁移了，想要了解新版本的迁移事项看<a href="https://ui-router.github.io/guide/ng1/migrate-to-1_0" target="_blank" rel="external">这里</a>。</p>
<p>对于还在使用 ngRoute 的童鞋，我也强烈建议你去使用 ui-router。</p>
<p>多视图和嵌套视图就不多说了，除此之外还有比较强大实用的地方就是 ui-router 提供的生命周期钩子即 <code>$stateChangeStart</code>, <code>$stateChangeSuccess</code>, <code>$stateChangeError</code>，ngRoute 不知道有没有，没有去了解过。下面举个粟子说下用法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">$rootScope.$on(<span class="string">"$stateChangeStart"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event, toState, toStateParams, fromState, fromStateParams</span>) </span>&#123;</div><div class="line">    $rootScope.loading = <span class="literal">true</span>;</div><div class="line">&#125;);</div><div class="line">$rootScope.$on(<span class="string">"$stateChangeSuccess"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event, toState, toStateParams, fromState, fromParams</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(ga) &#123;</div><div class="line">    <span class="keyword">let</span> re = <span class="regexp">/\&#123;(.*?)&#125;/g</span>, url;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">Object</span>.keys(toStateParams).length &gt; <span class="number">0</span>) &#123;</div><div class="line">      url = toState.url.replace(re, <span class="built_in">Object</span>.values(toStateParams).reduce((pre, curr) =&gt; curr));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      url = toState.url;</div><div class="line">    &#125;</div><div class="line">    ga(<span class="string">'send'</span>, <span class="string">'pageview'</span>, url);</div><div class="line">  &#125;</div><div class="line">  $rootScope.loading = <span class="literal">false</span>;</div><div class="line">&#125;);</div><div class="line">$rootScope.$on(<span class="string">"$stateChangeError"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event, toState, toStateParams, fromState, fromParams, error</span>) </span>&#123;</div><div class="line">  $rootScope.loading = <span class="literal">false</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>其实上面应该时比较 tricky 的做法，作用就是全局视图切换动画以及让 google analysis 工作，从 <code>stateChangeStart</code> 开始，<code>isLoading</code> 变为 true 直到 <code>stateChangeSuccess</code> 的时候变为 false。我们把 <code>isLoading</code> 挂在 <code>$rootScope</code> 上面方便使用，用这个变量就可以判断是否加载一个 Loading 的 DOM。</p>
<p>其次，由于单页应用特性，google analysis 只被加载一次从而无法实时反馈用户当前所访问的页面，我们可以手动进行调用，上面就是用法了，也是每次在成功状态变化之后发送当前 url。</p>
<p>不过遗憾的是这个 API 在 ui-router 1.0 版本废弃了，不过 ui-router 1.0 目录下带了另一个文件，引入这个文件即可以继续使用。我猜测 ui-router 1.0 应该是有更好的解决方案来替代它，详细的可以自己去了解下。</p>
<p>另外还想说的一个地方就是 ui-router 的 resolve 功能，允许我们在控制器初始化之前先获取和处理数据，如果 resolve 的东西是一个 promise，如果 promise 状态为 rejected，那么视图就不会被成功切换。基于此我们可以把视图需要的一些 HTTP 请求放到 ui-router 的 resolve 上面来做，然后再注入到控制器给控制器使用，并且这样还可以避免数据未到达时视图的数据显示问题以及数据请求失败后的问题。举个粟子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">.state(<span class="string">'posts'</span>, &#123;</div><div class="line">  url: <span class="string">'/posts/:type'</span>,</div><div class="line">  templateUrl: <span class="string">'posts/posts_tpl.html'</span>,</div><div class="line">  controller: <span class="string">'PostsController as vm'</span>,</div><div class="line">  resolve: &#123;</div><div class="line">    posts: <span class="function"><span class="keyword">function</span>(<span class="params">Posts, $stateParams, $q</span>) </span>&#123;</div><div class="line">      <span class="keyword">let</span> defer = $q.defer();</div><div class="line">      <span class="keyword">if</span>([<span class="string">'unread'</span>, <span class="string">'mark'</span>].indexOf($stateParams.type) !== <span class="number">-1</span>) &#123;</div><div class="line">        defer.resolve(Posts.get(&#123;type: $stateParams.type&#125;).$promise);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        defer.reject(<span class="string">'参数不正确'</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> defer.promise;</div><div class="line">    &#125;,</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这是一个路由的状态，这里应用了 promise 的反模式，其实我自己也不是特别了解，之前看到一篇文章再批评这个。我回去学习下再补充。</p>
<p>这个地方的作用就是判断 state 传进的参数是否符合要求，如果不符合要求则无法加载，符合要求的话就会去请求资源，如果请求失败的话视图也不会被加载，即状态不会切换成功，如果请求成功我们可以再控制器依赖注入 <code>posts</code> 取得返回结果。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;搞了快一年的 Angular，Angular 真的是一个非常强大非常齐全非常好用的框架，而且拥有强大的社区支持，虽然踩了很多坑，但是仍然无悔学习了这样一个框架。Angular 2 已经正式发布了，我也打算学 Angular2 去了，现在手头上还有一个用 Angular 的项目，这个项目我是想把我学到的很多 Angular 的最佳实践都用进去，借此我就想干脆也写几篇博客总结下好了，我写的比较散，想到什么就说什么。&lt;/p&gt;
&lt;h2 id=&quot;使用单次绑定或单向绑定&quot;&gt;&lt;a href=&quot;#使用单次绑定或单向绑定&quot; class=&quot;headerlink&quot; title=&quot;使用单次绑定或单向绑定&quot;&gt;&lt;/a&gt;使用单次绑定或单向绑定&lt;/h2&gt;&lt;p&gt;从 Angular 1.3 开始就有了 once-time binding，Angular 1.5 开始支持了指令和组件的 one-way binding。看看他们的用法：&lt;/p&gt;
&lt;p&gt;单次绑定很简单，加上&lt;code&gt;::&lt;/code&gt; 就可以了。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;p&amp;gt;&amp;#123;&amp;#123;::vm.title&amp;#125;&amp;#125;&amp;lt;&lt;span class=&quot;regexp&quot;&gt;/p&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;An expression that starts with &lt;code&gt;::&lt;/code&gt; is considered a one-time expression. One-time expressions will stop recalculating once they are stable, which happens after the first digest if the expression result is a non-undefined value (see value stabilization algorithm below).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当 digest 结束之后并且单次绑定的值不为 undefined 时，这个值将不再被监听。官方称这个算法为 &lt;code&gt;Value stabilization algorithm&lt;/code&gt; 还解释了一下。看到这个，再想起 Angular 源码那注释，觉得真的业界良心啊。想具体了解下单次绑定，出门右转 -&amp;gt; &lt;a href=&quot;https://docs.angularjs.org/guide/expression&quot;&gt;docs.angularjs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在视图进行单向绑定也很简单，使用 &lt;code&gt;ng-bind&lt;/code&gt; 就可以了，这里主要说的是指令和组件中的单向绑定。&lt;/p&gt;
&lt;p&gt;其实 Angular1 还是不断再发展，现在最新的是 1.5.9，加了很多新的东西，也做了很多性能优化。单向绑定也是 1.5 之后才引入的新东西。1.5 也引入了一个新的东西叫 component，和 directive 差不多，具体我没用过我也不太了解，不过写法简洁了很多。单向绑定主要就是用于 component 和 directive 的。&lt;/p&gt;
&lt;p&gt;随便找个比较简单的例子来说下，&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;  &#39;use strict&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; app = angular.module(&lt;span class=&quot;string&quot;&gt;&#39;app&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  app.component(&lt;span class=&quot;string&quot;&gt;&#39;menuBar&#39;&lt;/span&gt;, &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// defines a two way binding in and out of the component&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    bindings: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      brand:&lt;span class=&quot;string&quot;&gt;&#39;&amp;lt;&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Load the template&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    templateUrl: &lt;span class=&quot;string&quot;&gt;&#39;/js/components/appComponent.html&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    controller: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// A list of menus&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.menu = [&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        name: &lt;span class=&quot;string&quot;&gt;&quot;Home&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        component: &lt;span class=&quot;string&quot;&gt;&quot;home&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;, &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        name: &lt;span class=&quot;string&quot;&gt;&quot;About&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        component: &lt;span class=&quot;string&quot;&gt;&quot;about&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;, &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        name: &lt;span class=&quot;string&quot;&gt;&quot;Contact&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        component: &lt;span class=&quot;string&quot;&gt;&quot;contact&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;单向绑定就上面的 &lt;code&gt;&amp;lt;&lt;/code&gt; ，我们知道一般有 &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; 三种方式，分别表示绑定字面量，绑定表达式，绑定事件，而新增的 &lt;code&gt;&amp;lt;&lt;/code&gt; 是用来实现单向绑定的。上面这段代码是从别的地方找来的，由于我自己没有使用过，所以暂时不过多介绍，晚点搞清楚了再补充下。&lt;/p&gt;
&lt;h2 id=&quot;谨慎使用-interval&quot;&gt;&lt;a href=&quot;#谨慎使用-interval&quot; class=&quot;headerlink&quot; title=&quot;谨慎使用 $interval&quot;&gt;&lt;/a&gt;谨慎使用 $interval&lt;/h2&gt;&lt;p&gt;如果我们要实现实时显示当前时间的效果，可以有下面三种方式:&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;vm.time = &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;.now();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 方式一&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;setInterval(() =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  vm.time = &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;.now();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  $scope.$digest();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 方式二&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;setInterval(() =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  $scope.$apply(() =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    vm.time = &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;.now();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 方式三&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$interval(() =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  vm.time = &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;.now();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;考虑到页面还有其他双向绑定量，你觉得上面三种方式哪种性能消耗会小一点？&lt;/p&gt;
&lt;p&gt;我这边测试了下，三种方式导致当前 digest 所执行的 watcher 表达式数量分别是　方式一 (34) &amp;lt; 方式二 (140) = 方式三 (140)。&lt;/p&gt;
&lt;img src=&quot;/2016/09/29/Angular%20最佳实践总结%20(一)/方式一.png&quot; alt=&quot;方式一&quot; title=&quot;方式一&quot;&gt;
&lt;img src=&quot;/2016/09/29/Angular%20最佳实践总结%20(一)/方式二.png&quot; alt=&quot;方式二&quot; title=&quot;方式二&quot;&gt;
&lt;img src=&quot;/2016/09/29/Angular%20最佳实践总结%20(一)/方式三.png&quot; alt=&quot;方式三&quot; title=&quot;方式三&quot;&gt;
&lt;p&gt;我感觉有种被骗的感觉，我记得大家都说不要手动调用 &lt;code&gt;$digest&lt;/code&gt; 啊要用 &lt;code&gt;$apply&lt;/code&gt; 啊… 但事实是这里的方式一是性能最好的，如果要说原因，那是因为&lt;code&gt;$scope.$digest()&lt;/code&gt; 只会触发当前 scope 进行 digest，而其余的就会从 &lt;code&gt;$rootScope&lt;/code&gt; 下来整个都进行 digest，对于我们这里只是想要实现时间变化的需求来说就显得有点多于了，这种情况下还是方式一合适些。当然了你也可以用原生 JS 来写，但这样就使用不了 Angular 的日期格式化功能了~&lt;/p&gt;
&lt;p&gt;不少人认为 Angular 脏检查是轮询，如果不加限制使用 &lt;code&gt;$interval&lt;/code&gt;，不就和轮询没区别了。所以能少用就少用，这里不用 &lt;code&gt;$interval&lt;/code&gt; 是因为它会在每次循环结束自动调用 &lt;code&gt;$rootScope&lt;/code&gt; 上面的 digest，因此使用 setInterval，如果你不触发 digest，那么这个数据的变化是不会同步到视图中的，所以我们手动的触发了当前作用于的 digest。&lt;/p&gt;
&lt;h2 id=&quot;ng-repeat-使用-trackby-优化&quot;&gt;&lt;a href=&quot;#ng-repeat-使用-trackby-优化&quot; class=&quot;headerlink&quot; title=&quot;ng-repeat 使用 trackby 优化&quot;&gt;&lt;/a&gt;ng-repeat 使用 trackby 优化&lt;/h2&gt;&lt;p&gt;Angular 会为每个 watch 变量生成一个 &lt;code&gt;hashkey&lt;/code&gt;，并使用他来跟踪其值的变化，当我们使用 ng-repeat 时，如果数组的内容发生了变化，Angular 不会重新销毁和渲染整个 DOM，而是找出变化的一部分做出修改，由于 &lt;code&gt;hashkey&lt;/code&gt; 是根据节点内容产生的，这意味着我们的数组中不能有完全一样的两个节点存在。并且当数组的子项为对象时，用一个类似的新的数组覆盖它会导致 Angular 销毁并重新渲染整个 DOM。我们试一试便知。&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 不使用 track by --&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ng-repeat&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;item in items&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#123;&amp;#123;item.value&amp;#125;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 使用 track by --&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ng-repeat&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;item in vm.items track by item.key&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#123;&amp;#123;item.value&amp;#125;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们在控制器里面这样写看下&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;vm.items = [&amp;#123;key: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, value: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;#125;, &amp;#123;key: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, value: &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&amp;#125;, &amp;#123;key: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, value: &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&amp;#125;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$timeout(() =&amp;gt; vm.items = [&amp;#123;key: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, value: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;#125;, &amp;#123;key: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, value: &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&amp;#125;, &amp;#123;key: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, value: &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&amp;#125;], &lt;span class=&quot;number&quot;&gt;2000&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$timeout(() =&amp;gt; vm.items.push(&amp;#123;key: &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, value: &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&amp;#125;), &lt;span class=&quot;number&quot;&gt;3000&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以自己试一试，然后调出开发者工具查看下 DOM 的变化&lt;/p&gt;
&lt;p&gt;结果是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;不使用 track by&lt;/p&gt;
&lt;p&gt;2 秒后重新渲染全部子节点，3 秒后添加渲染了一个新节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用 track by&lt;/p&gt;
&lt;p&gt;2 秒后没变化，3秒后添加渲染了一个新节点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;他们的区别就在数组重新赋值上面，还有就是数组必须是一个由对象组成的数组。在有些情况下，我们可能需要使用一个新的数组覆盖旧的数组，而他们之间可能有部分是相同的，如果我们使用 trackBy，Angular 就可以利用这一部分已经渲染好的 DOM，从而达到了优化的目的。&lt;/p&gt;
&lt;p&gt;如果没有特别的唯一标识可以指定，也可以直接使用 &lt;code&gt;track by $index&lt;/code&gt;，也可以起到一样的作用。&lt;/p&gt;
    
    </summary>
    
      <category term="Angular" scheme="https://ruiming.github.io/categories/Angular/"/>
    
    
      <category term="Angular" scheme="https://ruiming.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>Angular1之折腾记</title>
    <link href="https://ruiming.github.io/2016/09/24/Angular1%E4%B9%8B%E6%8A%98%E8%85%BE%E8%AE%B0/"/>
    <id>https://ruiming.github.io/2016/09/24/Angular1之折腾记/</id>
    <published>2016-09-24T15:40:50.000Z</published>
    <updated>2016-09-25T06:11:05.129Z</updated>
    
    <content type="html"><![CDATA[<p>前几天 Angular2 正式发布了，虽然他也在我的学习计划里面，但我并没有把他应用在我最近开展的一个项目中。最近在写一个 Rss 订阅器，基于 Angular1 和 Koa2(总感觉两个有点不搭 =.= )，主要是不想在这个项目花太长时间，再者我还想集我目前掌握的所有技术之大成写一个能拿的出手的项目，所以就没有选择 Angular2 了。至于 Koa2，其实很早就想学了，只是之前一直在忙别的。</p>
<h2 id="angular-resource-介绍"><a href="#angular-resource-介绍" class="headerlink" title="angular-resource 介绍"></a>angular-resource 介绍</h2><p>今天捣鼓 Angular 的 Resource 功能，前端后端都掌握在自己的手上时去用 Angular 的 Resource 特别舒服，大大减少了代码量，特么强大。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    angular</div><div class="line">        .module(<span class="string">'app'</span>)</div><div class="line">        .factory(<span class="string">'Post'</span>, $resource =&gt; &#123;</div><div class="line">            <span class="keyword">return</span> $resource(<span class="string">'/api/feed/:feed_id/post/:id'</span>, &#123;id: <span class="string">'@_id'</span>&#125;, &#123;</div><div class="line">                update: &#123;method: <span class="string">'PUT'</span>&#125;,</div><div class="line">                get: &#123;method: <span class="string">'GET'</span>, cache: <span class="literal">true</span>&#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;)</div><div class="line">&#125;());</div></pre></td></tr></table></figure></p>
<p>在上面我定义了一个 <code>Post</code> 资源，一旦创建完成后，他就自动拥有了以下方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="string">'get'</span>: &#123;method: <span class="string">'GET'</span>&#125;,</div><div class="line">	<span class="string">'save'</span>: &#123;method: <span class="string">'POST'</span>&#125;,</div><div class="line">	<span class="string">'query'</span>: &#123;method: <span class="string">'GET'</span>, isArray: <span class="literal">true</span>&#125;,</div><div class="line">	<span class="string">'remove'</span>: &#123;method: <span class="string">'DELETE'</span>&#125;,</div><div class="line">	<span class="string">'delete'</span>: &#123;method: <span class="string">'DELETE'</span>&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有些 IE 浏览器可能不支持 <code>delete</code>，这时候可以使用 <code>remove</code>。<br>我们还可以自定义或者修改里面的方法，比如我上面中就自定义了一个 <code>update</code> 方法以及给 <code>get</code> 方法开启了缓存。</p>
<p>那怎么使用呢？也很简单，如果对 <code>restfulAPI</code> 比较熟悉应该很容易理解。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$stateProvider</div><div class="line">	.state(<span class="string">'feed.post'</span>, &#123;</div><div class="line">	      url: <span class="string">'/post/:post_id'</span>,</div><div class="line">	      templateUrl: <span class="string">'post/post_tpl.html'</span>,</div><div class="line">	      controller: <span class="string">'PostController as vm'</span>,</div><div class="line">	      resolve: &#123;</div><div class="line">	          post: <span class="function"><span class="keyword">function</span>(<span class="params">Post, $stateParams, $state</span>) </span>&#123;</div><div class="line">	              <span class="keyword">return</span> Post.get(&#123;feed_id: $stateParams.id, id: $stateParams.post_id&#125;).$promise;</div><div class="line">	          &#125;</div><div class="line">	      &#125;</div><div class="line">	  &#125;)</div></pre></td></tr></table></figure>
<p>这里就调用了 <code>get</code> 方法，同时把参数传入，这样就好了。其他方法其实一样的。<br><code>resource</code> 也有很多功能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$resource(url, [paramDefaults], [actions], options);</div></pre></td></tr></table></figure>
<p>第二个参数设置默认参数用，比如我们发起了一个 <code>get</code> 请求得到数据，这条数据有一个 <code>_id</code> 属性，我们可以把他绑定为默认的 <code>id</code> 参数，这样在之后执行该资源的其他方法时我们可以不指定 <code>id</code>。<br>第三个参数就是自定义方法的地方了，前面我给 <code>get</code> 方法升级了下，是这样的，这个也就是第三个参数了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$resource(<span class="string">'/api/feed/:feed_id/post/:id'</span>, &#123;id: <span class="string">'@_id'</span>&#125;, &#123;</div><div class="line">    update: &#123;method: <span class="string">'PUT'</span>&#125;,</div><div class="line">    get: &#123;method: <span class="string">'GET'</span>, cache: <span class="literal">true</span>&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>格式是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;action1: &#123;method:?, params:?, isArray:?, headers:?, ...&#125;,</div><div class="line"> action2: &#123;method:?, params:?, isArray:?, headers:?, ...&#125;,</div><div class="line"> ...&#125;</div></pre></td></tr></table></figure>
<p>更多说明参考<a href="https://docs.angularjs.org/api/ngResource/service/$resource" target="_blank" rel="external">官方文档</a>咯。<br>第四个参数没看明白，可以自己看下官方文档。</p>
<h2 id="angular-resource-缓存问题"><a href="#angular-resource-缓存问题" class="headerlink" title="angular-resource 缓存问题"></a>angular-resource 缓存问题</h2><p>上一个项目没有用 angular-resource 的时候，我就在 factory 里面缓存 response，下次请求时直接返回该 response。由于用户所操作的和所缓存的都是同一个对象，因此在进行一些对该 response 的修改时比如，用户进行点赞操作，那么我除了发出一个请求之外，我还要将 response 里的是否点赞的值修改过来，这样视图才能反映出来，由于和缓存是同一份东西，因此实现了缓存的同步变化。<br>但不知道是不是这种方式容易导致缓存被破坏还是怎么样，我看了下 angular 以及 angular-resource 的部分源码，发现 angular 在处理 http 缓存时对数据进行了 serialize 操作，而且第一次返回给用户的并不是缓存的结果，而是自己 resource 里面的东西，下次访问时才从缓存取出来后 deserialize 后返回。<br>关于这个问题其实老早就有人发出 issue 了，但官方并没有回应，目前比较好的解决方案就是在修改资源时，删除缓存。可以这样操作:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $httpDefaultCache = $cacheFactory.get(<span class="string">'$http'</span>);</div><div class="line">$httpDefaultCache.remove(key)；</div><div class="line"><span class="comment">// The cache key is the request URL including search parameters;</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>那有没有更好的办法呢，其实我也想过，有想到用缓存数据替代返回到控制器的数据，然而从这个尝试开始就发现了很多很坑的地方。<br>我在 httpInjector 里面拦截 response 加入了这么一段代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">     <span class="comment">// 只对 resource 的 cache 进行处理</span></div><div class="line">     <span class="keyword">if</span>(config.config &amp;&amp; config.config.cache === <span class="literal">true</span>) &#123;</div><div class="line">         <span class="keyword">let</span> url = config.config.url;</div><div class="line">         $cacheFactory.get(<span class="string">'$http'</span>).get(url)[<span class="number">1</span>] = angular.fromJson($cacheFactory.get(<span class="string">'$http'</span>).get(url)[<span class="number">1</span>]);</div><div class="line">         config.resource.data = $cacheFactory.get(<span class="string">'$http'</span>).get(url)[<span class="number">1</span>].data;</div><div class="line">         config.config.data = $cacheFactory.get(<span class="string">'$http'</span>).get(url)[<span class="number">1</span>].data;</div><div class="line">         config.data = $cacheFactory.get(<span class="string">'$http'</span>).get(url)[<span class="number">1</span>].data;</div><div class="line">         <span class="built_in">console</span>.log($cacheFactory.get(<span class="string">'$http'</span>).get(url));</div><div class="line">     &#125;</div><div class="line"> &#125;);</div></pre></td></tr></table></figure></p>
<p>作用就时强制 serialize 缓存的数据，然后讲全部数据都替换成缓存中的数据，由于在这一阶段并没有开始缓存，所以要设置 setTimeout 推迟操作。<br>这样做了之后，对第一次加载仍然没有什么影响，但第二次加载时就开始起作用了，更改会同步变化到缓存，其实就是之后用的就直接是缓存的对象，而不再是 deserialize 化后的数据，这一步应该归功于我修改了缓存中数据的存储形式。<br>由于第一次返回给控制器的数据并不是从缓存取出来的，而是从 resource 里面取出来的即上面的 <code>config.resource.data</code>，所以我也把他改到缓存中的对象去。为了更好说明问题，我把控制器代码也贴上来。我的目的就是进行 mark 操作后缓存也会自动同步过来。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    angular</div><div class="line">        .module(<span class="string">'app'</span>)</div><div class="line">        .controller(<span class="string">'PostController'</span>, PostController);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">PostController</span>(<span class="params">$state, post, Post, $scope, _, $rootScope, $timeout, $cacheFactory</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> vm = <span class="keyword">this</span>;</div><div class="line">        vm.post = post;</div><div class="line">		</div><div class="line">		vm.mark = mark;</div><div class="line">		</div><div class="line">        vm.currentPost = post.data.result;</div><div class="line">        vm.currentPostDetail = post.data.detail;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">mark</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            vm.currentPostDetail.mark = !vm.currentPostDetail.mark;</div><div class="line">            Post.update(&#123;feed_id: vm.currentPost.feed_id[<span class="number">0</span>], id: vm.currentPost._id&#125;, &#123;type: <span class="string">'mark'</span>&#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;());</div></pre></td></tr></table></figure></p>
<p>按理说，控制器初始化的时候 <code>post</code> 是一个 resource 对象，我在 <code>setTimeout</code> 中修改了 resource 内部的数据，指向到缓存中被 serialize 化的数据。而 <code>vm.currentPost</code> 和 <code>vm.currentPostDetail</code> 又是分别指向 <code>post.data.result</code> 和 <code>post.data.detail</code>，应该我在 <code>vm</code> 上面的操作可以影响到缓存才对，然而并不能。试试看修改 <code>mark</code> 方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mark</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    vm.currentPostDetail.mark = !vm.currentPostDetail.mark;</div><div class="line">    post.data.detail.mark = !post.data.detail.mark;</div><div class="line">    Post.update(&#123;feed_id: vm.currentPost.feed_id[<span class="number">0</span>], id: vm.currentPost._id&#125;, &#123;type: <span class="string">'mark'</span>, revert: <span class="literal">true</span>&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也就是加了一句话，更改 <code>post</code> 中的数据。结果是工作了！这说明 post 确实此时是指向缓存的。那 <code>vm.currentPostDetail</code> 也是指向 <code>post.data.detail</code> 的，为什么它不工作？<br>其实这不是 angular 的锅，console 试试下面就知道了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">pre = &#123;status: <span class="number">200</span>, result: &#123;detail: &#123;a:<span class="number">1</span>&#125;, result: &#123;b:<span class="number">2</span>&#125;&#125;&#125;;</div><div class="line">ctrl = pre.result.detail;		<span class="comment">// &#123;a:1&#125;</span></div><div class="line">cache = &#123;status: <span class="number">200</span>, result: &#123;detail: &#123;a:<span class="number">2</span>&#125;, result: &#123;b:<span class="number">3</span>&#125;&#125;&#125;;</div><div class="line">pre = cache;</div><div class="line"><span class="built_in">console</span>.log(ctrl);				<span class="comment">// &#123;a:1&#125;</span></div></pre></td></tr></table></figure></p>
<p>应该不止我一个人会认为最后结果应该是 <code>{a: 2}</code> 吧…其实上面还可以再简化成这样<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a = &#123;a:<span class="number">1</span>&#125;;</div><div class="line">b = a;</div><div class="line">a = &#123;a:<span class="number">2</span>&#125;;</div><div class="line"><span class="built_in">console</span>.log(b);		<span class="comment">// &#123;a:1&#125;</span></div></pre></td></tr></table></figure></p>
<p>画一个图的话是这样子的。<br><img src="/2016/09/24/Angular1之折腾记/object.png" alt="object" title="object"><br>这样应该就明了了，所以由于控制器第一次取到的 response 一定是 resource 内部的结果，而 httpInjector 是在返回 response 前进行修改，因此我们无法通过 httpInjector 来达到目的。唯一能做到的方法就是让控制器接受到的结果与缓存指向同一内存，假设 $cacheFactory 缓存 http 的结果没有被序列化，那么将 resource 中的数据加入缓存，同时把这个数据返回给控制器，就实现了控制器数据和缓存数据指向一致的目的，所以最终问题还是在 $cacheFactory 把结果给序列化了再存储。<br>为了验证下我们的说法，可以修改下 angular 源码下面的地方:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">done</span>(<span class="params">status, response, headersString, statusText</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (cache) &#123;</div><div class="line">        <span class="keyword">if</span> (isSuccess(status)) &#123;</div><div class="line">        cache.put(url, [status, response, parseHeaders(headersString), statusText]);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// remove promise from the cache</span></div><div class="line">        cache.remove(url);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolveHttpPromise</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        resolvePromise(response, status, headersString, statusText);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (useApplyAsync) &#123;</div><div class="line">        $rootScope.$applyAsync(resolveHttpPromise);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        resolveHttpPromise();</div><div class="line">        <span class="keyword">if</span> (!$rootScope.$$phase) $rootScope.$apply();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>把这一行<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cache.put(url, [status, response, parseHeaders(headersString), statusText]);</div></pre></td></tr></table></figure></p>
<p>改为<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cache.put(url, [status, angular.fromJson(response), parseHeaders(headersString), statusText]);</div></pre></td></tr></table></figure></p>
<p>之后就会发现，从第二次开始缓存的数据就会同步变更了，因为存的是对象，所以下次从缓存取的时候就直接用的对象，所以就可以保持数据的同步了。但第一次还是不行，我也没有再深究下去了，源码有点绕，看不太懂。<br>另外，过程中曾经有想利用 <code>$stateChangeStart</code> 和 <code>$stateChangeSuccess</code> 着手，但是发现这两个事件没有效果，查了资料才知道，<code>ui-router</code> 的新版本(1.0)已经有较大的变化，不再支持上面的事件，而是转而通过 <code>$transition</code> 来操作。如果你还在用老版本的 <code>ui-router</code>，可以试试看这个新版本的，迁移可以参考<a href="https://ui-router.github.io/guide/ng1/migrate-to-1_0#state-change-events" target="_blank" rel="external">这里</a>。</p>
<p>花了好几个小时想尝试解决这个问题都没搞定，现在还是搞不懂为什么 angular 要把数据序列化后缓存，是为了数据的稳定吗？如果可以提供一个 option 来设置不是很好吗？不知道有没有什么解决方案，一直没找着，貌似是因为缓存的数据就不应该被修改，但在一些场景它还是有应用用途的吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天 Angular2 正式发布了，虽然他也在我的学习计划里面，但我并没有把他应用在我最近开展的一个项目中。最近在写一个 Rss 订阅器，基于 Angular1 和 Koa2(总感觉两个有点不搭 =.= )，主要是不想在这个项目花太长时间，再者我还想集我目前掌握的所有技术之大成写一个能拿的出手的项目，所以就没有选择 Angular2 了。至于 Koa2，其实很早就想学了，只是之前一直在忙别的。&lt;/p&gt;
&lt;h2 id=&quot;angular-resource-介绍&quot;&gt;&lt;a href=&quot;#angular-resource-介绍&quot; class=&quot;headerlink&quot; title=&quot;angular-resource 介绍&quot;&gt;&lt;/a&gt;angular-resource 介绍&lt;/h2&gt;&lt;p&gt;今天捣鼓 Angular 的 Resource 功能，前端后端都掌握在自己的手上时去用 Angular 的 Resource 特别舒服，大大减少了代码量，特么强大。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    angular&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        .module(&lt;span class=&quot;string&quot;&gt;&#39;app&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        .factory(&lt;span class=&quot;string&quot;&gt;&#39;Post&#39;&lt;/span&gt;, $resource =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; $resource(&lt;span class=&quot;string&quot;&gt;&#39;/api/feed/:feed_id/post/:id&#39;&lt;/span&gt;, &amp;#123;id: &lt;span class=&quot;string&quot;&gt;&#39;@_id&#39;&lt;/span&gt;&amp;#125;, &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                update: &amp;#123;method: &lt;span class=&quot;string&quot;&gt;&#39;PUT&#39;&lt;/span&gt;&amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                get: &amp;#123;method: &lt;span class=&quot;string&quot;&gt;&#39;GET&#39;&lt;/span&gt;, cache: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;());&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在上面我定义了一个 &lt;code&gt;Post&lt;/code&gt; 资源，一旦创建完成后，他就自动拥有了以下方法。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&#39;get&#39;&lt;/span&gt;: &amp;#123;method: &lt;span class=&quot;string&quot;&gt;&#39;GET&#39;&lt;/span&gt;&amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&#39;save&#39;&lt;/span&gt;: &amp;#123;method: &lt;span class=&quot;string&quot;&gt;&#39;POST&#39;&lt;/span&gt;&amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&#39;query&#39;&lt;/span&gt;: &amp;#123;method: &lt;span class=&quot;string&quot;&gt;&#39;GET&#39;&lt;/span&gt;, isArray: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&#39;remove&#39;&lt;/span&gt;: &amp;#123;method: &lt;span class=&quot;string&quot;&gt;&#39;DELETE&#39;&lt;/span&gt;&amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&#39;delete&#39;&lt;/span&gt;: &amp;#123;method: &lt;span class=&quot;string&quot;&gt;&#39;DELETE&#39;&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;有些 IE 浏览器可能不支持 &lt;code&gt;delete&lt;/code&gt;，这时候可以使用 &lt;code&gt;remove&lt;/code&gt;。&lt;br&gt;我们还可以自定义或者修改里面的方法，比如我上面中就自定义了一个 &lt;code&gt;update&lt;/code&gt; 方法以及给 &lt;code&gt;get&lt;/code&gt; 方法开启了缓存。&lt;/p&gt;
&lt;p&gt;那怎么使用呢？也很简单，如果对 &lt;code&gt;restfulAPI&lt;/code&gt; 比较熟悉应该很容易理解。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$stateProvider&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	.state(&lt;span class=&quot;string&quot;&gt;&#39;feed.post&#39;&lt;/span&gt;, &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	      url: &lt;span class=&quot;string&quot;&gt;&#39;/post/:post_id&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	      templateUrl: &lt;span class=&quot;string&quot;&gt;&#39;post/post_tpl.html&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	      controller: &lt;span class=&quot;string&quot;&gt;&#39;PostController as vm&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	      resolve: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	          post: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;Post, $stateParams, $state&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	              &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Post.get(&amp;#123;feed_id: $stateParams.id, id: $stateParams.post_id&amp;#125;).$promise;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	          &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	      &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	  &amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里就调用了 &lt;code&gt;get&lt;/code&gt; 方法，同时把参数传入，这样就好了。其他方法其实一样的。&lt;br&gt;&lt;code&gt;resource&lt;/code&gt; 也有很多功能。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$resource(url, [paramDefaults], [actions], options);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第二个参数设置默认参数用，比如我们发起了一个 &lt;code&gt;get&lt;/code&gt; 请求得到数据，这条数据有一个 &lt;code&gt;_id&lt;/code&gt; 属性，我们可以把他绑定为默认的 &lt;code&gt;id&lt;/code&gt; 参数，这样在之后执行该资源的其他方法时我们可以不指定 &lt;code&gt;id&lt;/code&gt;。&lt;br&gt;第三个参数就是自定义方法的地方了，前面我给 &lt;code&gt;get&lt;/code&gt; 方法升级了下，是这样的，这个也就是第三个参数了。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$resource(&lt;span class=&quot;string&quot;&gt;&#39;/api/feed/:feed_id/post/:id&#39;&lt;/span&gt;, &amp;#123;id: &lt;span class=&quot;string&quot;&gt;&#39;@_id&#39;&lt;/span&gt;&amp;#125;, &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    update: &amp;#123;method: &lt;span class=&quot;string&quot;&gt;&#39;PUT&#39;&lt;/span&gt;&amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    get: &amp;#123;method: &lt;span class=&quot;string&quot;&gt;&#39;GET&#39;&lt;/span&gt;, cache: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;格式是这样的：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;action1: &amp;#123;method:?, params:?, isArray:?, headers:?, ...&amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; action2: &amp;#123;method:?, params:?, isArray:?, headers:?, ...&amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; ...&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;更多说明参考&lt;a href=&quot;https://docs.angularjs.org/api/ngResource/service/$resource&quot;&gt;官方文档&lt;/a&gt;咯。&lt;br&gt;第四个参数没看明白，可以自己看下官方文档。&lt;/p&gt;
&lt;h2 id=&quot;angular-resource-缓存问题&quot;&gt;&lt;a href=&quot;#angular-resource-缓存问题&quot; class=&quot;headerlink&quot; title=&quot;angular-resource 缓存问题&quot;&gt;&lt;/a&gt;angular-resource 缓存问题&lt;/h2&gt;&lt;p&gt;上一个项目没有用 angular-resource 的时候，我就在 factory 里面缓存 response，下次请求时直接返回该 response。由于用户所操作的和所缓存的都是同一个对象，因此在进行一些对该 response 的修改时比如，用户进行点赞操作，那么我除了发出一个请求之外，我还要将 response 里的是否点赞的值修改过来，这样视图才能反映出来，由于和缓存是同一份东西，因此实现了缓存的同步变化。&lt;br&gt;但不知道是不是这种方式容易导致缓存被破坏还是怎么样，我看了下 angular 以及 angular-resource 的部分源码，发现 angular 在处理 http 缓存时对数据进行了 serialize 操作，而且第一次返回给用户的并不是缓存的结果，而是自己 resource 里面的东西，下次访问时才从缓存取出来后 deserialize 后返回。&lt;br&gt;关于这个问题其实老早就有人发出 issue 了，但官方并没有回应，目前比较好的解决方案就是在修改资源时，删除缓存。可以这样操作:&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; $httpDefaultCache = $cacheFactory.get(&lt;span class=&quot;string&quot;&gt;&#39;$http&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$httpDefaultCache.remove(key)；&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// The cache key is the request URL including search parameters;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Angular" scheme="https://ruiming.github.io/categories/Angular/"/>
    
    
      <category term="Angular" scheme="https://ruiming.github.io/tags/Angular/"/>
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>提升网站加载速度的 N 个方法</title>
    <link href="https://ruiming.github.io/2016/09/11/%E6%8F%90%E5%8D%87%E7%BD%91%E7%AB%99%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E7%9A%84%20N%20%E4%B8%AA%E6%96%B9%E6%B3%95/"/>
    <id>https://ruiming.github.io/2016/09/11/提升网站加载速度的 N 个方法/</id>
    <published>2016-09-11T05:53:33.000Z</published>
    <updated>2016-09-29T05:07:37.555Z</updated>
    
    <content type="html"><![CDATA[<p>Web 这几年的一个变化之一估计就是各种优化小技巧不断涌出…自己也琢磨和尝试了不少优化，毕竟自己项目的网页首屏加载也是一度接近 2M 的。以下针对 HTTP1 和 HTTP1.1，在 HTTP2 中，很多最佳实践都适得其反了。</p>
<h2 id="减少文件传输数量"><a href="#减少文件传输数量" class="headerlink" title="减少文件传输数量"></a>减少文件传输数量</h2><p>现在前端代码发布上线的时候一般都会进行压缩，混淆，合并等操作，他们起到了减少文件体积和数量以及混淆代码降低可读性的作用。</p>
<p>浏览器针对同一域名的并发请求数目是有限制的，而在 HTTP1 和 HTTP1.1 中每传输一个资源就得建立一条连接。因此当网站的请求资源数量过多时，会导致后面资源请求的阻塞，也会导致频繁的连接建立和关闭带来的开销。一般浏览器的并发请求数量在4-8之间。因此我们针对同一域名的资源不宜过多，否则就会导致后面资源的阻塞。</p>
<p>针对该问题，我们可以采用合并文件，将资源分到不同域名，缓加载资源，提前加载资源，缓存等手段。具体如下：</p>
<ol>
<li>合并文件以减少并发请求数量<br> 合并文件也不能简单粗暴的合并为一个，对于长时间不会改变的文件我们要单独合并出来，这个文件是可以进行长期缓存的，而一些变动较为频繁的我们就不应该和上面的这些文件合并在一起，并且他们也不应该设置过激的缓存策略。</li>
<li>将次要文件延迟加载，比如 Google Analysis<br> 一些无关痛痒的文件可以放到页面最尾部，这是最佳实践，这里特别想提一下 async 和 defer，他们并没有对文件的请求产生影响，只是影响了执行的过程，所以我们不应该使用 async 或者 defer 方法来优化。 <img src="/2016/09/11/提升网站加载速度的%20N%20个方法/async-defer.jpg" alt="async-defer" title="async-defer">
 使用 async，会立即开始并行加载，加载完成后会进行执行并阻塞主渲染进程。<br> 使用 defer，会立即开始并行加载，但会延迟到最后才执行。</li>
<li>分散资源到不同域名<br> 比如图片有专门的域名(img.xxx.com)来存储。一些资源可以考虑第三方 CDN 比如 Bootcss 的 CDN，因为这类 CDN 使用较广，有可能用户浏览器已经有过缓存，这就避免了再次请求和加载，同时也减轻了服务器压力。</li>
<li>使用雪碧图(css sprites)来合并小图片<br> 这个优化技术其实挺常见，将图片合并为一个后使用 background-image 和 background-position 等来控制显示雪碧图的哪一部分就好了，据说还可以自动生成雪碧图自动定位。</li>
<li>利用 200 缓存<br> 这是一个比较极端的缓存方式，200 缓存时浏览器不发出网络请求，直接调用本地缓存，这需要强制浏览器使用本地缓存。我们可以使用 Expires 标志。即给出日期时间，超出该时间后则认为是过时，浏览器才会重新发起请求。这个具体细节我还不太了解。过后补充。</li>
<li>使用懒加载(lazy load)<br> 很多网站特别是有大量图片的网站都会使用该技术。当用户下滑页面时，才开始加载下面的图片。一来减少了页面加载的请求数和加载时间，二来也减少用户流量。不过可能有人会说这样体验不太好，好在业内有人把这个技术做到了堪称极致的地步，就是预先加载一个高度压缩的原图，然后淡出原图。大家应该有体验到类似的技术，就不多说了。</li>
<li><p>使用预加载技术(prefetch)<br> 这个技术知道的人可能不多，MDN 上面是这样解释的：</p>
<blockquote>
<p>页面资源预加载(Link prefetch)是浏览器提供的一个技巧，目的是让浏览器在空闲时间下载或预读取一些文档资源，用户在将来将会访问这些资源。一个Web页面可以对浏览器设置一系列的预加载指示，当浏览器加载完当前页面后，它会在后台静悄悄的加载指定的文档，并把它们存储在缓存里。当用户访问到这些预加载的文档后，浏览器能快速的从缓存里提取给用户。</p>
</blockquote>
<p> 不过资源预加载其实使用的并不多，可能是因为技术本身不成熟，浏览器支持不够等原因。目前没有发现有哪个网站使用了这个技术。感兴趣的自己去了解下，这里不多阐述这个技术。</p>
</li>
<li>集中加载资源<br> 额，这个名字是我自己起的，姑且我认为也是一种优化手段，主要针对的时 SPA。比如 Angular 搭建的 SPA。Angular 提供了 templateCache 这个模块。这个在前面的博客中已经介绍过，简单说就是一个数组，我们把模板全部都预先放入这个数组中。Angular 在请求页面的时候会先检查 templateCache 是否已经缓存了，如果有则直接调用这个缓存的模板，否则发出网络请求获取该模板，同时会放入 templateCache 中缓存。有人可能会问那不是增加了首屏加载的体积大小了吗？的确，但比起用户每点击一个新的页面就发起一个请求而言，这种方式无疑会更适合不是吗？并且如果你的文件确实太大了，那你应该考虑下你是否充分利用了指令功能。</li>
</ol>
<h2 id="减少文件大小"><a href="#减少文件大小" class="headerlink" title="减少文件大小"></a>减少文件大小</h2><p>除了减少文件数量，减少文件大小也同样重要，不过比起合并文件这样简单的减少文件数量的操作，减少文件大小就没来的那么简单了。常用的方法如下：<br><a id="more"></a></p>
<ol>
<li><p>开启 GZIP 压缩<br> GZIP 压缩应用非常广泛，因其可以有效明显的减少文件的体积。在 Nginx 中，我们可以很简单的进行配置开启 GZIP 压缩。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">gzip on;</div><div class="line">gzip_vary on;</div><div class="line">gzip_comp_level 4;</div><div class="line">gzip_buffers 16 8K;</div><div class="line">gzip_min_length 1k;</div><div class="line">gzip_proxied any;</div><div class="line">gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;</div><div class="line">gzip_<span class="built_in">disable</span> <span class="string">"MSIE [1-6]\."</span>;</div></pre></td></tr></table></figure>
<p> 这是我项目服务器上面 Nginx 关于 gzip 的配置。我们关心的当然还是压缩前后文件大小的差异，找别人的一个图贴下：</p>
 <img src="/2016/09/11/提升网站加载速度的%20N%20个方法/gzip_comp_level.png" alt="gzip_comp_level" title="gzip_comp_level">
<p> 可以看到效果还是很明显的，一般 GZIP 等级不宜高于 4 级。因为压缩意味着浏览器下载后还需要解压，所以压缩等级过高反而会带来性能问题（移动端耗电增加）甚至是降低页面渲染（解压占用CPU影响页面渲染且耗时）。<br> 另外，大文件压缩效果更明显，所以合并文件后再压缩会比分开压缩效果要好。</p>
</li>
<li><p>使用 WebP 格式图片<br> WebP 是 Google 推出的一种同时提供有损压缩与无损压缩的图片文件格式。根据 Google 较早的测试，无损压缩后的 WebP 比 PNG 文件少了45%的文件大小，即使这些 PNG 文件经过其他压缩工具压缩之后，WebP 还是可以减少28%的文件大小。</p>
 <img src="/2016/09/11/提升网站加载速度的%20N%20个方法/WebP.png" alt="WebP" title="WebP">
<p> WebP 在互联网上已经非常流行，主流浏览器都已经支持，并且国内也有大量站点如淘宝网，腾讯网，QQ空间等等都使用了这一格式。另外，针对不支持的浏览器，也可以引入相应的 shim 解决。</p>
 <img src="/2016/09/11/提升网站加载速度的%20N%20个方法/WebP支持情况.png" alt="WebP支持情况" title="WebP支持情况">
</li>
<li><p>书写压缩友好的代码<br> 这个对开发人员就要较高的要求了，并且如果不是对文件体积有很大的要求一般都不会做到这一步。在代码压缩的过程有一步就是进行变量替换，举一个前面博客中的例子来说</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">	<span class="keyword">var</span> ArrayProto = <span class="built_in">Array</span>.prototype, ObjProto = <span class="built_in">Object</span>.prototype;</div><div class="line"><span class="keyword">var</span> SymbolProto = <span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">'undefined'</span> ? <span class="built_in">Symbol</span>.prototype : <span class="literal">null</span>;</div><div class="line"><span class="keyword">var</span> push = ArrayProto.push,</div><div class="line">    slice = ArrayProto.slice,</div><div class="line">    toString = ObjProto.toString,</div><div class="line">    hasOwnProperty = ObjProto.hasOwnProperty;</div></pre></td></tr></table></figure>
<p> <code>Array.prototype.push</code> 是无法压缩的，而如果我们赋值 <code>ArrayProto = Array.prototype</code> ，那么 <code>ArrayProto</code> 就可以被替换掉，同理，上面中的 <code>push</code>, <code>slice</code> 等都是对压缩友好的。除此之外，一般的压缩工具还会把 <code>undefined</code>  都替换为 <code>void 0</code>，一来可以避免 <code>underfined</code> 重写的问题，二来字符数少了。目前我比较清楚的就这两个，有兴趣的话可以去了解下压缩的过程，对比下压缩前后。</p>
</li>
<li><p>避免引入无用代码<br>有一种比较常见的场景是我们使用了 FontAweSome 等的文件后，虽然我们可以很方便的通过写 CSS 类名来添加修改图标，但我们用到的毕竟时少数图标，所以其他没有用到的图标的引入就是非必须的。这个我自己没有实践过，可以看看<a href="http://stackoverflow.com/questions/15331525/optimize-font-awesome-for-only-used-classes" target="_blank" rel="external">Optimize Font Awesome for only used classes</a>这里的讨论。<br>除了去做筛选之外，还有的办法就是我们不要引入整个图标文件，有些提供图标的网站可以让你自己选择需要的图标后以字体和 CSS 文件的形式下载下来。这样做就稍微麻烦一点，不过既然你要图文件小，那麻烦一点也没什么。</p>
</li>
</ol>
<h2 id="其他-Web-提速手段"><a href="#其他-Web-提速手段" class="headerlink" title="其他 Web 提速手段"></a>其他 Web 提速手段</h2><p>前面集中就文件请求数和文件体积开展讨论，其实还远远不止上面这些办法。常用的还有以下这些。</p>
<ol>
<li><p>dns-prefetch<br> 这个其实和前面说的资源预加载差不多，只是这个是 DNS 预解析。用户访问一个新的域名之前，会首先通过 DNS 解析得到他的 IP 地址，之后才开始建立连接。DNS 解析也是需要时间的，而这个技术的作用就是在用户页面空闲的时候去预获取 IP 地址并缓存，这样当访问该域名页面的时候，就不需要再解析域名，从而缩短了页面加载时间。</p>
 <img src="/2016/09/11/提升网站加载速度的%20N%20个方法/dns-prefetch.png" alt="淘宝网 dns-prefetch" title="淘宝网 dns-prefetch">
</li>
<li><p>Preconnect<br> 这个和上面差不多，但是不光会解析 DNS 还会建立 TCP 握手连接和 TLS 协议(如果需要的话)用法如下：</p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preconnect"</span> <span class="attr">href</span>=<span class="string">"https://ruiming.github.io"</span>&gt;</span></div></pre></td></tr></table></figure>
<p> 但是这个的支持还比较一般，我也没找到有谁使用了这个技术。</p>
 <img src="/2016/09/11/提升网站加载速度的%20N%20个方法/preconnect.png" alt="preconnect" title="preconnect">
<p> 其实类似的预xx技术还挺多，还有预渲染等，感兴趣的可以参考<a href="http://www.alloyteam.com/2015/10/prefetching-preloading-prebrowsing/" target="_blank" rel="external">此处</a></p>
</li>
<li><p>使用第三方 CDN<br> 前面也有稍微提了下 CDN。对于 CDN 的使用应该根据实际情况来，如果整个页面就只引入了两三个第三方库，我们可以考虑使用公共 CDN 比如 Bootcss 的 CDN。其一是真的很快，比七牛什么都快好多，其二是用的人多，可能用户浏览器已经缓存了，另外 Bootcss 的 CDN 默认使用 HTTP2，在支持 HTTP2 的浏览器中，他也可以避免影响我们网站资源并发请求数量的问题，当然如果你也是用 HTTP2 这个问题就不大了。<br> 如果不使用公共 CDN，对于个人也可以使用七牛或者其他的提供的 CDN 存储。CDN 的好处在可以根据用户位置就近分配资源，同时也可以减轻服务器压力。</p>
</li>
</ol>
<hr>
<p>参考资料：<br>WebP 探寻之路: <a href="https://isux.tencent.com/introduction-of-webp.html" target="_blank" rel="external">https://isux.tencent.com/introduction-of-webp.html</a><br>一箩筐的预加载技术: <a href="http://www.alloyteam.com/2015/10/prefetching-preloading-prebrowsing" target="_blank" rel="external">http://www.alloyteam.com/2015/10/prefetching-preloading-prebrowsing</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web 这几年的一个变化之一估计就是各种优化小技巧不断涌出…自己也琢磨和尝试了不少优化，毕竟自己项目的网页首屏加载也是一度接近 2M 的。以下针对 HTTP1 和 HTTP1.1，在 HTTP2 中，很多最佳实践都适得其反了。&lt;/p&gt;
&lt;h2 id=&quot;减少文件传输数量&quot;&gt;&lt;a href=&quot;#减少文件传输数量&quot; class=&quot;headerlink&quot; title=&quot;减少文件传输数量&quot;&gt;&lt;/a&gt;减少文件传输数量&lt;/h2&gt;&lt;p&gt;现在前端代码发布上线的时候一般都会进行压缩，混淆，合并等操作，他们起到了减少文件体积和数量以及混淆代码降低可读性的作用。&lt;/p&gt;
&lt;p&gt;浏览器针对同一域名的并发请求数目是有限制的，而在 HTTP1 和 HTTP1.1 中每传输一个资源就得建立一条连接。因此当网站的请求资源数量过多时，会导致后面资源请求的阻塞，也会导致频繁的连接建立和关闭带来的开销。一般浏览器的并发请求数量在4-8之间。因此我们针对同一域名的资源不宜过多，否则就会导致后面资源的阻塞。&lt;/p&gt;
&lt;p&gt;针对该问题，我们可以采用合并文件，将资源分到不同域名，缓加载资源，提前加载资源，缓存等手段。具体如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;合并文件以减少并发请求数量&lt;br&gt; 合并文件也不能简单粗暴的合并为一个，对于长时间不会改变的文件我们要单独合并出来，这个文件是可以进行长期缓存的，而一些变动较为频繁的我们就不应该和上面的这些文件合并在一起，并且他们也不应该设置过激的缓存策略。&lt;/li&gt;
&lt;li&gt;将次要文件延迟加载，比如 Google Analysis&lt;br&gt; 一些无关痛痒的文件可以放到页面最尾部，这是最佳实践，这里特别想提一下 async 和 defer，他们并没有对文件的请求产生影响，只是影响了执行的过程，所以我们不应该使用 async 或者 defer 方法来优化。 &lt;img src=&quot;/2016/09/11/提升网站加载速度的%20N%20个方法/async-defer.jpg&quot; alt=&quot;async-defer&quot; title=&quot;async-defer&quot;&gt;
 使用 async，会立即开始并行加载，加载完成后会进行执行并阻塞主渲染进程。&lt;br&gt; 使用 defer，会立即开始并行加载，但会延迟到最后才执行。&lt;/li&gt;
&lt;li&gt;分散资源到不同域名&lt;br&gt; 比如图片有专门的域名(img.xxx.com)来存储。一些资源可以考虑第三方 CDN 比如 Bootcss 的 CDN，因为这类 CDN 使用较广，有可能用户浏览器已经有过缓存，这就避免了再次请求和加载，同时也减轻了服务器压力。&lt;/li&gt;
&lt;li&gt;使用雪碧图(css sprites)来合并小图片&lt;br&gt; 这个优化技术其实挺常见，将图片合并为一个后使用 background-image 和 background-position 等来控制显示雪碧图的哪一部分就好了，据说还可以自动生成雪碧图自动定位。&lt;/li&gt;
&lt;li&gt;利用 200 缓存&lt;br&gt; 这是一个比较极端的缓存方式，200 缓存时浏览器不发出网络请求，直接调用本地缓存，这需要强制浏览器使用本地缓存。我们可以使用 Expires 标志。即给出日期时间，超出该时间后则认为是过时，浏览器才会重新发起请求。这个具体细节我还不太了解。过后补充。&lt;/li&gt;
&lt;li&gt;使用懒加载(lazy load)&lt;br&gt; 很多网站特别是有大量图片的网站都会使用该技术。当用户下滑页面时，才开始加载下面的图片。一来减少了页面加载的请求数和加载时间，二来也减少用户流量。不过可能有人会说这样体验不太好，好在业内有人把这个技术做到了堪称极致的地步，就是预先加载一个高度压缩的原图，然后淡出原图。大家应该有体验到类似的技术，就不多说了。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用预加载技术(prefetch)&lt;br&gt; 这个技术知道的人可能不多，MDN 上面是这样解释的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;页面资源预加载(Link prefetch)是浏览器提供的一个技巧，目的是让浏览器在空闲时间下载或预读取一些文档资源，用户在将来将会访问这些资源。一个Web页面可以对浏览器设置一系列的预加载指示，当浏览器加载完当前页面后，它会在后台静悄悄的加载指定的文档，并把它们存储在缓存里。当用户访问到这些预加载的文档后，浏览器能快速的从缓存里提取给用户。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 不过资源预加载其实使用的并不多，可能是因为技术本身不成熟，浏览器支持不够等原因。目前没有发现有哪个网站使用了这个技术。感兴趣的自己去了解下，这里不多阐述这个技术。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;集中加载资源&lt;br&gt; 额，这个名字是我自己起的，姑且我认为也是一种优化手段，主要针对的时 SPA。比如 Angular 搭建的 SPA。Angular 提供了 templateCache 这个模块。这个在前面的博客中已经介绍过，简单说就是一个数组，我们把模板全部都预先放入这个数组中。Angular 在请求页面的时候会先检查 templateCache 是否已经缓存了，如果有则直接调用这个缓存的模板，否则发出网络请求获取该模板，同时会放入 templateCache 中缓存。有人可能会问那不是增加了首屏加载的体积大小了吗？的确，但比起用户每点击一个新的页面就发起一个请求而言，这种方式无疑会更适合不是吗？并且如果你的文件确实太大了，那你应该考虑下你是否充分利用了指令功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;减少文件大小&quot;&gt;&lt;a href=&quot;#减少文件大小&quot; class=&quot;headerlink&quot; title=&quot;减少文件大小&quot;&gt;&lt;/a&gt;减少文件大小&lt;/h2&gt;&lt;p&gt;除了减少文件数量，减少文件大小也同样重要，不过比起合并文件这样简单的减少文件数量的操作，减少文件大小就没来的那么简单了。常用的方法如下：&lt;br&gt;
    
    </summary>
    
      <category term="还不知道分什么类好" scheme="https://ruiming.github.io/categories/%E8%BF%98%E4%B8%8D%E7%9F%A5%E9%81%93%E5%88%86%E4%BB%80%E4%B9%88%E7%B1%BB%E5%A5%BD/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="HTTP" scheme="https://ruiming.github.io/tags/HTTP/"/>
    
      <category term="Web" scheme="https://ruiming.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 Angular 脏检查</title>
    <link href="https://ruiming.github.io/2016/09/04/%E6%B5%85%E8%B0%88%20Angular%20%E8%84%8F%E6%A3%80%E6%9F%A5/"/>
    <id>https://ruiming.github.io/2016/09/04/浅谈 Angular 脏检查/</id>
    <published>2016-09-04T06:57:22.000Z</published>
    <updated>2016-09-09T11:11:58.374Z</updated>
    
    <content type="html"><![CDATA[<p>Angular 的脏值检查机制一直是 Angular 被人诟病的地方，但瑕不掩瑜，Angular 还是一个非常优秀的框架，并且 Angular2 也已经抛弃了这个脏值检查的算法。<br>最近在看《AngularJS 深度剖析与最佳实践》，不得不说是一本很好的书籍，作者在第三章开始讲背后的原理，这里分析了 Angular 的 $digest 函数，即脏检查机制。所以自己也去下载了 Angular 最新的源码去瞧了下，然后做下笔记吧。</p>
<p>首先要注意，Angular 的 digest 的触发不是定时的，只有在指定的事件触发之后才会进入 $digest。基本上我们用的带 <code>$</code> 的东西调用之后都可能会触发 digest。比如我们使用 <code>setTimeout</code> 就不会触发 digest，即当你使用 <code>setTimeout</code> 更改 viewmodel 的值后，它不会同步的反映到用户的视图中去，解决方法有两个，一个是使用 Angular 提供的 <code>$timeout</code> 替代 <code>setTimeout</code>，<code>$timeout</code> 会在执行结束之后自动触发 digest； 另一个方法是手动调用 $apply，$apply 是 Angular 对 digest 的一层封装，我们一般不会直接调用 digest 而是通过使用 $apply 方法。比如对于 <code>setTimeout</code>，我们就可以这样触发 digest。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">  $scope.$apply(() =&gt; &#123;</div><div class="line">    $scope.test = <span class="number">123</span>;</div><div class="line">  &#125;)    </div><div class="line">&#125;, <span class="number">500</span>);</div></pre></td></tr></table></figure></p>
<p>我们看一个例子，这也是 Angular 源码 $digest 部分的一个示例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scope = ...;</div><div class="line">scope.name = <span class="string">'misko'</span>;</div><div class="line">scope.counter = <span class="number">0</span>;</div><div class="line"></div><div class="line">expect(scope.counter).toEqual(<span class="number">0</span>);</div><div class="line">scope.$watch(<span class="string">'name'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue</span>)</span>&#123;</div><div class="line">  scope.counter = scope.counter + <span class="number">1</span>;</div><div class="line">&#125;);</div><div class="line">expect(scope.counter).toEqual(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">// 执行第一次 digest，第一次 digest 会遍历全部的 watcher，并触发上面的方法，从而使的 count+1</span></div><div class="line">scope.$digest();</div><div class="line">expect(scope.counter).toEqual(<span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="comment">// 第二次调用时，由于上一次调用检查 name 不脏，所以不会再去处理</span></div><div class="line">scope.$digest();</div><div class="line">expect(scope.counter).toEqual(<span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="comment">// 第三次调用时，由于 name 发生了变化，使得当前值和上一次保存的值不同，所以会触发起 $watch 方法</span></div><div class="line">scope.name = <span class="string">'adam'</span>;</div><div class="line">scope.$digest();</div><div class="line">expect(scope.counter).toEqual(<span class="number">2</span>);</div></pre></td></tr></table></figure></p>
<p>Angular 的脏值检查过程大致如下：<br>对当前作用域和子作用域上的 <code>$$watchers</code> 进行遍历，<code>$$watches</code> 保存着 scope 上的所有变量以及其 <code>$watch</code> 方法，调用时会取当前值和上一次值进行比较，如果不相等则会调用 <code>$watch</code> 方法，同时会保存当前的值以在下一次进行比较，并且记录此次检查结果为脏。然后重复进行直到数据不脏为止，因此至少要 digest 两次，超出 10 次会报错，可以调高这个次数限制。当数据不再脏即 model 稳定下来之后， Angular 才会开始一次性批量更新 UI。从而减少了浏览器的 repaint 次数，提升性能。</p>
<p>深入到源码来看：<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div></pre></td><td class="code"><pre><div class="line">$digest: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> watch, value, last, fn, get,</div><div class="line">      watchers,</div><div class="line">      length,</div><div class="line">      dirty, ttl = TTL,</div><div class="line">      next, current, target = <span class="keyword">this</span>,</div><div class="line">      watchLog = [],</div><div class="line">      logIdx, asyncTask;</div><div class="line">      </div><div class="line">  beginPhase(<span class="string">'$digest'</span>);</div><div class="line">  $browser.$$checkUrlChange();</div><div class="line">  </div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === $rootScope &amp;&amp; applyAsyncId !== <span class="literal">null</span>) &#123;</div><div class="line">    $browser.defer.cancel(applyAsyncId);</div><div class="line">    flushApplyAsync();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  lastDirtyWatch = <span class="literal">null</span>;</div><div class="line">  </div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    dirty = <span class="literal">false</span>;</div><div class="line">    current = target;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> asyncQueuePosition = <span class="number">0</span>; asyncQueuePosition &lt; asyncQueue.length; asyncQueuePosition++) &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        asyncTask = asyncQueue[asyncQueuePosition];</div><div class="line">        asyncTask.scope.$<span class="built_in">eval</span>(asyncTask.expression, asyncTask.locals);</div><div class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        $exceptionHandler(e);</div><div class="line">      &#125;</div><div class="line">      lastDirtyWatch = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">    asyncQueue.length = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 脏值检查开始</span></div><div class="line">    traverseScopesLoop:</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">      <span class="comment">// 获取当前 scope 的 $$watchers</span></div><div class="line">      <span class="keyword">if</span> ((watchers = current.$$watchers)) &#123;</div><div class="line">        <span class="comment">// process our watches</span></div><div class="line">        <span class="comment">// 遍历执行这些 watches</span></div><div class="line">        length = watchers.length;</div><div class="line">        <span class="keyword">while</span> (length--) &#123;</div><div class="line">          <span class="keyword">try</span> &#123;</div><div class="line">            watch = watchers[length];</div><div class="line">            <span class="keyword">if</span> (watch) &#123;</div><div class="line">              get = watch.get;</div><div class="line">              <span class="keyword">if</span> ((value = get(current)) !== (last = watch.last) &amp;&amp;</div><div class="line">                  !(watch.eq</div><div class="line">                      ? equals(value, last)</div><div class="line">                      : (<span class="keyword">typeof</span> value === <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> last === <span class="string">'number'</span></div><div class="line">                         &amp;&amp; <span class="built_in">isNaN</span>(value) &amp;&amp; <span class="built_in">isNaN</span>(last)))) &#123;</div><div class="line">                           <span class="comment">// 优先使用 === 判断 value 和 last，其次再是根据他们是否为数字做 ng 的深度相等判断或者 isNaN 判断</span></div><div class="line">                dirty = <span class="literal">true</span>;</div><div class="line">                lastDirtyWatch = watch;</div><div class="line">                <span class="comment">// 如果 watch.eq 为 true，表示该 watch 的目标为对象，所以把该对象克隆到 watch.last 上面以下一次 digest 时来判断</span></div><div class="line">                <span class="comment">// 如果 watch.eq 为 false，表示该 watch 的目标为数字，所以直接赋值就可以了</span></div><div class="line">                <span class="comment">// 这里和上面一样都是为了提高速度和性能用</span></div><div class="line">                watch.last = watch.eq ? copy(value, <span class="literal">null</span>) : value;</div><div class="line">                <span class="comment">// 获取该 watch 的表达式并执行</span></div><div class="line">                fn = watch.fn;</div><div class="line">                <span class="comment">// 如果 last 和最开始的值相同则使用后者，否则使用前者。</span></div><div class="line">                fn(value, ((last === initWatchVal) ? value : last), current);</div><div class="line">                <span class="keyword">if</span> (ttl &lt; <span class="number">5</span>) &#123;</div><div class="line">                  logIdx = <span class="number">4</span> - ttl;</div><div class="line">                  <span class="keyword">if</span> (!watchLog[logIdx]) watchLog[logIdx] = [];</div><div class="line">                  watchLog[logIdx].push(&#123;</div><div class="line">                    msg: isFunction(watch.exp) ? <span class="string">'fn: '</span> + (watch.exp.name || watch.exp.toString()) : watch.exp,</div><div class="line">                    newVal: value,</div><div class="line">                    oldVal: last</div><div class="line">                  &#125;);</div><div class="line">                &#125;</div><div class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (watch === lastDirtyWatch) &#123;</div><div class="line">                dirty = <span class="literal">false</span>;</div><div class="line">                <span class="keyword">break</span> traverseScopesLoop;</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">            $exceptionHandler(e);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// Insanity Warning: scope depth-first traversal</span></div><div class="line">      <span class="comment">// yes, this code is a bit crazy, but it works and we have tests to prove it!</span></div><div class="line">      <span class="comment">// this piece should be kept in sync with the traversal in $broadcast</span></div><div class="line">      <span class="comment">// 对当前 scope 的子 scope 做遍历</span></div><div class="line">      <span class="keyword">if</span> (!(next = ((current.$$watchersCount &amp;&amp; current.$$childHead) ||</div><div class="line">          (current !== target &amp;&amp; current.$$nextSibling)))) &#123;</div><div class="line">        <span class="keyword">while</span> (current !== target &amp;&amp; !(next = current.$$nextSibling)) &#123;</div><div class="line">          current = current.$parent;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">while</span> ((current = next));</div><div class="line">    </div><div class="line">    <span class="comment">// 脏值检查未结束但此时 ttl 为 0，则抛出错误</span></div><div class="line">    <span class="keyword">if</span> ((dirty || asyncQueue.length) &amp;&amp; !(ttl--)) &#123;</div><div class="line">      clearPhase();</div><div class="line">      <span class="keyword">throw</span> $rootScopeMinErr(<span class="string">'infdig'</span>,</div><div class="line">          <span class="string">'&#123;0&#125; $digest() iterations reached. Aborting!\n'</span> +</div><div class="line">          <span class="string">'Watchers fired in the last 5 iterations: &#123;1&#125;'</span>,</div><div class="line">          TTL, watchLog);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 循环遍历直到 dirty 为 false 并且 asyncQueue.length = 0</span></div><div class="line">  &#125; <span class="keyword">while</span> (dirty || asyncQueue.length);</div><div class="line"></div><div class="line">  clearPhase();</div><div class="line"></div><div class="line">  <span class="comment">// 执行 postDigest 序列</span></div><div class="line">  <span class="keyword">while</span> (postDigestQueuePosition &lt; postDigestQueue.length) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      postDigestQueue[postDigestQueuePosition++]();</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">      $exceptionHandler(e);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  postDigestQueue.length = postDigestQueuePosition = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不过这段代码我也不是全都理解了，但是核心的算了解了。总体来看这个算法还是很简单粗暴的，这里保留了一段注释，有意思，官方吐槽的感觉。</p>
<p>由于脏检查的性能问题，在页面绑定数据较多的时候，我们应该尽量减少双向绑定的数量，比如使用 <code>ngInfiniteScroll</code> 这样的插件，适当使用单向绑定，甚至是取消一些变量的 watch 方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Angular 的脏值检查机制一直是 Angular 被人诟病的地方，但瑕不掩瑜，Angular 还是一个非常优秀的框架，并且 Angular2 也已经抛弃了这个脏值检查的算法。&lt;br&gt;最近在看《AngularJS 深度剖析与最佳实践》，不得不说是一本很好的书籍，作者在第三章开始讲背后的原理，这里分析了 Angular 的 $digest 函数，即脏检查机制。所以自己也去下载了 Angular 最新的源码去瞧了下，然后做下笔记吧。&lt;/p&gt;
&lt;p&gt;首先要注意，Angular 的 digest 的触发不是定时的，只有在指定的事件触发之后才会进入 $digest。基本上我们用的带 &lt;code&gt;$&lt;/code&gt; 的东西调用之后都可能会触发 digest。比如我们使用 &lt;code&gt;setTimeout&lt;/code&gt; 就不会触发 digest，即当你使用 &lt;code&gt;setTimeout&lt;/code&gt; 更改 viewmodel 的值后，它不会同步的反映到用户的视图中去，解决方法有两个，一个是使用 Angular 提供的 &lt;code&gt;$timeout&lt;/code&gt; 替代 &lt;code&gt;setTimeout&lt;/code&gt;，&lt;code&gt;$timeout&lt;/code&gt; 会在执行结束之后自动触发 digest； 另一个方法是手动调用 $apply，$apply 是 Angular 对 digest 的一层封装，我们一般不会直接调用 digest 而是通过使用 $apply 方法。比如对于 &lt;code&gt;setTimeout&lt;/code&gt;，我们就可以这样触发 digest。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;setTimeout(() =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  $scope.$apply(() =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    $scope.test = &lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;)    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;number&quot;&gt;500&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们看一个例子，这也是 Angular 源码 $digest 部分的一个示例。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; scope = ...;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;scope.name = &lt;span class=&quot;string&quot;&gt;&#39;misko&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;scope.counter = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;expect(scope.counter).toEqual(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;scope.$watch(&lt;span class=&quot;string&quot;&gt;&#39;name&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;newValue, oldValue&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  scope.counter = scope.counter + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;expect(scope.counter).toEqual(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 执行第一次 digest，第一次 digest 会遍历全部的 watcher，并触发上面的方法，从而使的 count+1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;scope.$digest();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;expect(scope.counter).toEqual(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 第二次调用时，由于上一次调用检查 name 不脏，所以不会再去处理&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;scope.$digest();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;expect(scope.counter).toEqual(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 第三次调用时，由于 name 发生了变化，使得当前值和上一次保存的值不同，所以会触发起 $watch 方法&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;scope.name = &lt;span class=&quot;string&quot;&gt;&#39;adam&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;scope.$digest();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;expect(scope.counter).toEqual(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Angular 的脏值检查过程大致如下：&lt;br&gt;对当前作用域和子作用域上的 &lt;code&gt;$$watchers&lt;/code&gt; 进行遍历，&lt;code&gt;$$watches&lt;/code&gt; 保存着 scope 上的所有变量以及其 &lt;code&gt;$watch&lt;/code&gt; 方法，调用时会取当前值和上一次值进行比较，如果不相等则会调用 &lt;code&gt;$watch&lt;/code&gt; 方法，同时会保存当前的值以在下一次进行比较，并且记录此次检查结果为脏。然后重复进行直到数据不脏为止，因此至少要 digest 两次，超出 10 次会报错，可以调高这个次数限制。当数据不再脏即 model 稳定下来之后， Angular 才会开始一次性批量更新 UI。从而减少了浏览器的 repaint 次数，提升性能。&lt;/p&gt;
&lt;p&gt;深入到源码来看：&lt;br&gt;
    
    </summary>
    
      <category term="Angular" scheme="https://ruiming.github.io/categories/Angular/"/>
    
    
      <category term="Angular" scheme="https://ruiming.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>项目采坑笔记</title>
    <link href="https://ruiming.github.io/2016/08/15/%E9%A1%B9%E7%9B%AE%E9%87%87%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    <id>https://ruiming.github.io/2016/08/15/项目采坑笔记/</id>
    <published>2016-08-15T08:37:19.000Z</published>
    <updated>2016-08-15T15:38:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>有段时间没写博客了，前段时间在看 Underscore 源码所以写的多了点，这段时间还是在忙自己的其他项目去了，还是有不少收获的。</p>
<h2 id="Angular-视图过渡动画"><a href="#Angular-视图过渡动画" class="headerlink" title="Angular 视图过渡动画"></a>Angular 视图过渡动画</h2><p>之前使用 <code>angular-promise-button</code> 这个模块实现了按钮的自动变化，以前自己是用很多标志位来判断特别二。不仅如此，页面切换动画也是用标志位判断，这样就特别不好维护特别不优雅，上次重构的时候就把这些全部去掉了。但是问题来了，页面数据未到达时候页面就渲染肯定会造成视觉上的问题，怎么解决呢。<br>我们都想写一些应用很广的代码，比如指令，比如上面这个 <code>angular-promise-button</code> 模块等等。其实要解决上面的问题，也是几行代码就可以解决的事情了。<br>我所使用的是 Angular 的 ui-router。ngRoute 应该也差不多。<br>在 ui-router 中可以使用 resolve 达到在控制器初始化以及视图加载前确保数据到达。比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$stateProvider</div><div class="line">    .state(<span class="string">'me'</span>,&#123;</div><div class="line">        url: <span class="string">'/me'</span>,</div><div class="line">        controller: <span class="string">'MeCtrl'</span>,</div><div class="line">        templateUrl: <span class="string">'me/me_tpl.html'</span>,</div><div class="line">        controllerAs: <span class="string">'vm'</span>,</div><div class="line">        nav: <span class="literal">true</span>,</div><div class="line">        resolve: &#123;</div><div class="line">            me: <span class="function"><span class="keyword">function</span>(<span class="params">userservice</span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> userservice.getUserInfo()</div><div class="line">                    .then(response =&gt; response);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;)</div></pre></td></tr></table></figure></p>
<p>只有 resolve 中的全部方法执行完后，才会开始初始化控制和加载视图。这个数据如果在控制器或者视图中要使用，可以在控制器中进行依赖注入。例如上面这个我的控制器是这样写的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="meta">    'use strict'</span>;</div><div class="line">    </div><div class="line">    angular</div><div class="line">        .module(<span class="string">'index'</span>)</div><div class="line">        .controller(<span class="string">'MeCtrl'</span>, MeCtrl);</div><div class="line">        </div><div class="line">    MeCtrl.$inject = [<span class="string">'me'</span>];</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">MeCtrl</span>(<span class="params">me</span>) </span>&#123;</div><div class="line">        <span class="keyword">let</span> vm = <span class="keyword">this</span>;</div><div class="line">        vm.user = me;</div><div class="line">    &#125;</div><div class="line">&#125;());</div></pre></td></tr></table></figure></p>
<p>resolve中的方法是阻塞页面进行的，这样就会带来问题了，如果数据请求比较久将导致网站停滞，我们这时候就希望可以有过渡动画出来。要达到全局过渡效果的作用，可以直接监听 <code>$rootScope</code> 中的三个状态即 <code>$stateChangeStart</code> 和 <code>$stateChangeSuccess</code> 以及 <code>$stateChangeError</code> 事件。例如上面这个例子中，当我们触发 <code>me</code> 这个 state 时，也就触发了 $rootScope 上的 <code>$stateChangeStart</code> 事件，当处理结束后将出发 <code>$stateChangeSuccess</code> 并加载视图， 处理失败就会触发 <code>$stateChangeError</code> 事件。代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">angular</div><div class="line">    .module(<span class="string">'index'</span>, [</div><div class="line">        <span class="string">'ui.router'</span>,</div><div class="line">        <span class="string">'ui.bootstrap'</span>,</div><div class="line">        <span class="string">'ngAnimate'</span>,</div><div class="line">        <span class="string">'ngSanitize'</span>,</div><div class="line">        <span class="string">'ngTouch'</span>,</div><div class="line">        <span class="string">'infinite-scroll'</span>,</div><div class="line">        <span class="string">'angularPromiseButtons'</span></div><div class="line">    ])</div><div class="line">    .config(config)</div><div class="line">    .run(($state,$rootScope) =&gt; &#123;</div><div class="line">        $rootScope.$state = $state;</div><div class="line">        $rootScope.$on(<span class="string">"$stateChangeStart"</span>, (event, toState, toStateParams, fromState, fromStateParams) =&gt; &#123;</div><div class="line">            <span class="keyword">var</span> isLoading = toState.resolve;</div><div class="line">            <span class="keyword">if</span>(!isLoading) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> toState.views) &#123;</div><div class="line">                    <span class="keyword">if</span> (toState.views.hasOwnProperty(prop)) &#123;</div><div class="line">                        <span class="keyword">if</span>(toState.views[prop].resolve) &#123;</div><div class="line">                            isLoading = <span class="literal">true</span>;</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (isLoading) &#123;</div><div class="line">                $rootScope.loading = <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        $rootScope.$on(<span class="string">"$stateChangeSuccess"</span>, (event, toState, toParams, fromState, fromParams) =&gt; &#123;</div><div class="line">            $rootScope.loading = <span class="literal">false</span>;</div><div class="line">        &#125;);</div><div class="line">        $rootScope.$on(<span class="string">"$stateChangeError"</span>, (event, toState, toParams, fromState, fromParams, error) =&gt; &#123;</div><div class="line">            $rootScope.loading = <span class="literal">false</span>;</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p>
<p>入口页面，省去了其他代码，这里第一行就是视图，第二行是加载动画，通过ng-show来控制显示。第三行是引入导航栏，这个在后面会说下。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span> <span class="attr">class</span>=<span class="string">"uiview"</span> <span class="attr">ng-show</span>=<span class="string">"!$root.loading"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cssload-thecube"</span> <span class="attr">ng-show</span>=<span class="string">"$root.loading"</span>&gt;</span> loading... <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-show</span>=<span class="string">"$state.current.nav"</span> <span class="attr">ng-include</span>=<span class="string">"'navbar/navbar_tpl.html'"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>可以看到上面的代码中是监听了 <code>$stateChangeStart</code> 事件，然后获取目标 state 上的 resolve 方法，当 state 上的 resolve 方法全部结束后，<code>$rootScope.loading</code> 设置为 false，否则保持为 true。<br>当监听到 <code>$stateChangeSuccess</code> 或者 <code>$stateChangeError</code> 事件时，置 <code>$rootScope.loading</code> 为 false，退出过渡动画。在视图中可以使用 <code>$root</code> 得到 <code>$rootScope</code>。<br>可以看到这里有很多参数，可见其功能是很强大的。<br><a id="more"></a><br>再看下上面这个第三行<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-show</span>=<span class="string">"$state.current.nav"</span> <span class="attr">ng-include</span>=<span class="string">"'navbar/navbar_tpl.html'"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>结合上面的 JS 代码来看，我已经把 <code>$state</code> 注入到了 <code>$rootScope</code> 中了，之后我就可以使用 <code>$state.current</code> 来获取当前的视图状态和信息。我需要实现导航栏仅仅出现在我指定的页面中，下方按钮可以根据当前视图来激活。第一点可以通过给路由 state 补充变量比如我这里的 <code>nav</code> 来实现，需要导航栏的地方就设置 <code>nav</code> 为 true, 否则就不设置。第二点则可以利用 <code>ui-sref-active</code> 来实现。如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- navbar/navbar_tpl.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"bookist-nav navbar navbar-default"</span> <span class="attr">role</span>=<span class="string">"navigation"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"nav navbar-nav"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">ui-sref-active</span>=<span class="string">"active"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">ui-sref</span>=<span class="string">"index"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-home fa-lg"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">ui-sref-active</span>=<span class="string">"active"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">ui-sref</span>=<span class="string">"booklists"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-th-large fa-lg"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>书单<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">ui-sref-active</span>=<span class="string">"active"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">ui-sref</span>=<span class="string">"cart"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-shopping-cart fa-lg"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>购物车<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">ui-sref-active</span>=<span class="string">"active"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">ui-sref</span>=<span class="string">"me"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-user fa-lg"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>我的<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>最后还有一个地方就是，下面这个代码<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span> <span class="attr">class</span>=<span class="string">"uiview"</span> <span class="attr">ng-show</span>=<span class="string">"!$root.loading"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>ui-view 的用法其实还不少，如果你有去注意的话，会看到这个视图在变化的时候其类名会变化，依次我们可以结合 angular-animate 来实现切换动画。注意这个切换动画是在视图加载后才开始的，和上面的不一样，如果同时使用，则会在上方过渡效果结束后触发。例如，我们可以实现淡入淡出：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.uiview &#123;</div><div class="line">  &amp;.ng-enter &#123;</div><div class="line">    transition: .5s;</div><div class="line">    opacity: 0;</div><div class="line">  &#125;</div><div class="line">  &amp;.ng-enter-active &#123;</div><div class="line">    opacity: 1;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以上面其实说了好几点：</p>
<ul>
<li>使用路由上的 resolve 来实现在控制器初始化前获取到需要的数据</li>
<li>监听 $rootScope 上的事件来实现 resolve 等待动画</li>
<li>在 ui-view 上通过使用 angular-animate 来实现视图的切换动画</li>
<li>通过 ui-sref-active 在当 ui-sref 和当前 state 一致时激活 active 类名</li>
<li>把 $state 注入到 $rootScope 达到在视图中获取 $state 用途</li>
<li>使用 $root 得到 $rootScope，利用 $root 获取 $rootScope 上的对象</li>
</ul>
<h2 id="静态资源自动发布七牛云"><a href="#静态资源自动发布七牛云" class="headerlink" title="静态资源自动发布七牛云"></a>静态资源自动发布七牛云</h2><p>这个很简单啦，我使用了 gulp-qiniu 这个模块来实现，很简单，结合前面说的 gulp-usemin 就更完美了。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- build:js //cdn.bookist.org/bookist.min.js --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"src/js/bookist.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"src/js/templates.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- endbuild --&gt;</span></div></pre></td></tr></table></figure></p>
<p>例如对上面 index.html 中的这一片段，我们要在开发环境中使用本地资源，而在线上环境则使用 CDN 资源。我们可以这样配置 gulpfile。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">gulp</span><span class="selector-class">.task</span>(<span class="string">'cdn'</span>, () =&gt; &#123;</div><div class="line">    gulp<span class="selector-class">.src</span>(<span class="string">'index.html'</span>)</div><div class="line">        <span class="selector-class">.pipe</span>(usemin())</div><div class="line">        <span class="selector-class">.pipe</span>(gulp.dest(<span class="string">'backend/app/templates'</span>));</div><div class="line">    <span class="selector-tag">gulp</span><span class="selector-class">.src</span>([<span class="string">'./src/js/bookist.js'</span>, <span class="string">'./src/js/templates.js'</span>])</div><div class="line">        <span class="selector-class">.pipe</span>(plumber())</div><div class="line">        <span class="selector-class">.pipe</span>(uglify())</div><div class="line">        <span class="selector-class">.pipe</span>(babel())</div><div class="line">        <span class="selector-class">.pipe</span>(concat(<span class="string">'bookist.min.js'</span>))</div><div class="line">        <span class="selector-class">.pipe</span>(qiniu(&#123;</div><div class="line">            <span class="attribute">accessKey</span>: <span class="string">"xxx"</span>,</div><div class="line">            <span class="attribute">secretKey</span>: <span class="string">"xxx"</span>,</div><div class="line">            <span class="attribute">bucket</span>: <span class="string">"bookist"</span>,</div><div class="line">            <span class="attribute">private</span>: false</div><div class="line">        &#125;));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行上面的任务后就会在 <code>backend/app/templates</code> 生成一个修改过的 index.html。对于上面的片段，处理之后是这样的：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.bookist.org/bookist.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>前面的注释是给 usemin 使用的，所以要按照规范书写。<br>同时上面的任务也会把资源发布到七牛云上面，如果你还想指定文件头或者版本号之类的信息，可以参考 gulp-qiniu 的文档进行配置。<br>上面的方法有一个小问题就是还会在 <code>backend/app/templates</code> 生成一个 <code>cdn.bookist.org</code> 的文件夹，不过无所谓咯，放到 .gitignore 就好了。<br>至于图片和 css 都差不多吧，就不多说了。</p>
<h2 id="微信坑逼"><a href="#微信坑逼" class="headerlink" title="微信坑逼"></a>微信坑逼</h2><p>有段时间我的网站在微信显示部分地方是有问题的，但在手机浏览器和电脑都没任何问题，一开始以为是样式的问题。等到自己要去解决这个问题了，才知道是 js 的问题。<br>由于微信开发工具不支持 linux，然后我虚拟机的 win10 有不知道什么原因一直连接不到手机。所以就手动调试了，这边改一点，发布上去，然后等微信缓存没了看效果(微信恶心的缓存…我都叫用苹果的人帮我看，因为苹果可以刷新..)。就这样一步步看，最后定位了问题代码。中间过程就不描述了，直接看：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> book <span class="keyword">of</span> books) &#123;</div><div class="line">    <span class="keyword">if</span>(book.rate)   book.star = <span class="built_in">Math</span>.ceil(book.rate/<span class="number">2</span>);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(book.star)   book.star = <span class="built_in">Math</span>.ceil(book.star/<span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>省略了无关代码，这是一个方法里面的部分代码，如果一个对象传入这个方法中，在微信会得不到返回值，在手机浏览器和电脑上都正常。<br>虽然这里使用了 ES6 的语法，但是我其实已经大量使用 let…of… 语句，项目并没有出现太大问题，就只是上面描述的一些地方异常而已。再者我使用了 babel 转码了。越想越觉得没道理啊。。。<br>最后虚拟机换了 win7 然后手机连接上了，打开了微信开发工具，调试微信 webview，报错 <code>Symbol is not defined</code>。<br>果断控制台敲 Symbol，结果 <code>Symbol is not defined</code>。<br>好吧，问题出来了，微信这个辣鸡不支持 Symbol…<br>但问题是我没有用 Symbol 这个东西啊，我瞄了 babel 一眼。<br>看下上面那段代码转码的结果：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _iteratorNormalCompletion5 = <span class="literal">true</span>;</div><div class="line"><span class="keyword">var</span> _didIteratorError5 = <span class="literal">false</span>;</div><div class="line"><span class="keyword">var</span> _iteratorError5 = <span class="literal">undefined</span>;</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> _iterator5 = books[<span class="built_in">Symbol</span>.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = <span class="literal">true</span>) &#123;</div><div class="line">        <span class="keyword">var</span> book = _step5.value;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (book.rate) book.star = <span class="built_in">Math</span>.ceil(book.rate / <span class="number">2</span>);<span class="keyword">else</span> <span class="keyword">if</span> (book.star) book.star = <span class="built_in">Math</span>.ceil(book.star / <span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">    _didIteratorError5 = <span class="literal">true</span>;</div><div class="line">    _iteratorError5 = err;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (!_iteratorNormalCompletion5 &amp;&amp; _iterator5.return) &#123;</div><div class="line">            _iterator5.return();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (_didIteratorError5) &#123;</div><div class="line">            <span class="keyword">throw</span> _iteratorError5;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>什么鬼…算了，不看了，但是确定了是 babel 转码导致的。然后查了下资料：</p>
<blockquote>
<p>Babel默认只转换新的JavaScript句法(syntax)，而不转换新的API，比如Iterator, Generator, Set, Maps, Proxy, Reflect, Symbol, Promise等全局对象，以及一些定义在全局对象上的方法(比如Object.assign)都不会转码。</p>
</blockquote>
<p>其实早有耳闻 polyfill 这个东西，但我想他一般是用在 IE 这种辣鸡浏览器上的，没想到微信 webview 这么不争气。<br>多打包一个 babel-polyfill 解决了这个问题。<br>坑比微信…</p>
<p>故事还没结束…<br>昨天发现网站并没有使用 http2，但是已经进行了设置了，最后查了很多资料原因好像是 openssl 的问题，但由于使用的是 docker，貌似不太好搞，但其实更换 nginx 版本就好了，原先是1.9版本，换成1.11-alpine 版就解决了，用 docker 更换 nginx 版本非常方便。额，具体原因不深究了，可能跟 alpine 这个字眼有关？不清楚…<br>http2 具备多路复用的特点，在 http1.1 中，并行传输文件是有限制的，因为用户端和服务端的最大连接数是有限制的，而连接的建立和销毁又会带来开销，所以在 http1.1 中对文件进行压缩合并是很有必要的。不过在 http2 就不需要这样做了，http2 可以在一条通道上传输多个文件，如果合并剩几个，就没法发挥并行传输的优势，而且文件太大，还会降低运输层的效率，即丢包或者乱序到达的影响。<br>我把网站改到了 http2 后，就不再进行文件合并了，转而可以大量使用 bootcss 的 CDN，bootcss 的 CDN 支持 http2，传输很快。至于上面没有的和自己写的，就发布到七牛云上面。恩，电脑上加载是变快了很多。<br>但是感觉不到微信加载变快…最后发现是微信不支持 http2…<br>好伤心…<br>最后我的方案是产生两个 css 文件和两个 js 文件，之所以是两个，因为一个是自己写的，经常变，另一个是用别人的，几乎不会变。</p>
<p>最后又发现微信好像支持 spdy… 心好累，算了，降了 nginx 版本开启 spdy 不理了。</p>
<hr>
<p>总结：</p>
<ul>
<li>Angular 是一个大而全的框架，我觉得很强大很牛逼，越来越喜欢 Angular 了</li>
<li>使用 CDN 可以大大的加速，尽量使用 CDN</li>
<li>微信这个坑比我就不说了，不支持 Symbol 不支持 http2</li>
<li>能用 http2 就尽量用 http2</li>
<li>考虑浏览器兼容性，根据需要引入 babel-polyfill</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有段时间没写博客了，前段时间在看 Underscore 源码所以写的多了点，这段时间还是在忙自己的其他项目去了，还是有不少收获的。&lt;/p&gt;
&lt;h2 id=&quot;Angular-视图过渡动画&quot;&gt;&lt;a href=&quot;#Angular-视图过渡动画&quot; class=&quot;headerlink&quot; title=&quot;Angular 视图过渡动画&quot;&gt;&lt;/a&gt;Angular 视图过渡动画&lt;/h2&gt;&lt;p&gt;之前使用 &lt;code&gt;angular-promise-button&lt;/code&gt; 这个模块实现了按钮的自动变化，以前自己是用很多标志位来判断特别二。不仅如此，页面切换动画也是用标志位判断，这样就特别不好维护特别不优雅，上次重构的时候就把这些全部去掉了。但是问题来了，页面数据未到达时候页面就渲染肯定会造成视觉上的问题，怎么解决呢。&lt;br&gt;我们都想写一些应用很广的代码，比如指令，比如上面这个 &lt;code&gt;angular-promise-button&lt;/code&gt; 模块等等。其实要解决上面的问题，也是几行代码就可以解决的事情了。&lt;br&gt;我所使用的是 Angular 的 ui-router。ngRoute 应该也差不多。&lt;br&gt;在 ui-router 中可以使用 resolve 达到在控制器初始化以及视图加载前确保数据到达。比如：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$stateProvider&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    .state(&lt;span class=&quot;string&quot;&gt;&#39;me&#39;&lt;/span&gt;,&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        url: &lt;span class=&quot;string&quot;&gt;&#39;/me&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        controller: &lt;span class=&quot;string&quot;&gt;&#39;MeCtrl&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        templateUrl: &lt;span class=&quot;string&quot;&gt;&#39;me/me_tpl.html&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        controllerAs: &lt;span class=&quot;string&quot;&gt;&#39;vm&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        nav: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        resolve: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            me: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;userservice&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; userservice.getUserInfo()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    .then(response =&amp;gt; response);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;只有 resolve 中的全部方法执行完后，才会开始初始化控制和加载视图。这个数据如果在控制器或者视图中要使用，可以在控制器中进行依赖注入。例如上面这个我的控制器是这样写的：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;    &#39;use strict&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    angular&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        .module(&lt;span class=&quot;string&quot;&gt;&#39;index&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        .controller(&lt;span class=&quot;string&quot;&gt;&#39;MeCtrl&#39;&lt;/span&gt;, MeCtrl);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    MeCtrl.$inject = [&lt;span class=&quot;string&quot;&gt;&#39;me&#39;&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MeCtrl&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;me&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; vm = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        vm.user = me;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;());&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;resolve中的方法是阻塞页面进行的，这样就会带来问题了，如果数据请求比较久将导致网站停滞，我们这时候就希望可以有过渡动画出来。要达到全局过渡效果的作用，可以直接监听 &lt;code&gt;$rootScope&lt;/code&gt; 中的三个状态即 &lt;code&gt;$stateChangeStart&lt;/code&gt; 和 &lt;code&gt;$stateChangeSuccess&lt;/code&gt; 以及 &lt;code&gt;$stateChangeError&lt;/code&gt; 事件。例如上面这个例子中，当我们触发 &lt;code&gt;me&lt;/code&gt; 这个 state 时，也就触发了 $rootScope 上的 &lt;code&gt;$stateChangeStart&lt;/code&gt; 事件，当处理结束后将出发 &lt;code&gt;$stateChangeSuccess&lt;/code&gt; 并加载视图， 处理失败就会触发 &lt;code&gt;$stateChangeError&lt;/code&gt; 事件。代码如下：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;angular&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    .module(&lt;span class=&quot;string&quot;&gt;&#39;index&#39;&lt;/span&gt;, [&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;ui.router&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;ui.bootstrap&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;ngAnimate&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;ngSanitize&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;ngTouch&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;infinite-scroll&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;angularPromiseButtons&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    .config(config)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    .run(($state,$rootScope) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        $rootScope.$state = $state;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        $rootScope.$on(&lt;span class=&quot;string&quot;&gt;&quot;$stateChangeStart&quot;&lt;/span&gt;, (event, toState, toStateParams, fromState, fromStateParams) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; isLoading = toState.resolve;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!isLoading) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; prop &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; toState.views) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (toState.views.hasOwnProperty(prop)) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(toState.views[prop].resolve) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                            isLoading = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isLoading) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                $rootScope.loading = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        $rootScope.$on(&lt;span class=&quot;string&quot;&gt;&quot;$stateChangeSuccess&quot;&lt;/span&gt;, (event, toState, toParams, fromState, fromParams) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            $rootScope.loading = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        $rootScope.$on(&lt;span class=&quot;string&quot;&gt;&quot;$stateChangeError&quot;&lt;/span&gt;, (event, toState, toParams, fromState, fromParams, error) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            $rootScope.loading = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;入口页面，省去了其他代码，这里第一行就是视图，第二行是加载动画，通过ng-show来控制显示。第三行是引入导航栏，这个在后面会说下。&lt;br&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ui-view&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;uiview&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ng-show&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;!$root.loading&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;cssload-thecube&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ng-show&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;$root.loading&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt; loading... &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ng-show&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;$state.current.nav&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ng-include&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;&#39;navbar/navbar_tpl.html&#39;&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看到上面的代码中是监听了 &lt;code&gt;$stateChangeStart&lt;/code&gt; 事件，然后获取目标 state 上的 resolve 方法，当 state 上的 resolve 方法全部结束后，&lt;code&gt;$rootScope.loading&lt;/code&gt; 设置为 false，否则保持为 true。&lt;br&gt;当监听到 &lt;code&gt;$stateChangeSuccess&lt;/code&gt; 或者 &lt;code&gt;$stateChangeError&lt;/code&gt; 事件时，置 &lt;code&gt;$rootScope.loading&lt;/code&gt; 为 false，退出过渡动画。在视图中可以使用 &lt;code&gt;$root&lt;/code&gt; 得到 &lt;code&gt;$rootScope&lt;/code&gt;。&lt;br&gt;可以看到这里有很多参数，可见其功能是很强大的。&lt;br&gt;
    
    </summary>
    
      <category term="Angular" scheme="https://ruiming.github.io/categories/Angular/"/>
    
    
      <category term="Angular" scheme="https://ruiming.github.io/tags/Angular/"/>
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 JavaScript 模块定义规范</title>
    <link href="https://ruiming.github.io/2016/08/06/%E6%B5%85%E8%B0%88JavaScript%E6%A8%A1%E5%9D%97%E5%AE%9A%E4%B9%89%E8%A7%84%E8%8C%83/"/>
    <id>https://ruiming.github.io/2016/08/06/浅谈JavaScript模块定义规范/</id>
    <published>2016-08-06T14:28:35.000Z</published>
    <updated>2016-08-06T14:31:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>JS 模块定义常见的有三种方式，即 AMD, CMD 和 CommonJS。其实还有一个 UMD，他是 CommonJS 和 AMD 揉和在一起而已。不过这些都 out 了，拥抱 ES6 吧。话虽这么说，你让那些不用 ES6 不用 babel 的怎么活，所以还是要了解下滴。</p>
<h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>CommonJS 是服务端即 Node.js 采用的模块化方案，我们应该都很熟悉了。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line">fs.readFileSync();</div></pre></td></tr></table></figure></p>
<p>这个过程是同步的，只有成功加载 <code>fs</code> 后才能执行后面的步骤。但在服务器文件都在本地，所以这个问题不大。但这个在浏览器就不合适了，如果文件加载耗时很长，将导致一直等待。</p>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>AMD 全称 Asynchronous Module Definition，意思就是异步模块定义。<br>用法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">math</span>) </span>&#123;</div><div class="line">    math.add(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>math 模块的加载和 <code>math.add()</code> 方法的执行不是同步的，这样浏览器就不会假死。<br>RequireJs 和 CurlJs 实现了 AMD 规范，将他们嵌入网页，就可以在浏览器端进行模块化编程了。<br>关于 AMD 的详细模块定义可以参考<a href="https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88" target="_blank" rel="external">wiki</a>)。这里给出 Underscore 的 AMD 定义方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> define == <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</div><div class="line">    define(<span class="string">'underscore'</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> _;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>CMD 全称 Common Module Definition，意思就是通用模块定义。。<br>对于依赖的模块，AMD 是提前执行，而 CMD 是延迟执行。AMD 推崇依赖前置，而 CMD 则推崇依赖就近。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> math = <span class="built_in">require</span>(<span class="string">'./math'</span>);</div><div class="line">    math.add(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>CMD 的主要实现是 SeaJS<br>AMD 预先加载所有依赖，使用的时候才去执行，速度快，可以并行加载多个模块。但这就需要开发的时候把全部依赖都提前定义，不便于开发和阅读，而且部分依赖（弱依赖）可能只在少数情况下使用。<br>CMD 只有在真正需要的时候才去加载依赖，使用的时候才去定义执行，但这个加载逻辑偏重，耗性能。</p>
<h2 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h2><p>UMD 全称 Universal Module Definition。<br>UMD 是 AMD 和 CommonJS 的揉和，他优先使用 CommonJS 的加载方式，其次才使用 AMD 的加载方式。<br>例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">window, factory</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">'object'</span>) &#123;</div><div class="line">     </div><div class="line">        <span class="built_in">module</span>.exports = factory();</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</div><div class="line">     </div><div class="line">        define(factory);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">     </div><div class="line">        <span class="built_in">window</span>.eventUtil = factory();</div><div class="line">    &#125;</div><div class="line">&#125;)(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//module ...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>其实就是一个服务端和浏览端通用的模块解决方案。</p>
<h2 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h2><p>ES6 在语言规格的层面上实现了模块功能，并且实现非常简单，完全可以替代现有的模块加载方案，成为浏览器和服务端都通用的模块解决方案。<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;stat, exists, readFile&#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</div></pre></td></tr></table></figure></p>
<p>这种做法将只在 fs 模块加载3个方法，其他方法不会进行加载。ES6 可以在编译时就完成模块加载，效率比 CommonJS 的加载方式高。<br>在浏览器中使用 ES6 模块的语法：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"foo.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>目前 Node 默认模块格式是 CommonJS，ES6 的模块方案还不支持，但可以通过 babel 来使用。</p>
<p>现在推荐做法是广泛使用 ES6 甚至 ES7 来书写 JavaScript 以提高开发效率，再使用 babel 转码就好了。所以前后端我们也都可以使用 ES6 的 Module 来进行。其他的模块加载方案应该会渐渐退出历史舞台。</p>
<hr>
<p><a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="external">ECMAScript6 入门 Module</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS 模块定义常见的有三种方式，即 AMD, CMD 和 CommonJS。其实还有一个 UMD，他是 CommonJS 和 AMD 揉和在一起而已。不过这些都 out 了，拥抱 ES6 吧。话虽这么说，你让那些不用 ES6 不用 babel 的怎么活，所以还是要了解下滴。&lt;/p&gt;
&lt;h2 id=&quot;CommonJS&quot;&gt;&lt;a href=&quot;#CommonJS&quot; class=&quot;headerlink&quot; title=&quot;CommonJS&quot;&gt;&lt;/a&gt;CommonJS&lt;/h2&gt;&lt;p&gt;CommonJS 是服务端即 Node.js 采用的模块化方案，我们应该都很熟悉了。例如：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; fs = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;fs&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;fs.readFileSync();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个过程是同步的，只有成功加载 &lt;code&gt;fs&lt;/code&gt; 后才能执行后面的步骤。但在服务器文件都在本地，所以这个问题不大。但这个在浏览器就不合适了，如果文件加载耗时很长，将导致一直等待。&lt;/p&gt;
&lt;h2 id=&quot;AMD&quot;&gt;&lt;a href=&quot;#AMD&quot; class=&quot;headerlink&quot; title=&quot;AMD&quot;&gt;&lt;/a&gt;AMD&lt;/h2&gt;&lt;p&gt;AMD 全称 Asynchronous Module Definition，意思就是异步模块定义。&lt;br&gt;用法如下：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;([&lt;span class=&quot;string&quot;&gt;&#39;math&#39;&lt;/span&gt;], &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;math&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    math.add(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;math 模块的加载和 &lt;code&gt;math.add()&lt;/code&gt; 方法的执行不是同步的，这样浏览器就不会假死。&lt;br&gt;RequireJs 和 CurlJs 实现了 AMD 规范，将他们嵌入网页，就可以在浏览器端进行模块化编程了。&lt;br&gt;关于 AMD 的详细模块定义可以参考&lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88&quot;&gt;wiki&lt;/a&gt;)。这里给出 Underscore 的 AMD 定义方法：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; define == &lt;span class=&quot;string&quot;&gt;&#39;function&#39;&lt;/span&gt; &amp;amp;&amp;amp; define.amd) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    define(&lt;span class=&quot;string&quot;&gt;&#39;underscore&#39;&lt;/span&gt;, [], &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;CMD&quot;&gt;&lt;a href=&quot;#CMD&quot; class=&quot;headerlink&quot; title=&quot;CMD&quot;&gt;&lt;/a&gt;CMD&lt;/h2&gt;&lt;p&gt;CMD 全称 Common Module Definition，意思就是通用模块定义。。&lt;br&gt;对于依赖的模块，AMD 是提前执行，而 CMD 是延迟执行。AMD 推崇依赖前置，而 CMD 则推崇依赖就近。例如：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;define(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;require, exports, module&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; math = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;./math&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    math.add(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;CMD 的主要实现是 SeaJS&lt;br&gt;AMD 预先加载所有依赖，使用的时候才去执行，速度快，可以并行加载多个模块。但这就需要开发的时候把全部依赖都提前定义，不便于开发和阅读，而且部分依赖（弱依赖）可能只在少数情况下使用。&lt;br&gt;CMD 只有在真正需要的时候才去加载依赖，使用的时候才去定义执行，但这个加载逻辑偏重，耗性能。&lt;/p&gt;
&lt;h2 id=&quot;UMD&quot;&gt;&lt;a href=&quot;#UMD&quot; class=&quot;headerlink&quot; title=&quot;UMD&quot;&gt;&lt;/a&gt;UMD&lt;/h2&gt;&lt;p&gt;UMD 全称 Universal Module Definition。&lt;br&gt;UMD 是 AMD 和 CommonJS 的揉和，他优先使用 CommonJS 的加载方式，其次才使用 AMD 的加载方式。&lt;br&gt;例如：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;window, factory&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; exports === &lt;span class=&quot;string&quot;&gt;&#39;object&#39;&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = factory();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; define === &lt;span class=&quot;string&quot;&gt;&#39;function&#39;&lt;/span&gt; &amp;amp;&amp;amp; define.amd) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        define(factory);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.eventUtil = factory();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//module ...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其实就是一个服务端和浏览端通用的模块解决方案。&lt;/p&gt;
&lt;h2 id=&quot;ES6-Module&quot;&gt;&lt;a href=&quot;#ES6-Module&quot; class=&quot;headerlink&quot; title=&quot;ES6 Module&quot;&gt;&lt;/a&gt;ES6 Module&lt;/h2&gt;&lt;p&gt;ES6 在语言规格的层面上实现了模块功能，并且实现非常简单，完全可以替代现有的模块加载方案，成为浏览器和服务端都通用的模块解决方案。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://ruiming.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Underscore 源码学习(七)</title>
    <link href="https://ruiming.github.io/2016/08/06/Underscore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0(%E4%B8%83)/"/>
    <id>https://ruiming.github.io/2016/08/06/Underscore源码学习(七)/</id>
    <published>2016-08-06T07:53:18.000Z</published>
    <updated>2016-08-06T13:03:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>Underscore 中间 flatten 相关的方法之前一直不是很理解，现在完全搞懂了，稍微说一下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> flatten = <span class="function"><span class="keyword">function</span>(<span class="params">input, shallow, strict, output</span>) </span>&#123;</div><div class="line">    output = output || [];</div><div class="line">    <span class="keyword">var</span> idx = output.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = getLength(input); i &lt; length; i++) &#123;</div><div class="line">        <span class="keyword">var</span> value = input[i];</div><div class="line">        <span class="comment">// 若value为数组，把里面东西去出来赋值给output</span></div><div class="line">        <span class="comment">// 否则直接赋值给output</span></div><div class="line">        <span class="comment">// isArrayLike的判断可以去掉，保留的原因是因为他用来判断value是否为数组很快，可以迅速筛选掉非数组</span></div><div class="line">        <span class="keyword">if</span> (isArrayLike(value) &amp;&amp; (_.isArray(value) || _.isArguments(value))) &#123;</div><div class="line">        <span class="comment">// Flatten current level of array or arguments object.</span></div><div class="line">        <span class="keyword">if</span> (shallow) &#123;</div><div class="line">            <span class="comment">// 如果给了shallow参数，只只遍历一层</span></div><div class="line">            <span class="keyword">var</span> j = <span class="number">0</span>, len = value.length;</div><div class="line">            <span class="keyword">while</span> (j &lt; len) output[idx++] = value[j++];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 一直遍历下去，如果是元素则按下面赋值，如果是数组则继续遍历</span></div><div class="line">            flatten(value, shallow, strict, output);</div><div class="line">            idx = output.length;</div><div class="line">        &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strict) &#123;</div><div class="line">        output[idx++] = value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> output;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个方法不难看懂，作用是将input平铺展开，如果 <code>shallow</code> 为 <code>true</code>，则只展开一层。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_.flatten([<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>], [[<span class="number">4</span>, [<span class="number">5</span>]]]])              <span class="comment">// [1, 2, 3, 4, 5]</span></div><div class="line">_.flatten([<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>], [[<span class="number">4</span>, [<span class="number">5</span>]]]], <span class="literal">true</span>)        <span class="comment">// [1, 2, 3, [4, [5]]]</span></div></pre></td></tr></table></figure></p>
<p>这里的 <code>strict</code> 参数就是之前一直卡住的原因，就是下面这个地方：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">_.without = restArgs(<span class="function"><span class="keyword">function</span>(<span class="params">array, otherArrays</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> _.difference(array, otherArrays);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">_.difference = restArgs(<span class="function"><span class="keyword">function</span>(<span class="params">array, rest</span>) </span>&#123;</div><div class="line">    rest = flatten(rest, <span class="literal">true</span>, <span class="literal">true</span>);</div><div class="line">    <span class="comment">// 遍历array，如果array中一个元素包含在rest中，则去掉该元素</span></div><div class="line">    <span class="keyword">return</span> _.filter(array, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> !_.contains(rest, value);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这是两个方法，那时候想 <code>without</code> 方法调用的时候, <code>otherArrays</code>是一个数组了，到 <code>difference</code> 方法的时候，这个数组去调用 <code>flatten</code> 方法的时候不是会出问题吗？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_.flatten([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="literal">true</span>, <span class="literal">true</span>)        <span class="comment">// []</span></div></pre></td></tr></table></figure></p>
<p>脑子里面就这样想…卡了好久，等我基本看了全部源码才会过来看才理解了。<br><code>difference</code> 方法的 <code>restArgs</code> 很重要，他们两个是各自独立的方法，但是 <code>without</code> 可以共用 <code>difference</code> 的逻辑。<br>上面那样子理解是有问题的，因为在 <code>without</code> 方法中 <code>otherArrays</code> 如果是[1, 2, 3]，到了 <code>flatten</code> 调用的时候因为 <code>restArgs</code> 的关系他变成了 [[1, 2, 3]]，调用最后返回结果[1, 2, 3]。然后我就纳闷了，加了一层又解除这是何解…<br>不过抛开 <code>without</code> 方法去看 <code>difference</code> 方法就能理解了。<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">_.without([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line"><span class="comment">// 1, 2, 3通过restArgs变为[1, 2, 3]，传入difference方法</span></div><div class="line"><span class="comment">// [1, 2, 3]通过restArgs变为[[1, 2, 3]]，传入flatten方法</span></div><div class="line"><span class="comment">// 返回[1, 2, 3]，剩下的可以看懂了不解释</span></div><div class="line"><span class="comment">// 之所以shallow和strict都为true，是因为不需要两个数组即使内容一样他们也是不想等的，</span></div><div class="line"><span class="comment">// 不需要进行处理，所以没必要展开</span></div><div class="line">_.difference([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>]);</div><div class="line"><span class="comment">// [1, 2], [3]通过restArgs变为[1, 2, 3]，传入difference方法，其余同</span></div></pre></td></tr></table></figure></p>
<p>所以其实 <code>difference</code> 方法的 <code>restArgs</code> 虽然对与 <code>without</code> 方法中的调用是多余的，但是作为一个独立的方法，他还是有必要的。<br>上面注释应该说的很清楚了，完。</p>
<p>其实只是我自己没看清楚而已，也不难。这个地方的很多方法比如 <code>union</code>, <code>intersection</code>等等都是集合的相关操作。比如 <code>difference</code> 就是差集，<code>union</code> 就是并集，而<code>intersection</code> 就是交集。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Underscore 中间 flatten 相关的方法之前一直不是很理解，现在完全搞懂了，稍微说一下。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; flatten = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;input, shallow, strict, output&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    output = output || [];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; idx = output.length;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, length = getLength(input); i &amp;lt; length; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; value = input[i];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 若value为数组，把里面东西去出来赋值给output&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 否则直接赋值给output&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// isArrayLike的判断可以去掉，保留的原因是因为他用来判断value是否为数组很快，可以迅速筛选掉非数组&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isArrayLike(value) &amp;amp;&amp;amp; (_.isArray(value) || _.isArguments(value))) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Flatten current level of array or arguments object.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (shallow) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 如果给了shallow参数，只只遍历一层&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, len = value.length;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (j &amp;lt; len) output[idx++] = value[j++];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 一直遍历下去，如果是元素则按下面赋值，如果是数组则继续遍历&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            flatten(value, shallow, strict, output);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            idx = output.length;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!strict) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        output[idx++] = value;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; output;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个方法不难看懂，作用是将input平铺展开，如果 &lt;code&gt;shallow&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt;，则只展开一层。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;_.flatten([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;], [[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, [&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]]]])              &lt;span class=&quot;comment&quot;&gt;// [1, 2, 3, 4, 5]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;_.flatten([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;], [[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, [&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]]]], &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;)        &lt;span class=&quot;comment&quot;&gt;// [1, 2, 3, [4, [5]]]&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里的 &lt;code&gt;strict&lt;/code&gt; 参数就是之前一直卡住的原因，就是下面这个地方：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;_.without = restArgs(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;array, otherArrays&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _.difference(array, otherArrays);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;_.difference = restArgs(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;array, rest&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    rest = flatten(rest, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 遍历array，如果array中一个元素包含在rest中，则去掉该元素&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _.filter(array, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;value&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; !_.contains(rest, value);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这是两个方法，那时候想 &lt;code&gt;without&lt;/code&gt; 方法调用的时候, &lt;code&gt;otherArrays&lt;/code&gt;是一个数组了，到 &lt;code&gt;difference&lt;/code&gt; 方法的时候，这个数组去调用 &lt;code&gt;flatten&lt;/code&gt; 方法的时候不是会出问题吗？&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;_.flatten([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;], &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;)        &lt;span class=&quot;comment&quot;&gt;// []&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;脑子里面就这样想…卡了好久，等我基本看了全部源码才会过来看才理解了。&lt;br&gt;&lt;code&gt;difference&lt;/code&gt; 方法的 &lt;code&gt;restArgs&lt;/code&gt; 很重要，他们两个是各自独立的方法，但是 &lt;code&gt;without&lt;/code&gt; 可以共用 &lt;code&gt;difference&lt;/code&gt; 的逻辑。&lt;br&gt;上面那样子理解是有问题的，因为在 &lt;code&gt;without&lt;/code&gt; 方法中 &lt;code&gt;otherArrays&lt;/code&gt; 如果是[1, 2, 3]，到了 &lt;code&gt;flatten&lt;/code&gt; 调用的时候因为 &lt;code&gt;restArgs&lt;/code&gt; 的关系他变成了 [[1, 2, 3]]，调用最后返回结果[1, 2, 3]。然后我就纳闷了，加了一层又解除这是何解…&lt;br&gt;不过抛开 &lt;code&gt;without&lt;/code&gt; 方法去看 &lt;code&gt;difference&lt;/code&gt; 方法就能理解了。&lt;br&gt;
    
    </summary>
    
      <category term="Underscore" scheme="https://ruiming.github.io/categories/Underscore/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="Underscore" scheme="https://ruiming.github.io/tags/Underscore/"/>
    
  </entry>
  
  <entry>
    <title>Underscore 源码学习(六)</title>
    <link href="https://ruiming.github.io/2016/08/05/Underscore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0(%E5%85%AD)/"/>
    <id>https://ruiming.github.io/2016/08/05/Underscore源码学习(六)/</id>
    <published>2016-08-05T05:59:06.000Z</published>
    <updated>2016-08-05T06:07:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于 Underscore 的 mixin 方法。<br>首先先看个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Panel</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  consoe.log(<span class="keyword">this</span>, <span class="keyword">this</span> <span class="keyword">instanceof</span> Panel);</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> Panel) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Panel();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">a = Panel();        <span class="comment">// Window   false</span></div><div class="line">b = <span class="keyword">new</span> Panel();    <span class="comment">// Panel&#123;&#125;  true</span></div></pre></td></tr></table></figure></p>
<p>当函数作为构造器使用时，函数内的 <code>this</code> 执行被新建的对象。当函数被调用时，函数内的 <code>this</code> 则为被调用的对象，在这里是 <code>Window</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _ = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> _) <span class="keyword">return</span> obj;</div><div class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> _)) <span class="keyword">return</span> <span class="keyword">new</span> _(obj);</div><div class="line">  <span class="keyword">this</span>._wrapped = obj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>同样的，如果我们使用下面方法调用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> under = _();</div></pre></td></tr></table></figure></p>
<p>第二个条件成立，所以新建一个 <code>_</code> 对象后返回，注意这里是再次调用这个函数。<br>如果我们这样调用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> under = <span class="keyword">new</span> _();</div></pre></td></tr></table></figure></p>
<p>就好像上面第二次调用一样，这时候就构造了 <code>under</code> 这个对象，如果传入了参数 <code>obj</code>，则把 <code>obj</code> 存入 <code>under</code> 这个对象的 <code>_wrapped</code> 属性中。<br><code>Underscore</code> 提供了一个 OO 的调用方法，即:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> chainResult = <span class="function"><span class="keyword">function</span>(<span class="params">instance, obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> instance._chain ? _(obj).chain() : obj;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">_.mixin = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="comment">// 遍历obj中的函数</span></div><div class="line">    _.each(_.functions(obj), <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="comment">// 避免原型链查找，提升性能</span></div><div class="line">        <span class="keyword">var</span> func = _[name] = obj[name];</div><div class="line">        _.prototype[name] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">// 把wrapped作为数组第一个参数(context)，其余传参push到这个数组中</span></div><div class="line">            <span class="keyword">var</span> args = [<span class="keyword">this</span>._wrapped];</div><div class="line">            push.apply(args, <span class="built_in">arguments</span>);</div><div class="line">            <span class="comment">// 如果this是一个_实例，则使用func调用的结果来新建_实例后返回以供继续链式调用</span></div><div class="line">            <span class="comment">// 如果this不是一个_实例，则直接返回func调用的结果</span></div><div class="line">            <span class="keyword">return</span> chainResult(<span class="keyword">this</span>, func.apply(_, args));</div><div class="line">        &#125;;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> _;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 把Underscore对象mixin化，这样就可以直接在_上调用方法</span></div><div class="line">_.mixin(_);</div></pre></td></tr></table></figure></p>
<p>当然我们还可以把自己写的方法通过 <code>mixin</code> 加入到 <code>Underscore</code> 对象中。<br><a id="more"></a><br>在这段代码后面还把原生的一些操作方法也添加到这个 <code>_</code> 上面，这样我们就可以直接在 <code>_</code> 上调用这些方法。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Add all mutator Array functions to the wrapper.</span></div><div class="line">_.each([<span class="string">'pop'</span>, <span class="string">'push'</span>, <span class="string">'reverse'</span>, <span class="string">'shift'</span>, <span class="string">'sort'</span>, <span class="string">'splice'</span>, <span class="string">'unshift'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> method = ArrayProto[name];</div><div class="line">    _.prototype[name] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> obj = <span class="keyword">this</span>._wrapped;</div><div class="line">        method.apply(obj, <span class="built_in">arguments</span>);</div><div class="line">        <span class="keyword">if</span> ((name === <span class="string">'shift'</span> || name === <span class="string">'splice'</span>) &amp;&amp; obj.length === <span class="number">0</span>) <span class="keyword">delete</span> obj[<span class="number">0</span>];</div><div class="line">        <span class="keyword">return</span> chainResult(<span class="keyword">this</span>, obj);</div><div class="line">    &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>上面这些方法并不是 Underscore 新建的，不存在于 Underscore 对象的原型链上，所以我们要把他们加进去。和上面 <code>mixin</code> 方法类似，下面这段代码是为了兼容 IE 而采取的操作：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ((name === <span class="string">'shift'</span> || name === <span class="string">'splice'</span>) &amp;&amp; obj.length === <span class="number">0</span>) <span class="keyword">delete</span> obj[<span class="number">0</span>];</div></pre></td></tr></table></figure></p>
<blockquote>
<p>jdalton commented on 6 Dec 2011<br>IE bugs with splice() and shift(), failing to remove the 0 indexed value, when using an array-like-object with _(…).<br>IE compatibility mode and IE &lt; 9 have buggy Array shift() and splice() functions that fail to remove the last element, object[0], of array-like-objects even though the length property is set to 0.</p>
</blockquote>
<p>通过上面这些方法把 Underscore 转化为可面向对象编程，调用更加优雅，我们可以有以下两种使用方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_.map([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123; <span class="keyword">return</span> n * <span class="number">2</span>; &#125;);</div><div class="line">_([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).map(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123; <span class="keyword">return</span> n * <span class="number">2</span>; &#125;);</div></pre></td></tr></table></figure></p>
<p>至于选择哪一种就看你的喜好了～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 Underscore 的 mixin 方法。&lt;br&gt;首先先看个例子：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Panel&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  consoe.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; Panel);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; Panel) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Panel();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;a = Panel();        &lt;span class=&quot;comment&quot;&gt;// Window   false&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;b = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Panel();    &lt;span class=&quot;comment&quot;&gt;// Panel&amp;#123;&amp;#125;  true&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当函数作为构造器使用时，函数内的 &lt;code&gt;this&lt;/code&gt; 执行被新建的对象。当函数被调用时，函数内的 &lt;code&gt;this&lt;/code&gt; 则为被调用的对象，在这里是 &lt;code&gt;Window&lt;/code&gt;。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; _ = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (obj &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; _) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; obj;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; _)) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; _(obj);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._wrapped = obj;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;同样的，如果我们使用下面方法调用：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; under = _();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;第二个条件成立，所以新建一个 &lt;code&gt;_&lt;/code&gt; 对象后返回，注意这里是再次调用这个函数。&lt;br&gt;如果我们这样调用：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; under = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; _();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;就好像上面第二次调用一样，这时候就构造了 &lt;code&gt;under&lt;/code&gt; 这个对象，如果传入了参数 &lt;code&gt;obj&lt;/code&gt;，则把 &lt;code&gt;obj&lt;/code&gt; 存入 &lt;code&gt;under&lt;/code&gt; 这个对象的 &lt;code&gt;_wrapped&lt;/code&gt; 属性中。&lt;br&gt;&lt;code&gt;Underscore&lt;/code&gt; 提供了一个 OO 的调用方法，即:&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; chainResult = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;instance, obj&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance._chain ? _(obj).chain() : obj;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;_.mixin = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 遍历obj中的函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    _.each(_.functions(obj), &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 避免原型链查找，提升性能&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; func = _[name] = obj[name];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        _.prototype[name] = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 把wrapped作为数组第一个参数(context)，其余传参push到这个数组中&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; args = [&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._wrapped];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            push.apply(args, &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 如果this是一个_实例，则使用func调用的结果来新建_实例后返回以供继续链式调用&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 如果this不是一个_实例，则直接返回func调用的结果&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; chainResult(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, func.apply(_, args));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 把Underscore对象mixin化，这样就可以直接在_上调用方法&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;_.mixin(_);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当然我们还可以把自己写的方法通过 &lt;code&gt;mixin&lt;/code&gt; 加入到 &lt;code&gt;Underscore&lt;/code&gt; 对象中。&lt;br&gt;
    
    </summary>
    
      <category term="Underscore" scheme="https://ruiming.github.io/categories/Underscore/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="Underscore" scheme="https://ruiming.github.io/tags/Underscore/"/>
    
  </entry>
  
  <entry>
    <title>Underscore 源码学习(五)</title>
    <link href="https://ruiming.github.io/2016/08/04/Underscore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0(%E4%BA%94)/"/>
    <id>https://ruiming.github.io/2016/08/04/Underscore源码学习(五)/</id>
    <published>2016-08-04T07:18:48.000Z</published>
    <updated>2016-08-04T11:41:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>Underscore 的函数大部分还是挺好理解的，感觉过一遍就行了，不过今天看到两个函数感觉还是挺有意思的，并且也挺常用。这两个函数就是 throttle 和 debounce。</p>
<h2 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">_.throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, options</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> timeout, context, args, result;</div><div class="line">  <span class="keyword">var</span> previous = <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span> (!options) options = &#123;&#125;;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 更改previous即上一次执行时间为当前时间</span></div><div class="line">    previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : _.now();</div><div class="line">    timeout = <span class="literal">null</span>;</div><div class="line">    result = func.apply(context, args);</div><div class="line">    <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> now = _.now();</div><div class="line">    <span class="comment">// 如果leading为false时禁用第一次首先执行，previous等于now（效果同已经执行过一次，所以第一次被禁用）</span></div><div class="line">    <span class="comment">// 这个if语句只在第一次执行该函数的时候有效</span></div><div class="line">    <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</div><div class="line">    <span class="keyword">var</span> remaining = wait - (now - previous);</div><div class="line">    context = <span class="keyword">this</span>;</div><div class="line">    args = <span class="built_in">arguments</span>;</div><div class="line">    <span class="comment">// 超时处理和未到时的处理</span></div><div class="line">    <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</div><div class="line">      <span class="comment">// timeout不为null时清除掉并设置为null</span></div><div class="line">      <span class="keyword">if</span> (timeout) &#123;</div><div class="line">        clearTimeout(timeout);</div><div class="line">        timeout = <span class="literal">null</span>;</div><div class="line">      &#125;</div><div class="line">      previous = now;</div><div class="line">      <span class="comment">// 立即调用</span></div><div class="line">      result = func.apply(context, args);</div><div class="line">      <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;    <span class="comment">// 如果没有禁用最后一次执行</span></div><div class="line">      timeout = setTimeout(later, remaining);               <span class="comment">// remaining毫秒后执行later</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 返回调用的结果</span></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  throttled.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    clearTimeout(timeout);</div><div class="line">    previous = <span class="number">0</span>;</div><div class="line">    timeout = context = args = <span class="literal">null</span>;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> throttled;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其实一步步去理解也不难，就不细说这个方法了。这个方法有可选项设置，分别为 {leading: false} 和 {trailing: false}。</p>
<p>所以一般有四类情况：</p>
<ul>
<li>默认情况<br>第一次调用时立即响应，之后每个周期内最多执行一次，周期内触发会产生定时执行使在上一次执行时间 <code>preview</code> 周期时间后再次执行。</li>
<li>设置 <code>leading</code> 为 <code>false</code><br>同默认情况区别在于第一次调用不会立即执行而是等待周期时间后再次执行，如果在周期时间内触发，一样等待上一次执行时间 <code>preview</code> 周期时间后再执行。</li>
<li>设置 <code>trailing</code> 为 <code>false</code><br>最后周期内最多执行一次，但在周期时间内调用不会触发 <code>timeout</code>，只能在上一次 <code>timeout</code> 失效后调用才能生效并且此时调用将立即执行。</li>
<li>设置 <code>leading</code> 和 <code>trailing</code> 为 <code>false</code><br>如果同时还设置 <code>leading</code> 为 <code>false</code> 的话，那么第一次调用不会立即执行而是等待周期时间后才执行，在这段时间内调用都不会有效果。</li>
</ul>
<a id="more"></a>
<p>比如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = _.throttle(updatePosition, <span class="number">100</span>);</div><div class="line">$(<span class="built_in">window</span>).scroll(func);</div></pre></td></tr></table></figure></p>
<p>由于 scroll 过程时, <code>func</code> 函数的调用是很密集的，我们不能每次调用都去执行，可以通过设置 throttle 来达到节流阀的作用。<code>leading</code> 和 <code>trailing</code> 只是实现上细微的不同而已。</p>
<p>throll 主要应用在鼠标移动，mousemove 事件，DOM 元素动态定位，window 对象的 resize 和 scroll 等事件。这些事件触发频率高，但又要尽可能进行响应。</p>
<h2 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">_.debounce = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> timeout, result;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params">context, args</span>) </span>&#123;</div><div class="line">    timeout = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">if</span> (args) result = func.apply(context, args);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> debounced = restArgs(<span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</div><div class="line">    <span class="comment">// 再次调用且上次还未执行，则清除上次的timeout</span></div><div class="line">    <span class="comment">// 只是timeout事件不再执行，但timeout依旧存在</span></div><div class="line">    <span class="keyword">if</span> (timeout) clearTimeout(timeout);</div><div class="line">    <span class="comment">// 如果immediate为true</span></div><div class="line">    <span class="keyword">if</span> (immediate) &#123;</div><div class="line">      <span class="comment">// 如果timeout为null，则立即调用函数</span></div><div class="line">      <span class="comment">// 如果timeout不为null，则callNow为false，函数不执行</span></div><div class="line">      <span class="keyword">var</span> callNow = !timeout;</div><div class="line">      timeout = setTimeout(later, wait);</div><div class="line">      <span class="keyword">if</span> (callNow) result = func.apply(<span class="keyword">this</span>, args);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 延迟later执行，如果这个还没到时间再来一次，则新的会覆盖上一次的</span></div><div class="line">      timeout = _.delay(later, wait, <span class="keyword">this</span>, args);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  debounced.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    clearTimeout(timeout);</div><div class="line">    timeout = <span class="literal">null</span>;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> debounced;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数就要比上面那个好理解一点，说明下这个函数：</p>
<ul>
<li><p>如果 <code>immediate</code> 为 <code>true</code>，周期 100ms</p>
<ul>
<li>0   =&gt; 立即执行，设置 <code>timeout</code></li>
<li>50  =&gt; 重新设置 <code>timeout</code>，不执行</li>
<li>100 =&gt; 重新设置 <code>timeout</code>，不执行</li>
<li>200 =&gt; <code>timeout</code> 到时，执行函数</li>
</ul>
</li>
<li><p>如果 <code>immediate</code> 为 <code>false</code>, 周期 100ms</p>
<ul>
<li>0   =&gt; 设置 <code>timeout</code>，不执行</li>
<li>100 =&gt; <code>timeout</code> 到时，执行函数</li>
<li>120 =&gt; 设置 <code>timeout</code>，不执行</li>
<li>180 =&gt; 重新设置 <code>timeout</code>，不执行</li>
<li>280 =&gt; <code>timeout</code> 到时，执行函数</li>
</ul>
</li>
</ul>
<p>其实 <code>timeout</code> 就变成一个控制两次事件触发间隔用的，并且和上面的 throttle 不同，<code>timeout</code> 会被重新设置。</p>
<p>debounce 主要应用在文本输入 keydown 事件，keyup 事件，例如做 autocomplete。</p>
<p>结合两个的应用细细体味下他们差别。如果想自己体验下差别，<a href="http://jsfiddle.net/missinglink/19e2r2we/" target="_blank" rel="external">传送门</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Underscore 的函数大部分还是挺好理解的，感觉过一遍就行了，不过今天看到两个函数感觉还是挺有意思的，并且也挺常用。这两个函数就是 throttle 和 debounce。&lt;/p&gt;
&lt;h2 id=&quot;throttle&quot;&gt;&lt;a href=&quot;#throttle&quot; class=&quot;headerlink&quot; title=&quot;throttle&quot;&gt;&lt;/a&gt;throttle&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;_.throttle = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;func, wait, options&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; timeout, context, args, result;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; previous = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!options) options = &amp;#123;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; later = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 更改previous即上一次执行时间为当前时间&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    previous = options.leading === &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt; ? &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; : _.now();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    timeout = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    result = func.apply(context, args);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!timeout) context = args = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; throttled = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; now = _.now();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果leading为false时禁用第一次首先执行，previous等于now（效果同已经执行过一次，所以第一次被禁用）&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 这个if语句只在第一次执行该函数的时候有效&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!previous &amp;amp;&amp;amp; options.leading === &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;) previous = now;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; remaining = wait - (now - previous);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    context = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    args = &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 超时处理和未到时的处理&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (remaining &amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; || remaining &amp;gt; wait) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// timeout不为null时清除掉并设置为null&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (timeout) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        clearTimeout(timeout);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        timeout = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      previous = now;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 立即调用&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      result = func.apply(context, args);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!timeout) context = args = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!timeout &amp;amp;&amp;amp; options.trailing !== &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;) &amp;#123;    &lt;span class=&quot;comment&quot;&gt;// 如果没有禁用最后一次执行&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      timeout = setTimeout(later, remaining);               &lt;span class=&quot;comment&quot;&gt;// remaining毫秒后执行later&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 返回调用的结果&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  throttled.cancel = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    clearTimeout(timeout);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    previous = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    timeout = context = args = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; throttled;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其实一步步去理解也不难，就不细说这个方法了。这个方法有可选项设置，分别为 {leading: false} 和 {trailing: false}。&lt;/p&gt;
&lt;p&gt;所以一般有四类情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认情况&lt;br&gt;第一次调用时立即响应，之后每个周期内最多执行一次，周期内触发会产生定时执行使在上一次执行时间 &lt;code&gt;preview&lt;/code&gt; 周期时间后再次执行。&lt;/li&gt;
&lt;li&gt;设置 &lt;code&gt;leading&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt;&lt;br&gt;同默认情况区别在于第一次调用不会立即执行而是等待周期时间后再次执行，如果在周期时间内触发，一样等待上一次执行时间 &lt;code&gt;preview&lt;/code&gt; 周期时间后再执行。&lt;/li&gt;
&lt;li&gt;设置 &lt;code&gt;trailing&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt;&lt;br&gt;最后周期内最多执行一次，但在周期时间内调用不会触发 &lt;code&gt;timeout&lt;/code&gt;，只能在上一次 &lt;code&gt;timeout&lt;/code&gt; 失效后调用才能生效并且此时调用将立即执行。&lt;/li&gt;
&lt;li&gt;设置 &lt;code&gt;leading&lt;/code&gt; 和 &lt;code&gt;trailing&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt;&lt;br&gt;如果同时还设置 &lt;code&gt;leading&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 的话，那么第一次调用不会立即执行而是等待周期时间后才执行，在这段时间内调用都不会有效果。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Underscore" scheme="https://ruiming.github.io/categories/Underscore/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="Underscore" scheme="https://ruiming.github.io/tags/Underscore/"/>
    
  </entry>
  
  <entry>
    <title>谈谈 React 和 Redux</title>
    <link href="https://ruiming.github.io/2016/08/01/%E8%B0%88%E8%B0%88React%E5%92%8CRedux/"/>
    <id>https://ruiming.github.io/2016/08/01/谈谈React和Redux/</id>
    <published>2016-08-01T07:53:32.000Z</published>
    <updated>2016-08-04T08:33:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚回到家的时候学习了 React 和 Redux，现在才想来总结一下，不知道会不会忘的差不多了…本来是想写一个问卷发布系统的，使用 React 和 Redux 已经完成了基础的几个功能，但是那个代码量…用 Angular 写简直轻轻松松的好吧…然后就去重构项目还有现在学的 Underscore 去了。是时候重新回顾下了。<br>此处主要讲的是 Redux 。</p>
<h3 id="关于-Redux"><a href="#关于-Redux" class="headerlink" title="关于 Redux"></a>关于 Redux</h3><blockquote>
<p>redux 是facebook 提出的 flux 架构的一种优秀实现；而且不局限于为 react 提供数据状态处理。它是零依赖的，可以配合其他任何框架或者类库一起使用。要想配合 react，还得引入 react-redux。</p>
</blockquote>
<h3 id="关于-Flux"><a href="#关于-Flux" class="headerlink" title="关于 Flux"></a>关于 Flux</h3><p>那什么是 Flux 呢？见下图<br><img src="/2016/08/01/谈谈React和Redux/flux-overview.png" alt="flux-overview.png" title="flux-overview.png"><br>Flux 可以分为四个部分：</p>
<ul>
<li>View: 视图层</li>
<li>Action: 视图层触发的动作</li>
<li>Dispatcher: 派发器，用来接受 Actions, 执行回调函数</li>
<li>Store：数据层，用来存放应用的状态，其变更会触发 View 层更新</li>
</ul>
<p>Flux 的最大特点就是单向流动，他的过程大概如下：</p>
<ol>
<li>用户访问 View ，触发了动作 Action</li>
<li>Dispatcher 收到 Action ，根据 Action 类别进行相应的处理，处理结束后要求 Store 更新</li>
<li>Store 进行更新，通知 View 层刷新</li>
<li>View 层收到通知更新页面</li>
</ol>
<p>额，其实我没有用 Flux，不敢讲太多了，简单的说就是一种单项数据流动的解决方案吧。我是直接学 Redux，对 Flux 也就大概了解这么多了。</p>
<h3 id="Redux-和-Flux"><a href="#Redux-和-Flux" class="headerlink" title="Redux 和 Flux"></a>Redux 和 Flux</h3><p>Redux 是 Flux 的一种实现，但他们又有所不同，在 Flux 中，Store 可以有多个，但 Redux 有且只能有一个 Store，Flux 中存在 Dispatcher，在 Redux 则没有这个，而是用 reducer 代替了。不多说了，直接往下说 Redux 吧，我快扯不下去 Flux 了=.=</p>
<h3 id="理解Redux"><a href="#理解Redux" class="headerlink" title="理解Redux"></a>理解Redux</h3><p>Redux 由四部分组成：</p>
<ul>
<li>Action</li>
<li>Reducer</li>
<li>Store</li>
<li>Views</li>
</ul>
<p>我们结合具体的应用场景来看</p>
<h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>先从 Action 说起，一个 Action 是一个普通的对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> SET_PAPER_TITLE = <span class="string">'SET_PAPER_TITLE'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_QUESTION = <span class="string">'ADD_QUESTION'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> REMOVE_QUESTION = <span class="string">'REMOVE_QUESTION'</span>;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setPaperTitle</span>(<span class="params">newTitle</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        type: SET_PAPER_TITLE,</div><div class="line">        value: newTitle</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addQuestion</span>(<span class="params">type</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        type: ADD_QUESTION,</div><div class="line">        questionType: type</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">removeQuestion</span>(<span class="params">questionId</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        type: REMOVE_QUESTION,</div><div class="line">        questionId: questionId</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>type 属性是必须的，表示动作类别，其他的参数可以自定。<br>我们先不用管 Action 有什么用，后面会提到。<br><a id="more"></a></p>
<h4 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h4><p>在 Action 这一层中，可以筛选掉脏数据，多余的参数不会传入，真正处理数据是在 Reducer 中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; SET_PAPER_TITLE, ADD_QUESTION, REMOVE_QUESTION, ADD_OPTION, REMOVE_OPTION, SET_QUESTION_TITLE, SET_OPTION_TITLE &#125; <span class="keyword">from</span> <span class="string">'../action/action'</span></div><div class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">paperReducer</span>(<span class="params">state=[], action</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span>(action.type) &#123;</div><div class="line">        <span class="keyword">case</span> SET_PAPER_TITLE:</div><div class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</div><div class="line">                title: action.value</div><div class="line">            &#125;);</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">questionsReducer</span>(<span class="params">state=[], action</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span>(action.type) &#123;</div><div class="line">        <span class="keyword">case</span> ADD_QUESTION:</div><div class="line">            <span class="keyword">return</span> [</div><div class="line">                ...state,</div><div class="line">                &#123;</div><div class="line">                    title: <span class="string">''</span>,</div><div class="line">                    type: action.questionType,</div><div class="line">                    content: [<span class="string">''</span>,<span class="string">''</span>,<span class="string">''</span>,<span class="string">''</span>]</div><div class="line">                &#125;</div><div class="line">            ];</div><div class="line">        <span class="keyword">case</span> REMOVE_QUESTION:</div><div class="line">            <span class="keyword">return</span> [</div><div class="line">                ...state.slice(<span class="number">0</span>, action.questionId),</div><div class="line">                ...state.slice(action.questionId+<span class="number">1</span>)</div><div class="line">            ];</div><div class="line">        <span class="keyword">case</span> ADD_OPTION:</div><div class="line">        <span class="keyword">case</span> REMOVE_OPTION:</div><div class="line">        <span class="keyword">case</span> SET_QUESTION_TITLE:</div><div class="line">        <span class="keyword">case</span> SET_OPTION_TITLE:</div><div class="line">            <span class="keyword">return</span> [</div><div class="line">                ...state.slice(<span class="number">0</span>, action.questionId),</div><div class="line">                questionReducer(state[action.questionId], action),</div><div class="line">                ...state.slice(action.questionId+<span class="number">1</span>)</div><div class="line">            ];</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> paperApp = combineReducers(&#123;</div><div class="line">    paper: paperReducer,</div><div class="line">    questions: questionsReducer</div><div class="line">&#125;);</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> paperApp;</div></pre></td></tr></table></figure></p>
<p>这里列了很多 Action，但在上面的 Action 部分我只提了两个，其他的其实都一样的，就是参数可能有些区别而已。<br>这里就要好好说一笔了，reducer 之所以叫 reducer，一个原因就是他很类似 JavaScript 中数组的 reduce 方法，接收两个参数，一个是当前状态，一个是处理方法。<br>但在 Redux 中，不要直接修改当前状态即 <code>state</code>，而应该返回一个新的 <code>state</code>，而这样做的其中一个好处就是可以实现时间旅行的功能，即可以回溯到任意版本的数据，并且对于判断 <code>state</code> 是否发生修改也很重要，如果是在原引用上修改我们得用 <code>deepEqual</code> 深度遍历来对比值，而如果返回了一个新的对象则可以直接使用 <code>===</code> 来判断两个数据是否一致，不一致则触发更改。reducer 方法应该都能看懂，接下来是 combineReducers 这个。<br>我上面其实涉及到三个 reducer 了，分别是</p>
<ul>
<li>paperReducer</li>
<li>questionsReducer</li>
<li>questionReducer</li>
</ul>
<p>但为了减少空间，我没有把 <code>questionReducer</code> 写出来。其实注意看从29行到32行的四个 Action，我都传入 <code>state</code> 中的部分数据给了 <code>questionReducer</code> 去做处理。因为这些都是涉及一个问题的修改的，所以就单独列出来。这样就不致于一个 reducer 写太多东西。<br>实质上还是两个 reducer 而已，这里的 combineReducers 就是把这两个 reducer 合并在一起。这两个 reducer 一个是处理问卷信息如问卷标题，一个是处理问卷的问题比如新建删除问题，问题修改这些。</p>
<h4 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h4><p>使用 combineReducers 就要求我们 Store 的设计合理，因为 Store 和 reducer 是要对应的，<code>questionsReducer</code> 只要处理问题，而 <code>paperReducer</code> 只要处理问卷本身，所以也就不需要往 <code>paperReducer</code> 传入完整的 <code>state</code> 信息。我们看下 Store。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></div><div class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span></div><div class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></div><div class="line"><span class="keyword">import</span> paperApp <span class="keyword">from</span> <span class="string">'./reducer/reducer'</span></div><div class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./containers/App'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> initialState = &#123;</div><div class="line">    paper: &#123;</div><div class="line">        title: <span class="string">'asd'</span>,</div><div class="line">        time: <span class="string">"2016-7-19"</span>,</div><div class="line">        author: <span class="string">"Ruiming"</span>,</div><div class="line">    &#125;,</div><div class="line">    questions: [&#123;</div><div class="line">        title: <span class="string">''</span>,</div><div class="line">        type: <span class="string">'radio'</span>,</div><div class="line">        content: [<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>]</div><div class="line">    &#125;, &#123;</div><div class="line">        title: <span class="string">''</span>,</div><div class="line">        type: <span class="string">'checkbox'</span>,</div><div class="line">        content: [<span class="string">''</span>,<span class="string">''</span>,<span class="string">''</span>,<span class="string">''</span>]</div><div class="line">    &#125;]</div><div class="line">&#125;;</div><div class="line"><span class="keyword">let</span> store = createStore(paperApp, initialState);</div><div class="line"><span class="keyword">let</span> rootElement = <span class="built_in">document</span>.getElementById(<span class="string">'index'</span>);</div><div class="line">render (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">App</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span>,</div><div class="line">    rootElement</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>我们初始一个数据 initialState，调用 createStore 方法需要传入两个参数，分别就是我们上面 combineReducers 后的<code>paperApp</code>和我们的数据。在初始数据中，有两个对象分别是<code>paper</code>和<code>questions</code>，这就刚好和 combineReducers 中的<code>paper</code>和<code>questions</code>对应，从而实现传递部分<code>state</code>。<br>下面的 render 部分是就是渲染部分了， Provider 是 react-redux 提供的一个容器，将 Store 作为属性传递给该容器。</p>
<h4 id="Views"><a href="#Views" class="headerlink" title="Views"></a>Views</h4><p>我们看下 App 的内容<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component, PropTypes &#125; <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></div><div class="line"><span class="keyword">import</span> &#123; addQuestion, addOption, setPaperTitle, setQuestionTitle, setOptionTitle, removeQuestion, removeOption &#125; <span class="keyword">from</span> <span class="string">'../action/action'</span></div><div class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'../components/Header'</span></div><div class="line"><span class="keyword">import</span> NewQuestionBar <span class="keyword">from</span> <span class="string">'../components/NewQuestionBar'</span></div><div class="line"><span class="keyword">import</span> OptionsBar <span class="keyword">from</span> <span class="string">'../components/OptionsBar'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">const</span> &#123; dispatch, title, questions &#125; = <span class="keyword">this</span>.props;</div><div class="line">        <span class="keyword">return</span> &lt;div ref="paper"&gt;</div><div class="line">            &lt;Header title=&#123;title&#125;</div><div class="line">                    setPaperTitle=&#123;(title) =&gt; dispatch(setPaperTitle(title))&#125;</div><div class="line">                /&gt;</div><div class="line">            &lt;NewQuestionBar addQuestion=&#123;(type) =&gt; dispatch(addQuestion(type))&#125; /&gt;</div><div class="line">            &lt;section className="paper"&gt;</div><div class="line">                &lt;ul className="paper-list"&gt;</div><div class="line">                    &#123;questions.map(function(question, i) &#123;</div><div class="line">                        return &lt;OptionsBar content=&#123;question.content&#125;</div><div class="line">                                           addQuestion=&#123;() =&gt; dispatch(addQuestion())&#125;</div><div class="line">                                           addOption=&#123;(questionId) =&gt; dispatch(addOption(questionId))&#125;</div><div class="line">                        /&gt;</div><div class="line">                    &#125;.bind(this))</div><div class="line">                    &#125;</div><div class="line">                &lt;/ul&gt;</div><div class="line">            &lt;/section&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function select(state) &#123;</div><div class="line">    return &#123;</div><div class="line">        paper: state.paper,</div><div class="line">        questions: state.questions</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default connect(select)(App);</div></pre></td></tr></table></figure></p>
<p>上面我去掉了很多部分，只保留了 <code>addQuestion</code> 和 <code>addOption</code> 这两个，我们看下这两个就好了。其实这部分的写法就是 React 写法而已，只是多了个 dispatch 方法。注意下最后的 connect 方法，他的作用是：</p>
<ul>
<li>把所需要的 <code>state</code> 属性挂载到组件的 <code>props</code> 上。</li>
<li>为组件的 <code>props</code> 添加 <code>dispatch</code> 方法。</li>
</ul>
<h3 id="Redux-运行过程"><a href="#Redux-运行过程" class="headerlink" title="Redux 运行过程"></a>Redux 运行过程</h3><p>介绍完了 Redux 的四个部分，接下来就要说下这个运行的流程了。这才是理解 Redux 的关键。</p>
<ol>
<li>用户在视图触发 dispatch 事件</li>
<li>Redux 响应用户操作生成 action </li>
<li>action 传到 store 层，可以使用中间件进行一些处理</li>
<li>action 传 <code>state</code> 和 <code>action</code> 给 reducer 处理</li>
<li>reducer 返回一个新的 <code>state</code></li>
<li>store 读取 reducer 返回的内容，设置新的状态</li>
</ol>
<p>大致就是以上过程，action 是唯一可以改变状态的途径，不仅包括用户的触发，也可以是来自服务器的推送，action 进行预处理后会传到 store，由 store 发送动作给 reducer，带上当前状态和当前动作，reducer 根据动作的 type 来进行不同的处理。注意 action 和 reducer 都是纯函数。</p>
<p>Redux 大致就是这么一回事，我们可以看到所有数据都来自一个对象 Store，这样就方便了调试测试，可以把 Store 就想象成一个数据库。state 只读，只能通过 action 改变，并且必须保证 reducer 是纯函数，所谓纯函数就是相同参数传入无数次他们都返回相同的东西，其实就是内部没有使用外部变量，外部变量总是伴随着不确定性。</p>
<h3 id="React-和-Angular"><a href="#React-和-Angular" class="headerlink" title="React 和 Angular"></a>React 和 Angular</h3><p>React 现在很博人眼球，虚拟DOM提升了页面渲染性能，并且衍生的 React Native 也非常有诱惑力，单向数据流动虽然带来了清晰的逻辑和更高的性能，但降低了开发效率。另外，使用 React 开发的应用天然组件化，也方便了后期的维护。</p>
<p>Angular 是一个功能完善全面的框架，还自带了 $http, ngRoute, jQlite, $q, service 等等。提供了一整套的解决方案，估计这点很合大公司的胃口。并且 Angular 社区成熟活跃，生态完整，目前仍是最流行的前端框架，没有之一，非常适合用来写单页应用。数据双向绑定给开发带来了很大的便利，但双向绑定带来了性能损耗并且脏值检查性能也不好。</p>
<p>对比起来，我还是更喜欢 Angular，他的开发效率高，而且写起来很清晰，虽然他也有一些问题，但是在没有达到一个量级前这些问题是很难被体现出来的。而 React 可能在开发多端或者注重体积或者是在大型应用中可能才会去考虑吧。</p>
<p>另外 Angular2 也实现了虚拟 DOM，同样支持服务端渲染，使用 web worker 提升性能，TypeScript 提升了 JavaScript 项目的健壮性，而 Web Components 无疑是是未来趋势。我对 Angular2 同样满怀期待，我认为 Angular2 未来也会同 Angular1 一样火起来。</p>
<p>计划是再学习 react-router，写一个完整的 React 应用，后端使用 Koa 来开发。不过还是等手头上的东西处理完先吧。</p>
<p>除了 Angular1 和 Angular2 以及 React ，还有 Vue 和 Vue2 以及阿里的 Weex，前端的水深着呢！</p>
<hr>
<p><a href="https://github.com/Lucifier129/Lucifier129.github.io/issues/9" target="_blank" rel="external">深入到源码：解读 redux 的设计思路与用法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚回到家的时候学习了 React 和 Redux，现在才想来总结一下，不知道会不会忘的差不多了…本来是想写一个问卷发布系统的，使用 React 和 Redux 已经完成了基础的几个功能，但是那个代码量…用 Angular 写简直轻轻松松的好吧…然后就去重构项目还有现在学的 Underscore 去了。是时候重新回顾下了。&lt;br&gt;此处主要讲的是 Redux 。&lt;/p&gt;
&lt;h3 id=&quot;关于-Redux&quot;&gt;&lt;a href=&quot;#关于-Redux&quot; class=&quot;headerlink&quot; title=&quot;关于 Redux&quot;&gt;&lt;/a&gt;关于 Redux&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;redux 是facebook 提出的 flux 架构的一种优秀实现；而且不局限于为 react 提供数据状态处理。它是零依赖的，可以配合其他任何框架或者类库一起使用。要想配合 react，还得引入 react-redux。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;关于-Flux&quot;&gt;&lt;a href=&quot;#关于-Flux&quot; class=&quot;headerlink&quot; title=&quot;关于 Flux&quot;&gt;&lt;/a&gt;关于 Flux&lt;/h3&gt;&lt;p&gt;那什么是 Flux 呢？见下图&lt;br&gt;&lt;img src=&quot;/2016/08/01/谈谈React和Redux/flux-overview.png&quot; alt=&quot;flux-overview.png&quot; title=&quot;flux-overview.png&quot;&gt;&lt;br&gt;Flux 可以分为四个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;View: 视图层&lt;/li&gt;
&lt;li&gt;Action: 视图层触发的动作&lt;/li&gt;
&lt;li&gt;Dispatcher: 派发器，用来接受 Actions, 执行回调函数&lt;/li&gt;
&lt;li&gt;Store：数据层，用来存放应用的状态，其变更会触发 View 层更新&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Flux 的最大特点就是单向流动，他的过程大概如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户访问 View ，触发了动作 Action&lt;/li&gt;
&lt;li&gt;Dispatcher 收到 Action ，根据 Action 类别进行相应的处理，处理结束后要求 Store 更新&lt;/li&gt;
&lt;li&gt;Store 进行更新，通知 View 层刷新&lt;/li&gt;
&lt;li&gt;View 层收到通知更新页面&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;额，其实我没有用 Flux，不敢讲太多了，简单的说就是一种单项数据流动的解决方案吧。我是直接学 Redux，对 Flux 也就大概了解这么多了。&lt;/p&gt;
&lt;h3 id=&quot;Redux-和-Flux&quot;&gt;&lt;a href=&quot;#Redux-和-Flux&quot; class=&quot;headerlink&quot; title=&quot;Redux 和 Flux&quot;&gt;&lt;/a&gt;Redux 和 Flux&lt;/h3&gt;&lt;p&gt;Redux 是 Flux 的一种实现，但他们又有所不同，在 Flux 中，Store 可以有多个，但 Redux 有且只能有一个 Store，Flux 中存在 Dispatcher，在 Redux 则没有这个，而是用 reducer 代替了。不多说了，直接往下说 Redux 吧，我快扯不下去 Flux 了=.=&lt;/p&gt;
&lt;h3 id=&quot;理解Redux&quot;&gt;&lt;a href=&quot;#理解Redux&quot; class=&quot;headerlink&quot; title=&quot;理解Redux&quot;&gt;&lt;/a&gt;理解Redux&lt;/h3&gt;&lt;p&gt;Redux 由四部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Action&lt;/li&gt;
&lt;li&gt;Reducer&lt;/li&gt;
&lt;li&gt;Store&lt;/li&gt;
&lt;li&gt;Views&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们结合具体的应用场景来看&lt;/p&gt;
&lt;h4 id=&quot;Action&quot;&gt;&lt;a href=&quot;#Action&quot; class=&quot;headerlink&quot; title=&quot;Action&quot;&gt;&lt;/a&gt;Action&lt;/h4&gt;&lt;p&gt;先从 Action 说起，一个 Action 是一个普通的对象。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; SET_PAPER_TITLE = &lt;span class=&quot;string&quot;&gt;&#39;SET_PAPER_TITLE&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; ADD_QUESTION = &lt;span class=&quot;string&quot;&gt;&#39;ADD_QUESTION&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; REMOVE_QUESTION = &lt;span class=&quot;string&quot;&gt;&#39;REMOVE_QUESTION&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setPaperTitle&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;newTitle&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        type: SET_PAPER_TITLE,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        value: newTitle&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;addQuestion&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;type&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        type: ADD_QUESTION,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        questionType: type&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;removeQuestion&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;questionId&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        type: REMOVE_QUESTION,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        questionId: questionId&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;type 属性是必须的，表示动作类别，其他的参数可以自定。&lt;br&gt;我们先不用管 Action 有什么用，后面会提到。&lt;br&gt;
    
    </summary>
    
      <category term="React" scheme="https://ruiming.github.io/categories/React/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="React" scheme="https://ruiming.github.io/tags/React/"/>
    
      <category term="Redux" scheme="https://ruiming.github.io/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>Underscore 源码学习(四)</title>
    <link href="https://ruiming.github.io/2016/08/01/Underscore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0(%E5%9B%9B)/"/>
    <id>https://ruiming.github.io/2016/08/01/Underscore源码学习(四)/</id>
    <published>2016-08-01T07:37:14.000Z</published>
    <updated>2016-08-04T08:33:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>终于看完了 Underscore 的集合部分了，看 Underscore 源码真的是长见识了，感觉真的受益匪浅。<br>但是集合里面方法也挺多的，我都不知道该拿哪些出来讲下，最近接触了 Redux，就说下 createRedux 这个方法吧，为后面讲 Redux 做个铺垫。<br>先看源码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> createReduce = <span class="function"><span class="keyword">function</span>(<span class="params">dir</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> reducer = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, memo, initial</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</div><div class="line">        length = (keys || obj).length,</div><div class="line">        index = dir &gt; <span class="number">0</span> ? <span class="number">0</span> : length - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(!initial) &#123;</div><div class="line">      memo = obj[keys ? keys[index] : index];</div><div class="line">      index += dir;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(; index &gt;= <span class="number">0</span> &amp;&amp; index &lt; length; index += dir) &#123;</div><div class="line">      <span class="keyword">var</span> currentKey = keys ? keys[index] : index;</div><div class="line">      memo = iteratee(memo, obj[currentKey], currentKey, obj);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> memo;</div><div class="line">  &#125;;</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, memo, context</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> initial = <span class="built_in">arguments</span>.length &gt;= <span class="number">3</span>;</div><div class="line">    <span class="keyword">return</span> reducer(obj, opitimizeCb(iteratee, context, <span class="number">4</span>), memo, initial);</div><div class="line">  &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这是 reduce 函数的工厂函数，用于生成一个 reducer ，dir 是决定方向用的。<br>我们从最后一个 return 开始看起，即<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, memo, context</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> initial = <span class="built_in">arguments</span>.length &gt;= <span class="number">3</span>;</div><div class="line">  <span class="keyword">return</span> reducer(obj, opitimizeCb(iteratee, context, <span class="number">4</span>), memo, initial);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>我们使用 reduce 的时候，如果没有指定 memo 值，这时候参数个数只有两个即 obj 和 iteratee，所以 initial 为 false 表示没有初始化。对于没初始的情况，就是增加了一个 if 语句里面的内容而已，作用是把第一个元素作为 memo 值。<br>接着就是有没有初始化都共用的部分了，通过一个 for 循环把 keys 遍历，并把相应的信息交给 iteratee 去处理，参数 memo 是上一次处理结果。遍历完后把最后的处理结果 memo 返回就完了。<br>这个函数派生了两个方法，即<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_.reduce = _.foldl = _.inject = createReduce(<span class="number">1</span>);</div><div class="line">_.reduceRight = _.foldr = createReduce(<span class="number">-1</span>);</div></pre></td></tr></table></figure></p>
<p>只是方向不同而已。<br>举个例子方便理解些，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = _.reduce([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="function"><span class="keyword">function</span>(<span class="params">accumulator, value, index, collection</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> accmulator + value;</div><div class="line">&#125;, <span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p>结果为 15 这个应该很明显，js 原生也有 reduce 方法，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">left, right</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> left + right;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>我们看下 Underscore 的例子，主要想说明下他的运行过程，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!initial)</div><div class="line">    memo = <span class="number">1</span>; index = <span class="number">1</span>;</div><div class="line">endif</div><div class="line"><span class="keyword">for</span></div><div class="line">    memo = iteratee(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) = <span class="number">3</span>;</div><div class="line">    memo = iteratee(<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) = <span class="number">6</span>;</div><div class="line">    memo = iteratee(<span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) = <span class="number">10</span>;</div><div class="line">    memo = iteratee(<span class="number">10</span>, <span class="number">5</span>, <span class="number">4</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) = <span class="number">15</span>;</div><div class="line">endfor</div><div class="line"><span class="keyword">return</span> memo = <span class="number">15</span>;</div></pre></td></tr></table></figure></p>
<p>额，我也不知道写的是什么东西，只是描述下过程而已，你懂的。<br>剩下的集合部分感觉也没啥好说的了，花点时间看下就可以看懂了=.=。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于看完了 Underscore 的集合部分了，看 Underscore 源码真的是长见识了，感觉真的受益匪浅。&lt;br&gt;但是集合里面方法也挺多的，我都不知道该拿哪些出来讲下，最近接触了 Redux，就说下 createRedux 这个方法吧，为后面讲 Redux 做个铺垫。&lt;br&gt;先看源码&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; createReduce = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;dir&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; reducer = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj, iteratee, memo, initial&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; keys = !isArrayLike(obj) &amp;amp;&amp;amp; _.keys(obj),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        length = (keys || obj).length,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        index = dir &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ? &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; : length - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!initial) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      memo = obj[keys ? keys[index] : index];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      index += dir;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(; index &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; index &amp;lt; length; index += dir) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; currentKey = keys ? keys[index] : index;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      memo = iteratee(memo, obj[currentKey], currentKey, obj);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; memo;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj, iteratee, memo, context&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; initial = &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;.length &amp;gt;= &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; reducer(obj, opitimizeCb(iteratee, context, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;), memo, initial);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这是 reduce 函数的工厂函数，用于生成一个 reducer ，dir 是决定方向用的。&lt;br&gt;我们从最后一个 return 开始看起，即&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj, iteratee, memo, context&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; initial = &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;.length &amp;gt;= &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; reducer(obj, opitimizeCb(iteratee, context, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;), memo, initial);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们使用 reduce 的时候，如果没有指定 memo 值，这时候参数个数只有两个即 obj 和 iteratee，所以 initial 为 false 表示没有初始化。对于没初始的情况，就是增加了一个 if 语句里面的内容而已，作用是把第一个元素作为 memo 值。&lt;br&gt;接着就是有没有初始化都共用的部分了，通过一个 for 循环把 keys 遍历，并把相应的信息交给 iteratee 去处理，参数 memo 是上一次处理结果。遍历完后把最后的处理结果 memo 返回就完了。&lt;br&gt;这个函数派生了两个方法，即&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;_.reduce = _.foldl = _.inject = createReduce(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;_.reduceRight = _.foldr = createReduce(&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;只是方向不同而已。&lt;br&gt;举个例子方便理解些，例如：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; sum = _.reduce([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;], &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;accumulator, value, index, collection&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; accmulator + value;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;结果为 15 这个应该很明显，js 原生也有 reduce 方法，如下：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;].reduce(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;left, right&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; left + right;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Underscore" scheme="https://ruiming.github.io/categories/Underscore/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="Underscore" scheme="https://ruiming.github.io/tags/Underscore/"/>
    
  </entry>
  
  <entry>
    <title>Underscore 源码学习(三)</title>
    <link href="https://ruiming.github.io/2016/07/31/Underscore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0(%E4%B8%89)/"/>
    <id>https://ruiming.github.io/2016/07/31/Underscore源码学习(三)/</id>
    <published>2016-07-31T06:37:31.000Z</published>
    <updated>2016-08-04T08:32:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>这次主要说剩余参数。<br>在 ES5 中，如果想要函数接收任意数量的参数，必须使用特殊变量 <code>arguments</code>，举个例子，我们要实现一个加法函数，要求第一个数乘2，然后与其他数相加。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> sum = <span class="built_in">arguments</span>[<span class="number">0</span>] * <span class="number">2</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</div><div class="line">        sum += <span class="built_in">arguments</span>[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 ES6 中，我们可以使用 <code>...</code> 操作符，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, ...args</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> sum = first*<span class="number">2</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> arg <span class="keyword">of</span> args) &#123;</div><div class="line">        sum += arg;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用 ES5 我们无法给函数定义参数，而只能通过 <code>arguments</code> 来获取参数，这样写明显带来了可读性的降低。而 ES6 我们就可以在函数声明里面写明参数，对于不定长的参数，则可以使用 <code>...</code> 操作符。<br><code>...</code> 还有另一个常用的应用场景，比如下面例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span> <span class="keyword">instanceof</span> <span class="built_in">Array</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</div><div class="line">&#125;</div><div class="line">test(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line"><span class="comment">// Result:</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="literal">false</span></div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>如果细看输出的[1, 2, 3]会发现他是这样的：<br><img src="/2016/07/31/Underscore源码学习(三)/result1.png" alt="result1.png" title="result1.png"><br>我们再试试下面的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="built_in">console</span>.log(arr);</div><div class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>);</div><div class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</div><div class="line"><span class="comment">// Result:</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="literal">true</span></div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>再看下[1, 2, 3]这行输出里面是什么：<br><img src="/2016/07/31/Underscore源码学习(三)/result2.png" alt="result2.png" title="result2.png"><br>从 <code>instanceof</code> 我们就知道了 <code>arguments</code> 并不是真正的数组。伪数组实质是一个对象。<br>要把一个伪数组转为数组，可以这样用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div></pre></td></tr></table></figure></p>
<p>上面这种做法在很多地方都可以看到。除了上面这样做之外，我们还可以使用 ES6 的 <code>Array.from</code> 来处理，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</div></pre></td></tr></table></figure></p>
<p>但在 ES6 中，我们使用 <code>...</code> 运算符并不存在这个问题，比如上面第二个例子，<code>args</code> 是一个数组。<br>鉴于此，我们应该尽量使用 ES6 剩余参数写法和 <code>Array.from</code> 的写法，因为这样更容易理解，而且写起来更简洁。<br>另外，我们还可以使用 <code>...</code> 操作符来复制数组，如下：<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> itemsCopy = [...items];</div></pre></td></tr></table></figure></p>
<p>额，说多了，其实我是想说说 Underscore 中的 restArgs 这个东西…<br>看下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> restArgs = <span class="function"><span class="keyword">function</span>(<span class="params">func, startIndex</span>) </span>&#123;</div><div class="line">    startIndex = startIndex == <span class="literal">null</span> ? func.length <span class="number">-1</span> : +startIndex;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> length = <span class="built_in">Math</span>.max(<span class="built_in">arguments</span>.length - startIndex, <span class="number">0</span>);</div><div class="line">        <span class="keyword">var</span> rest = <span class="built_in">Array</span>(length);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</div><div class="line">            rest[index] = <span class="built_in">arguments</span>[index + startIndex];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">switch</span> (startIndex) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> func.call(<span class="keyword">this</span>, rest);</div><div class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> func.call(<span class="keyword">this</span>, <span class="built_in">arguments</span>[<span class="number">0</span>], rest);</div><div class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> func.call(<span class="keyword">this</span>, <span class="built_in">arguments</span>[<span class="number">0</span>], <span class="built_in">arguments</span>[<span class="number">1</span>], rest);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>(startIndex + <span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; startIndex; index++) &#123;</div><div class="line">            args[index] = <span class="built_in">arguments</span>[index];</div><div class="line">        &#125;</div><div class="line">        args[startIndex] = rest;</div><div class="line">        <span class="keyword">return</span> func.apply(<span class="keyword">this</span>, args);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个的作用就类似与 ES6 中的 <code>...</code> 操作符。这段代码作用是把 <code>func</code> 中 <code>startIndex</code> 开始的（如果没有指定则为被函数声明参数的最后一位开始）后面的参数全部变为一个数组传入 <code>func</code> 中。<br>这里有几个可圈可点的地方：</p>
<ul>
<li><p>fun.length 和 arguments.length<br>函数也具有 <code>length</code> 方法，得到的值是函数定义的参数的个数，但注意如果中间有一个含默认值的参数，则这个数和后面的参数都不会计算进去。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params">arg1, arg2, arg3 = 1, arg4</span>) </span>&#123;&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params">arg1, arg2, arg3</span>) </span>&#123;&#125;;</div><div class="line">test1.length;   <span class="comment">// 2</span></div><div class="line">test2.length    <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>而 <code>arguments.length</code> 则一直表示传入函数的参数个数。</p>
</li>
<li><p>使用 <code>+</code> 转换为数字<br>你可能注意到了下面这句话有个 <code>+</code> 运算符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">startIndex = startIndex == <span class="literal">null</span> ? func.length - <span class="number">1</span> : +startIndex;</div></pre></td></tr></table></figure>
<p>其用途就是尝试把 <code>startIndex</code> 转为数字，我们举例看下就明白了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="string">'123'</span>, b = <span class="string">'123s'</span>, c = <span class="string">'0x321'</span>, d = <span class="string">'-0'</span>, e = <span class="string">'-Infinity'</span></div><div class="line">+a;           <span class="comment">// 123</span></div><div class="line">+b;           <span class="comment">// NaN</span></div><div class="line">+c;           <span class="comment">// 801</span></div><div class="line">+d;           <span class="comment">// -0</span></div><div class="line">+e;           <span class="comment">// -Infinity</span></div></pre></td></tr></table></figure>
<p>应该很清楚了，就不说明了。<br>然后关于这里的 <code>switch</code> 其实就是一个优化而已，前面都提到过了，不提了。</p>
</li>
</ul>
<p>我们看下 Underscore 运用到 restArgs 方法的地方：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">_.invoke = restArgs(<span class="function"><span class="keyword">function</span>(<span class="params">obj, method, args</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> isFunc = _.isFunction(method);</div><div class="line">    <span class="keyword">return</span> _.map(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> func = isFunc ? method : value[method];</div><div class="line">        <span class="keyword">return</span> func == <span class="literal">null</span> ? func : func.apply(value, args);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这个方法的作用是在 <code>obj</code> 的每个元素上面执行 <code>method</code> 方法，例如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">_.invoke([[5, 1, 7], [3, 2, 1]], 'sort');</div><div class="line">_.invoke([['a', 'b', 'c'], ['w', 'g', 's']], 'join', '#');</div><div class="line">// Result:</div><div class="line">1,5,7,1,2,3</div><div class="line">a#b#c,w#g#s</div></pre></td></tr></table></figure></p>
<p>由于 <code>method</code> 需要的参数个数是未知的，所以我们这里使用了 <code>args</code> 再用 <code>restArgs</code> 达到类似 <code>...</code> 操作符的效果。<br>本来还想说说 Underscore 的几个方法的…但是好像已经写了挺多的了，还是下一次再介绍吧，后面的很多方法其实都不难理解，不过最好结合他的实际应用例子这样就更容易去理解些。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次主要说剩余参数。&lt;br&gt;在 ES5 中，如果想要函数接收任意数量的参数，必须使用特殊变量 &lt;code&gt;arguments&lt;/code&gt;，举个例子，我们要实现一个加法函数，要求第一个数乘2，然后与其他数相加。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; sum = &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;.length; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        sum += &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;[i];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sum;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在 ES6 中，我们可以使用 &lt;code&gt;...&lt;/code&gt; 操作符，例如：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;first, ...args&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; sum = first*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; arg &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; args) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        sum += arg;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sum;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用 ES5 我们无法给函数定义参数，而只能通过 &lt;code&gt;arguments&lt;/code&gt; 来获取参数，这样写明显带来了可读性的降低。而 ES6 我们就可以在函数声明里面写明参数，对于不定长的参数，则可以使用 &lt;code&gt;...&lt;/code&gt; 操作符。&lt;br&gt;&lt;code&gt;...&lt;/code&gt; 还有另一个常用的应用场景，比如下面例子：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;test(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Result:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果细看输出的[1, 2, 3]会发现他是这样的：&lt;br&gt;&lt;img src=&quot;/2016/07/31/Underscore源码学习(三)/result1.png&quot; alt=&quot;result1.png&quot; title=&quot;result1.png&quot;&gt;&lt;br&gt;我们再试试下面的&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(arr);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(arr &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(arr &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Result:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;再看下[1, 2, 3]这行输出里面是什么：&lt;br&gt;&lt;img src=&quot;/2016/07/31/Underscore源码学习(三)/result2.png&quot; alt=&quot;result2.png&quot; title=&quot;result2.png&quot;&gt;&lt;br&gt;从 &lt;code&gt;instanceof&lt;/code&gt; 我们就知道了 &lt;code&gt;arguments&lt;/code&gt; 并不是真正的数组。伪数组实质是一个对象。&lt;br&gt;要把一个伪数组转为数组，可以这样用&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr = &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;.prototype.slice.call(&lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面这种做法在很多地方都可以看到。除了上面这样做之外，我们还可以使用 ES6 的 &lt;code&gt;Array.from&lt;/code&gt; 来处理，如下：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr = &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;.from(&lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但在 ES6 中，我们使用 &lt;code&gt;...&lt;/code&gt; 运算符并不存在这个问题，比如上面第二个例子，&lt;code&gt;args&lt;/code&gt; 是一个数组。&lt;br&gt;鉴于此，我们应该尽量使用 ES6 剩余参数写法和 &lt;code&gt;Array.from&lt;/code&gt; 的写法，因为这样更容易理解，而且写起来更简洁。&lt;br&gt;另外，我们还可以使用 &lt;code&gt;...&lt;/code&gt; 操作符来复制数组，如下：&lt;br&gt;
    
    </summary>
    
      <category term="Underscore" scheme="https://ruiming.github.io/categories/Underscore/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="Underscore" scheme="https://ruiming.github.io/tags/Underscore/"/>
    
  </entry>
  
  <entry>
    <title>Underscore 源码学习(二)</title>
    <link href="https://ruiming.github.io/2016/07/29/Underscore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/"/>
    <id>https://ruiming.github.io/2016/07/29/Underscore源码学习(二)/</id>
    <published>2016-07-29T13:29:23.000Z</published>
    <updated>2016-08-04T08:32:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>Underscore 源码的学习落下了好几天，因为前几天一直正在重构项目和搞 React，不过这几天应该会花较多时间在 Underscore 上面了。<br>这次主要说下 Underscore 两个比较重要的函数吧，一个是<code>optimizeCb</code>，另一个是<code>cb</code>，这两个花了我挺长时间看的，而且是整个 Underscore 非常重要的函数，后面很多地方都使用到了它。</p>
<h2 id="optimizeCb-函数"><a href="#optimizeCb-函数" class="headerlink" title="optimizeCb 函数"></a>optimizeCb 函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> optimizeCb = <span class="function"><span class="keyword">function</span>(<span class="params">func, context, argCount</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (context === <span class="keyword">void</span> <span class="number">0</span>) <span class="keyword">return</span> func;</div><div class="line">    <span class="keyword">switch</span> (argCount == <span class="literal">null</span> ? <span class="number">3</span> : argCount) &#123;</div><div class="line">      <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> func.call(context, value);</div><div class="line">      &#125;;</div><div class="line">      <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">value, index, collection</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> func.call(context, value, index, collection);</div><div class="line">      &#125;;</div><div class="line">      <span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">accumulator, value, index, collection</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> func.call(context, accumulator, value, index, collection);</div><div class="line">      &#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> func.apply(context, <span class="built_in">arguments</span>);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个地方 <code>switch</code> 只是一个性能的优化，其实简化来看就是这样的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> optimizeCb = <span class="function"><span class="keyword">function</span>(<span class="params">func, context, argCount</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (context === <span class="keyword">void</span> <span class="number">0</span>) <span class="keyword">return</span> func;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> func.apply(context, <span class="built_in">arguments</span>);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>之所以有那段 <code>switch</code> 前面一篇已经有提到了，只是一个优化而已。使用 call 快于 apply。不过好像最新的 Chrome 已经可以自己优化这个过程，但为了提升性能，加上也无妨。<br>解释下段代码的意思，字如起名 optimizeCb 优化回调。这个函数传入三个参数依次是函数，上下文，参数个数。如果没有指定上下文则返回函数本身，如果有，则对该上下文绑定到传入的函数，根据传入的参数个数，在做一个性能优化。这个函数就是这个意思。我们看下他的使用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">_.each = _.forEach = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) </span>&#123;</div><div class="line">  iteratee = optimizeCb(iteratee, context);</div><div class="line">  <span class="keyword">var</span> i, length;</div><div class="line">  <span class="keyword">if</span> (isArrayLike(obj)) &#123;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, length = obj.length; i &lt; length; i++) &#123;</div><div class="line">      iteratee(obj[i], i, obj);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">var</span> keys = _.keys(obj);</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, length = keys.length; i &lt; length; i++) &#123;</div><div class="line">      iteratee(obj[keys[i]], keys[i], obj);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个函数是用来实现数组或者对象的遍历的，他是怎么做到呢？<br>首先是<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iteratee = optimizeCb(iteratee, context);</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>这个是优化 <code>iteratee</code> 这个函数，如果指定了上下文(<code>context</code>)则做绑定。一开始没理解 <code>iteratee</code> 这东西，其实他就是一个函数而已，比如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stu = &#123;</div><div class="line">  <span class="string">'age'</span>: <span class="number">20</span>,</div><div class="line">  <span class="string">'school'</span>: <span class="string">'SCNU'</span>,</div><div class="line">  <span class="string">'sex'</span>: <span class="string">'male'</span></div><div class="line">&#125;;</div><div class="line">_.each(stu, <span class="function"><span class="keyword">function</span>(<span class="params">value, key, obj</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(key + <span class="string">' : '</span> + value); </div><div class="line">&#125;);</div><div class="line"><span class="comment">// console</span></div><div class="line">age : <span class="number">20</span></div><div class="line">school : SCNU</div><div class="line">sex : male</div></pre></td></tr></table></figure></p>
<p>我们传入了一个函数，这个函数可以有三个回调参数分别是 value, key, obj 分别表示键值，键名，迭代对象。<br>重新看回 <code>each</code> 这个函数，<code>isArrayLike</code> 函数判断 <code>obj</code> 是不是数组，如果是的话，一个循环分别把 <code>obj[i]</code>, <code>i</code>, <code>obj</code> 分别传入这个 <code>iteratee</code> 这个传入来的函数，比如上面的 <code>function(value, key, obj){}</code> 里面，一一对应到 <code>value</code>, <code>key</code>, <code>obj</code>。从而实现迭代。在下面的是对象的处理，没什么好说的。<br>然后我们就讲完了 optimizeCb 这个函数了，其实也挺好理解的。</p>
<h2 id="cb-函数"><a href="#cb-函数" class="headerlink" title="cb 函数"></a>cb 函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> cb = <span class="function"><span class="keyword">function</span>(<span class="params">value, context, argCount</span>) </span>&#123;</div><div class="line">    <span class="comment">// 如果改变了iteratee的行为，则返回自定义的iteratee</span></div><div class="line">    <span class="keyword">if</span> (_.iteratee !== builtinIteratee) <span class="keyword">return</span> _.iteratee(value, context);</div><div class="line">    <span class="comment">// 没有传入value，返回当前迭代元素自身，比如var results = _.map([1,2,3]) =&gt; results: [1,2,3]</span></div><div class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) <span class="keyword">return</span> _.identity;</div><div class="line">    <span class="comment">// 是函数返回优化回调函数，比如var results = _.map([1,2,3], function(value, index, obj) &#123;...&#125;)</span></div><div class="line">    <span class="keyword">if</span> (_.isFunction(value)) <span class="keyword">return</span> optimizeCb(value, context, argCount);</div><div class="line">    <span class="comment">// 是对象返回一个能判断对象是否相等的函数，比如</span></div><div class="line">    <span class="comment">// var results = _.map([&#123;name:'qq'&#125;,&#123;name:'w',age:13&#125;], &#123;name:'w'&#125;) =&gt; results: [false, true]</span></div><div class="line">    <span class="keyword">if</span> (_.isObject(value)) <span class="keyword">return</span> _.matcher(value);</div><div class="line">    <span class="comment">// 返回获取对象属性的函数，比如</span></div><div class="line">    <span class="comment">// var results = _.map([&#123;name: 'qq'&#125;, &#123;name: 'ww'&#125;], 'name') =&gt; results: ['qq', 'ww']</span></div><div class="line"><span class="keyword">return</span> _.property(value);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>首先是 <code>buildinIteratee</code> 这东西，这要结合下面这个来看<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.iteratee = builtinIteratee = <span class="function"><span class="keyword">function</span>(<span class="params">value, context</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> cb(value, context, <span class="literal">Infinity</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个是给用户自定义迭代规则用的。怎么自定义呢，比如这样<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">_.iteratee = <span class="function"><span class="keyword">function</span>(<span class="params">value, context</span>) </span>&#123;</div><div class="line">  <span class="comment">// value 为对象时返回自身</span></div><div class="line">  <span class="keyword">if</span> (value == <span class="literal">null</span> || _.isObject(value)) <span class="keyword">return</span> _.identity;</div><div class="line">  <span class="keyword">if</span> (_.isFunction(value)) <span class="keyword">return</span> optimizeCb(value, context, argCount);</div><div class="line">  <span class="keyword">return</span> _.property(value);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>还有 <code>identity</code> 其实就这样，返回一个返回自身的函数…<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Keep the identity function around for default iteratees.</span></div><div class="line">_.identity = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> value;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>我们自定义的这个迭代规则，如果 <code>value</code> 不为空而且是对象，则返回一个可以返回自身的函数。注意我们改变的只是 <code>iteratee</code> 函数，<code>builtinIteratee</code> 存的是默认规则，在 <code>cb</code> 函数中如果发现 <code>iteratee</code> 的行为更改了，则使用更改的行为来处理，否则往下默认处理，上面已经备注的很清楚了，自己看吧。<br>我们举个例子说下 <code>cb</code> 函数的用法，例如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">_.map = _.collect = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) </span>&#123;</div><div class="line">    iteratee = cb(iteratee, context);</div><div class="line">    <span class="keyword">var</span> keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</div><div class="line">        length = (keys || obj).length,</div><div class="line">        results = <span class="built_in">Array</span>(length);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</div><div class="line">      <span class="keyword">var</span> currentKey = keys ? keys[index] : index;</div><div class="line">      results[index] = iteratee(obj[currentKey], currentKey, obj);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>注意我们是怎么使用 map 的，比如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> results = _.map([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function"><span class="keyword">function</span>(<span class="params">value, index, obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'['</span>+obj+<span class="string">']'</span> + <span class="string">'\'s '</span>+index+<span class="string">' position is '</span>+value;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>我们使用 map 传入两个参数，一个是迭代对象，这里是 <code>[1, 2, 3]</code>，第二个参数是迭代函数，这里是 <code>function (value, index, obj){...}</code>。这个函数在 map 内部也就是 <code>iteratee</code>，然后我们再来看<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iteratee = cb(iteratee, context)</div></pre></td></tr></table></figure></p>
<p><code>iteratee</code> 是一个函数，使用上面这个句子返回了 <code>optimizeCb(value, context, argCount)</code>，这里的 <code>value</code> 就对应了我们的 <code>function(value, index, obj){...}</code> 函数。接着回到 map，他对对象进行遍历依次把通过调用 <code>iteratee</code> 也就是我们传入的函数得到的结果复制给 <code>result</code>，最后返回了 <code>result</code>。<br>所以上面例子的结果是<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">results:  [</div><div class="line">    <span class="string">"[1,2,3]'s 0 position is 1"</span>, </div><div class="line">    <span class="string">"[1,2,3]'s 1 position is 2"</span>, </div><div class="line">    <span class="string">"[1,2,3]'s 2 position is 3"</span></div><div class="line">];</div></pre></td></tr></table></figure></p>
<p>一定要理解 cb 和 optimizeCb 这两个的用法，他们在后面多次用到。好了，完了～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Underscore 源码的学习落下了好几天，因为前几天一直正在重构项目和搞 React，不过这几天应该会花较多时间在 Underscore 上面了。&lt;br&gt;这次主要说下 Underscore 两个比较重要的函数吧，一个是&lt;code&gt;optimizeCb&lt;/code&gt;，另一个是&lt;code&gt;cb&lt;/code&gt;，这两个花了我挺长时间看的，而且是整个 Underscore 非常重要的函数，后面很多地方都使用到了它。&lt;/p&gt;
&lt;h2 id=&quot;optimizeCb-函数&quot;&gt;&lt;a href=&quot;#optimizeCb-函数&quot; class=&quot;headerlink&quot; title=&quot;optimizeCb 函数&quot;&gt;&lt;/a&gt;optimizeCb 函数&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; optimizeCb = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;func, context, argCount&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (context === &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; func;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (argCount == &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; ? &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; : argCount) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;value&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; func.call(context, value);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;value, index, collection&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; func.call(context, value, index, collection);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;accumulator, value, index, collection&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; func.call(context, accumulator, value, index, collection);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; func.apply(context, &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个地方 &lt;code&gt;switch&lt;/code&gt; 只是一个性能的优化，其实简化来看就是这样的&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; optimizeCb = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;func, context, argCount&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (context === &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; func;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; func.apply(context, &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;之所以有那段 &lt;code&gt;switch&lt;/code&gt; 前面一篇已经有提到了，只是一个优化而已。使用 call 快于 apply。不过好像最新的 Chrome 已经可以自己优化这个过程，但为了提升性能，加上也无妨。&lt;br&gt;解释下段代码的意思，字如起名 optimizeCb 优化回调。这个函数传入三个参数依次是函数，上下文，参数个数。如果没有指定上下文则返回函数本身，如果有，则对该上下文绑定到传入的函数，根据传入的参数个数，在做一个性能优化。这个函数就是这个意思。我们看下他的使用。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;_.each = _.forEach = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj, iteratee, context&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  iteratee = optimizeCb(iteratee, context);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i, length;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isArrayLike(obj)) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, length = obj.length; i &amp;lt; length; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      iteratee(obj[i], i, obj);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; keys = _.keys(obj);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, length = keys.length; i &amp;lt; length; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      iteratee(obj[keys[i]], keys[i], obj);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; obj;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个函数是用来实现数组或者对象的遍历的，他是怎么做到呢？&lt;br&gt;首先是&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;iteratee = optimizeCb(iteratee, context);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Underscore" scheme="https://ruiming.github.io/categories/Underscore/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="Underscore" scheme="https://ruiming.github.io/tags/Underscore/"/>
    
  </entry>
  
  <entry>
    <title>一次项目重构</title>
    <link href="https://ruiming.github.io/2016/07/26/%E4%B8%80%E6%AC%A1%E9%A1%B9%E7%9B%AE%E9%87%8D%E6%9E%84/"/>
    <id>https://ruiming.github.io/2016/07/26/一次项目重构/</id>
    <published>2016-07-26T11:57:36.000Z</published>
    <updated>2016-08-04T09:29:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>上学期由于期末停工的项目又要继续开展了，然而停了一个多月的时间，我已经看不下去他的代码了，简直惨不忍睹，花了我将近40个小时的时间去做了重构。虽然重构说明有进步了，但是一改就要改几十个页面啊…累觉不爱..说一说这次将近40小时的重构吧。<br><img src="/2016/07/26/一次项目重构/git-diff.jpg" alt="git-diff" title="git-diff"></p>
<h2 id="Angular-重构"><a href="#Angular-重构" class="headerlink" title="Angular 重构"></a>Angular 重构</h2><p>项目是基于 Angular 的 SPA，项目参考<a href="https://github.com/johnpapa/angular-styleguide/blob/master/a1/i18n/zh-CN.md" target="_blank" rel="external">Angular规范</a>进行重构，主要是以下几点：</p>
<ul>
<li>把控制器的业务逻辑(主要是 HTTP 请求)分离到 Factory</li>
<li>Controller 和 Directive 以及 Factory 全部用立即函数包装</li>
<li>Controller 和 Directive 以及 Factory 内部书写格式</li>
<li>使用 controllerAs 代替 $scope </li>
<li>全部 JavaScript 文件使用 use strict 严格模式</li>
<li>利用单体做部分数据的缓存</li>
<li>提取大部分可复用模块到 directive</li>
<li>全部 ng-repeat 加上 track by</li>
<li>过大的试图使用 ng-include 进行分离</li>
<li>去掉全部辅助变量，用 angular-promise-buttons 来达到按钮状态变化</li>
<li>去掉全部页面切换动画</li>
<li>手动进行依赖注入</li>
<li>使用 ES6 语法，用 babel 转为 ES5</li>
<li>使用 eslint 来做代码格式检查</li>
</ul>
<p>之前我几乎没有使用 Factory 这一层，全部业务逻辑都在 Controller 里面做，随着项目越来越大(有26个页面)，页面之间函数重复的情况很多，而且控制器太厚，可读性差，给维护带来了巨大的困难。在这次重构之中，我把全部的 HTTP 请求全部放在 Factory 实现，从而做到了以下几点：</p>
<ul>
<li>函数复用，多个控制器用一个 Factory，避免同个函数多次书写</li>
<li>HTTP 请求返回 promise，结合 angular-promise-buttons 做到了按钮状态的自动变化以及过渡效果，去掉了先前实现同样目的的全部辅助变量</li>
<li>对部分相对不变的数据，在第一次缓存后直接在该 Factory 进行缓存，第二次获取的时候直接返回内存中的数据，加快了部分页面的二次加载速度，对跨页面你的同个请求同样有效</li>
<li>容易做单元测试和更改逻辑，因为全部 HTTP 请求都放在 Factory 实现，对后期修改以及代码测试都带来了很大的方便</li>
</ul>
<a id="more"></a>
<p>举个例子，这是我项目中的部分代码，现在是能拿出手了，以前的代码我都不能再吐槽了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** IndexCtrl.js */</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;                   <span class="comment">// 立即执行函数，避免作用域污染</span></div><div class="line"><span class="meta">    'use strict'</span>;               <span class="comment">// 严格模式，使代码更规范</span></div><div class="line">                                <span class="comment">// 空一行</span></div><div class="line">    angular                     <span class="comment">// Angular控制器定义，控制器函数使用命名行数</span></div><div class="line">        .module(<span class="string">'index'</span>)</div><div class="line">        .controller(<span class="string">'IndexCtrl'</span>, IndexCtrl);</div><div class="line"></div><div class="line">    IndexCtrl.$inject = [<span class="string">'bookservice'</span>, <span class="string">'booklistservice'</span>, <span class="string">'slideservice'</span>];     <span class="comment">// 手动依赖注入</span></div><div class="line">                                                                                <span class="comment">// 再空一行</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">IndexCtrl</span>(<span class="params">bookservice, booklistservice, slideservice</span>) </span>&#123;            <span class="comment">// 控制器函数</span></div><div class="line">        <span class="keyword">var</span> vm = <span class="keyword">this</span>;                                                          <span class="comment">// 不使用$scope</span></div><div class="line">        vm.myInterval = <span class="number">5000</span>;</div><div class="line"></div><div class="line">        vm.getHotBooklists = getHotBooklists;                                   <span class="comment">// 置顶绑定成员，函数声明隐藏实现细节</span></div><div class="line">        </div><div class="line">        getPopularBooks();                                                      <span class="comment">// 即时只使用一次，也推荐封装成函数</span></div><div class="line">        getSlides();</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getPopularBooks</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> bookservice.getPopularBooks().then(response =&gt; &#123;</div><div class="line">                vm.books = response;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getHotBooklists</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> booklistservice.getHotBooklists().then(response =&gt; &#123;</div><div class="line">                vm.booklists = response;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getSlides</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> slideservice.getSlides().then(response =&gt; &#123;</div><div class="line">                vm.slides = response;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>然后是 Factory 文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** SlideService.js */</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta">    'use strict'</span>;</div><div class="line"></div><div class="line">    angular</div><div class="line">        .module(<span class="string">'index'</span>)</div><div class="line">        .factory(<span class="string">'slideservice'</span>, slideservice);</div><div class="line"></div><div class="line">    slideservice.$inject = [<span class="string">'$http'</span>, <span class="string">'$q'</span>];</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">slideservice</span>(<span class="params">$http, $q</span>) </span>&#123;</div><div class="line">        <span class="keyword">let</span> slides = <span class="literal">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            getSlides: getSlides</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getSlides</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span>(slides === <span class="literal">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> $http.get(host + <span class="string">'/slides'</span>)</div><div class="line">                    .then(response =&gt; &#123;</div><div class="line">                        slides = response.data;         <span class="comment">// 第一次获取后存入内存</span></div><div class="line">                        <span class="keyword">return</span> slides;</div><div class="line">                    &#125;);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">let</span> deferred = $q.defer();</div><div class="line">                deferred.resolve(slides);</div><div class="line">                <span class="keyword">return</span> deferred.promise;                <span class="comment">// 将数据封装入promise返回，保证透明性</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>directive 就不给示例了，上面主要参考了这个<a href="https://github.com/johnpapa/angular-styleguide/blob/master/a1/i18n/zh-CN.md" target="_blank" rel="external">Angular规范</a>。这样写真的比我之前写的好了几百倍，controller 和 factory 和 directive 都按这个规范来，代码会很好维护。</p>
<p>这次重构让我知道我以前写的根本不叫 Angular，写的是一坨翔，MLGB 害我改了四天。</p>
<h2 id="HTML-重构"><a href="#HTML-重构" class="headerlink" title="HTML 重构"></a>HTML 重构</h2><p>其实说白了也是 Angular 重构，在上面的 Angular 重构已经提到了一些了，但是上面主要是说 controller 和 factory，这里说下 directive 和视图。</p>
<h3 id="部分页面复用"><a href="#部分页面复用" class="headerlink" title="部分页面复用"></a>部分页面复用</h3><p>在 Angular 中，HTML 部分复用有两种方案，一种是使用 ng-include，还有一种是使用 directive，其实区别很简单，ng-include 只是很简单的 HTML 复用，而 directive 你可以传递参数，directive 可以有自己的控制器，可以操纵 DOM，其实就是 HTML 和 JavaScript 文件的区别。不过这只是 directive 在页面复用这一块的作用，其实 directive 强大的很。</p>
<h3 id="使用-ng-repeat-都带上-track-by"><a href="#使用-ng-repeat-都带上-track-by" class="headerlink" title="使用 ng-repeat 都带上 track by"></a>使用 ng-repeat 都带上 track by</h3><p>对于 ng-repeat 使用 track by 可以提升性能，对于任何 ng-repeat 都加上 track by 是一个好习惯。比如<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">ng-repeat</span>=<span class="string">"book in vm.books track by book.isbn"</span>&gt;</span>&#123;&#123;book.title&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>也可以直接使用 track by $index。</p>
<h3 id="使用-controllerAs"><a href="#使用-controllerAs" class="headerlink" title="使用 controllerAs"></a>使用 controllerAs</h3><p>直接在路由使用 controllerAs<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">.state(<span class="string">'index'</span>, &#123;</div><div class="line">    url: <span class="string">'/'</span>,</div><div class="line">    views: &#123;</div><div class="line">        <span class="string">'main'</span>: &#123;</div><div class="line">            templateUrl: <span class="string">'index/index_tpl.html'</span>,</div><div class="line">            controller: <span class="string">'IndexCtrl'</span>,</div><div class="line">            controllerAs: <span class="string">'vm'</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>然后在视图中就像上面的例子，在访问控制器的变量和方法的时候都要带上 vm，虽然这样会稍微麻烦了一点，但是可以避免很多坑，而且这种写法更接近 JavaScript 原生的写法。</p>
<h2 id="CSS-重构"><a href="#CSS-重构" class="headerlink" title="CSS 重构"></a>CSS 重构</h2><p>恩，CSS 重构才是真正的大坑，先说下我之前是怎么写 CSS 代码的</p>
<ul>
<li>使用了 Sass 预处理器</li>
<li>多层嵌套</li>
<li>命名混乱</li>
<li>过多复用</li>
<li>全部挤在一个文件</li>
</ul>
<p>恩，挤在一个文件里面是最要命的，而且很任性的进行嵌套，导致多了或者少了一层都可能出问题，而且是2000多行的代码…所以我其实并没有做什么重构，我把它从一个文件分成了很多个文件，每个视图一个专属 scss 文件，对于复用的部分页面，用 directive 替代，并给该 directive 专属的 scss 文件。<br>怎么做到专属呢，就是每个视图和每个 scss 都包装在一个类名里面，这样就保证了 scss 代码互不干扰。<br>所以，其实我做的只是便于后期书写而已，总不能继续在这个文件书写下去，大坑啊。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上学期由于期末停工的项目又要继续开展了，然而停了一个多月的时间，我已经看不下去他的代码了，简直惨不忍睹，花了我将近40个小时的时间去做了重构。虽然重构说明有进步了，但是一改就要改几十个页面啊…累觉不爱..说一说这次将近40小时的重构吧。&lt;br&gt;&lt;img src=&quot;/2016/07/26/一次项目重构/git-diff.jpg&quot; alt=&quot;git-diff&quot; title=&quot;git-diff&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Angular-重构&quot;&gt;&lt;a href=&quot;#Angular-重构&quot; class=&quot;headerlink&quot; title=&quot;Angular 重构&quot;&gt;&lt;/a&gt;Angular 重构&lt;/h2&gt;&lt;p&gt;项目是基于 Angular 的 SPA，项目参考&lt;a href=&quot;https://github.com/johnpapa/angular-styleguide/blob/master/a1/i18n/zh-CN.md&quot;&gt;Angular规范&lt;/a&gt;进行重构，主要是以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把控制器的业务逻辑(主要是 HTTP 请求)分离到 Factory&lt;/li&gt;
&lt;li&gt;Controller 和 Directive 以及 Factory 全部用立即函数包装&lt;/li&gt;
&lt;li&gt;Controller 和 Directive 以及 Factory 内部书写格式&lt;/li&gt;
&lt;li&gt;使用 controllerAs 代替 $scope &lt;/li&gt;
&lt;li&gt;全部 JavaScript 文件使用 use strict 严格模式&lt;/li&gt;
&lt;li&gt;利用单体做部分数据的缓存&lt;/li&gt;
&lt;li&gt;提取大部分可复用模块到 directive&lt;/li&gt;
&lt;li&gt;全部 ng-repeat 加上 track by&lt;/li&gt;
&lt;li&gt;过大的试图使用 ng-include 进行分离&lt;/li&gt;
&lt;li&gt;去掉全部辅助变量，用 angular-promise-buttons 来达到按钮状态变化&lt;/li&gt;
&lt;li&gt;去掉全部页面切换动画&lt;/li&gt;
&lt;li&gt;手动进行依赖注入&lt;/li&gt;
&lt;li&gt;使用 ES6 语法，用 babel 转为 ES5&lt;/li&gt;
&lt;li&gt;使用 eslint 来做代码格式检查&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之前我几乎没有使用 Factory 这一层，全部业务逻辑都在 Controller 里面做，随着项目越来越大(有26个页面)，页面之间函数重复的情况很多，而且控制器太厚，可读性差，给维护带来了巨大的困难。在这次重构之中，我把全部的 HTTP 请求全部放在 Factory 实现，从而做到了以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数复用，多个控制器用一个 Factory，避免同个函数多次书写&lt;/li&gt;
&lt;li&gt;HTTP 请求返回 promise，结合 angular-promise-buttons 做到了按钮状态的自动变化以及过渡效果，去掉了先前实现同样目的的全部辅助变量&lt;/li&gt;
&lt;li&gt;对部分相对不变的数据，在第一次缓存后直接在该 Factory 进行缓存，第二次获取的时候直接返回内存中的数据，加快了部分页面的二次加载速度，对跨页面你的同个请求同样有效&lt;/li&gt;
&lt;li&gt;容易做单元测试和更改逻辑，因为全部 HTTP 请求都放在 Factory 实现，对后期修改以及代码测试都带来了很大的方便&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Angular" scheme="https://ruiming.github.io/categories/Angular/"/>
    
    
      <category term="Angular" scheme="https://ruiming.github.io/tags/Angular/"/>
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 闭包，继承与原型链</title>
    <link href="https://ruiming.github.io/2016/07/22/JavaScript%E9%97%AD%E5%8C%85%EF%BC%8C%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://ruiming.github.io/2016/07/22/JavaScript闭包，继承与原型链/</id>
    <published>2016-07-22T07:03:23.000Z</published>
    <updated>2016-10-26T14:54:36.818Z</updated>
    
    <content type="html"><![CDATA[<p> JavaScript 闭包和原型链学习心得，如果有不对的地方望指出。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>什么是闭包，有很多说法，我的理解是一个函数可以记住和使用外部变量，保存这个变量的引用在自己的一个环境之中。<br>例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x + y;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> add5 = makeAdder(<span class="number">5</span>);</div><div class="line"><span class="keyword">var</span> add10 = makeAdder(<span class="number">10</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(add5(<span class="number">2</span>));  <span class="comment">// 7</span></div><div class="line"><span class="built_in">console</span>.log(add10(<span class="number">2</span>)); <span class="comment">// 12</span></div></pre></td></tr></table></figure></p>
<p>这个例子中， makeAdder 是一个函数工厂，add5 和 add10 就是闭包，他们记住了外部变量 x。通常一个函数执行完毕后其运行期上下文会被释放，但由于闭包的属性包含了与运行期上下文作用域链相同的对象引用，导致这个激活对象无法销毁，这就会导致内存消耗，另外，闭包内部的作用域链并不处在闭包作用域链的前端，并且闭包经常使用外部变量的话，导致对象属性的遍历经常到其原型上面去（一个解决方法是把他赋值到闭包自身的作用域上面），从而增加性能消耗。<br>既然闭包会导致内存增加和性能消耗，那为什么那么多人还使用它呢？上面的例子可能不太能说明问题，我们看下其他例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Counter = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeBy</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">    privateCounter += val;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      changeBy(<span class="number">1</span>);</div><div class="line">    &#125;,</div><div class="line">    decrement: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      changeBy(<span class="number">-1</span>);</div><div class="line">    &#125;,</div><div class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> privateCounter;</div><div class="line">    &#125;</div><div class="line">  &#125;   </div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(Counter.value()); <span class="comment">/* logs 0 */</span></div><div class="line">Counter.increment();</div><div class="line">Counter.increment();</div><div class="line"><span class="built_in">console</span>.log(Counter.value()); <span class="comment">/* logs 2 */</span></div><div class="line">Counter.decrement();</div><div class="line"><span class="built_in">console</span>.log(Counter.value()); <span class="comment">/* logs 1 */</span></div></pre></td></tr></table></figure></p>
<p>这个例子中外部只能通过 value 方法获取 privateCounter 的值，只能通过 increment 和 decrement 方法来改变 privateCounter 的值，无法直接获取到 priavateCounter 和调用 changeBy 函数。这种模式叫 module模式，因为大部分模块都是这样写的，包括 Underscore 也是这样。上篇中就说道了 Underscore 使用了立即执行函数，其用途其一是为了不污染外部变量，因为 JavaScript 是函数作用域，其次它利用了闭包的特性又可以保持函数内部闭包的可调用和被闭包所引用变量在闭包环境中的存在，同时函数内部可以定义一些私有变量和私有方法。我们无需担心这些变量和函数在外部函数执行完毕结束后的失效。<br>当你看到函数里面又 return 函数时，同时该函数又使用了外部变量，则该函数就是一个闭包。<br>关于闭包还有一个很容易犯错的地方，比如你想实现第一秒输出1,第二秒输出2,以此类推。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(i);</div><div class="line">    &#125;, i*<span class="number">1000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是实际运行结果是第一秒输出6,第二秒输出6…<br>闭包是记住了外部变量的引用，每次循环都建立了一个 timer 函数，但 console 并还没有被执行，当循环结束后确实是建立了5个计时器或者说5个闭包，但当开始执行 console 的时候，由于这些闭包所引用的 i 此时结果为6，所以会输出5次 6。<br>更能说明问题些，我们稍作修改下：<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(i);</div><div class="line">        i++;</div><div class="line">    &#125;, i*<span class="number">1000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果是第一秒输出1，第二秒输出2…<br>我们也可以这么做<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">    <span class="keyword">let</span> j = i;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(j);</div><div class="line">    &#125;, j*<span class="number">1000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>或者这样做</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span> ; i++) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123; </div><div class="line">    	<span class="built_in">console</span>.log(i); </div><div class="line">    &#125;, i*<span class="number">1000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果和上面一样，第一秒输出1，第二秒输出2…</p>
<p>这是为什么呢？第二个例子说明了闭包内使用的是外部变量的引用，他们都使用了同一个引用，所以最终输出取决与此时这个引用的值。第三个例子，每次循环都会新建一个变量 j，分别被每个闭包所引用，这些引用互不干扰，我们可以在 console.log(j) 后面加上 j++，结果是不会有变化的。</p>
<h2 id="继承与原型链"><a href="#继承与原型链" class="headerlink" title="继承与原型链"></a>继承与原型链</h2><blockquote>
<p>在 javaScript 中，每个对象都有一个指向它的原型（prototype）对象的内部链接。这个原型对象又有自己的原型，直到某个对象的原型为 null 为止（也就是不再有原型指向），组成这条链的最后一环。这种一级一级的链结构就称为原型链（prototype chain）。</p>
</blockquote>
<p>第一次接触 JavaScript 的原型链是在使用 Angular 的时候，如果有看到前面我的一篇写 Angular 的就会看到。在使用 Angular 的 ngIf 和 textarea 时，会创建新的子作用域，子作用域的原型是父级作用域一般就是 scope，以 textarea 为例子，假设一个用户修改评论的 textarea 框，我们首先把原先的评论写了回去，假设我们这样使用<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">ng-model</span>=<span class="string">"content"</span>, <span class="attr">name</span>=<span class="string">"content"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">row</span>=<span class="string">"3"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>我们把用户的评论内容放到 $scope.content 里面去。<br>结果是我们可以看到 textarea 确实一开始就被填入了用户原先的评论，可是如果此时我们更改 textarea 内部的内容，然后提交修改。你会发现 $scope.content 没有发生变化。<br>这是因为 Angular 默认在 textarea 创建了一个新的子作用域，这个作用域本身一开始并不存在 content 这个值，即没有 hasOwnProperty(‘content’)，但他并不会因此就不做显示了，他会去找其原型，一般是 scope (如果在 ng-if 使用了 textarea，则其原型的原型才是 scope )，如果原型存在 content 则继承原型。所以你会看到初始状态是没问题的，当你修改评论内容时候，此时 textarea 自身的作用与就会新建了一个 content，内容就为你的评论内容，而其原型的 scope 将不再被使用，也不会被修改，所以你会发现 $scope.content 并没有发生变化。<br>如果 textarea 的原型也不存在 content，它会再往上找，直到原型链最顶端为止，处在原型链最顶端的对象的原型是 null。<br>以 Angular 的这个例子，我们就介绍完了 JavaScript 的原型链和继承，我们再举个例子说明下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stu = &#123;name: <span class="string">"stu"</span>, age: <span class="number">18</span>, school: <span class="string">"SCNU"</span>&#125;;</div><div class="line"><span class="keyword">var</span> father = &#123;name: <span class="string">"parent"</span>, age: <span class="number">40</span>, job: <span class="string">"engineer"</span>, company: <span class="string">"Google"</span>&#125;;</div><div class="line">stu.__proto__ = father;</div><div class="line"><span class="built_in">console</span>.log(stu.job)    <span class="comment">/* logs "engineer" */</span></div><div class="line">stu.job = <span class="string">"student"</span></div><div class="line"><span class="built_in">console</span>.log(stu.job)    <span class="comment">/* logs "student" */</span></div><div class="line"><span class="built_in">console</span>.log(father.job) <span class="comment">/* logs "engineer" */</span></div><div class="line"><span class="keyword">for</span>( prop <span class="keyword">in</span> stu ) &#123;</div><div class="line">    <span class="built_in">console</span>.log(stu.prop);  <span class="comment">/* logs stu, 18, SCNU, student, Google */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用for…in…会遍历对象的所有属性，一个解决方法是使用 hasOwnProperty 判断是否是该层的属性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; JavaScript 闭包和原型链学习心得，如果有不对的地方望指出。&lt;/p&gt;
&lt;h2 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;闭包&lt;/h2&gt;&lt;p&gt;什么是闭包，有很多说法，我的理解是一个函数可以记住和使用外部变量，保存这个变量的引用在自己的一个环境之中。&lt;br&gt;例如：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;makeAdder&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;y&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x + y;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; add5 = makeAdder(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; add10 = makeAdder(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(add5(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));  &lt;span class=&quot;comment&quot;&gt;// 7&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(add10(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)); &lt;span class=&quot;comment&quot;&gt;// 12&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个例子中， makeAdder 是一个函数工厂，add5 和 add10 就是闭包，他们记住了外部变量 x。通常一个函数执行完毕后其运行期上下文会被释放，但由于闭包的属性包含了与运行期上下文作用域链相同的对象引用，导致这个激活对象无法销毁，这就会导致内存消耗，另外，闭包内部的作用域链并不处在闭包作用域链的前端，并且闭包经常使用外部变量的话，导致对象属性的遍历经常到其原型上面去（一个解决方法是把他赋值到闭包自身的作用域上面），从而增加性能消耗。&lt;br&gt;既然闭包会导致内存增加和性能消耗，那为什么那么多人还使用它呢？上面的例子可能不太能说明问题，我们看下其他例子。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; Counter = (&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; privateCounter = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;changeBy&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;val&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    privateCounter += val;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    increment: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      changeBy(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    decrement: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      changeBy(&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    value: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; privateCounter;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;   &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(Counter.value()); &lt;span class=&quot;comment&quot;&gt;/* logs 0 */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Counter.increment();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Counter.increment();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(Counter.value()); &lt;span class=&quot;comment&quot;&gt;/* logs 2 */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Counter.decrement();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(Counter.value()); &lt;span class=&quot;comment&quot;&gt;/* logs 1 */&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个例子中外部只能通过 value 方法获取 privateCounter 的值，只能通过 increment 和 decrement 方法来改变 privateCounter 的值，无法直接获取到 priavateCounter 和调用 changeBy 函数。这种模式叫 module模式，因为大部分模块都是这样写的，包括 Underscore 也是这样。上篇中就说道了 Underscore 使用了立即执行函数，其用途其一是为了不污染外部变量，因为 JavaScript 是函数作用域，其次它利用了闭包的特性又可以保持函数内部闭包的可调用和被闭包所引用变量在闭包环境中的存在，同时函数内部可以定义一些私有变量和私有方法。我们无需担心这些变量和函数在外部函数执行完毕结束后的失效。&lt;br&gt;当你看到函数里面又 return 函数时，同时该函数又使用了外部变量，则该函数就是一个闭包。&lt;br&gt;关于闭包还有一个很容易犯错的地方，比如你想实现第一秒输出1,第二秒输出2,以此类推。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt;= &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;timer&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(i);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;, i*&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但是实际运行结果是第一秒输出6,第二秒输出6…&lt;br&gt;闭包是记住了外部变量的引用，每次循环都建立了一个 timer 函数，但 console 并还没有被执行，当循环结束后确实是建立了5个计时器或者说5个闭包，但当开始执行 console 的时候，由于这些闭包所引用的 i 此时结果为6，所以会输出5次 6。&lt;br&gt;更能说明问题些，我们稍作修改下：&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://ruiming.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Underscore 源码学习(一)</title>
    <link href="https://ruiming.github.io/2016/07/20/Underscore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"/>
    <id>https://ruiming.github.io/2016/07/20/Underscore源码学习(一)/</id>
    <published>2016-07-20T07:52:11.000Z</published>
    <updated>2016-08-04T09:12:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>暑假打算研究一下 Underscore 源码，我会对一些我觉得比较有意思的点拿出来讨论下，不过我不会过多介绍，也不会去分析 Underscore 的各个方法，但我会附上一些相关的不错的参考资料。由于我也是初学阶段，所以如果有说的不正确的地方望指出。</p>
<h2 id="要点1：立即执行函数"><a href="#要点1：立即执行函数" class="headerlink" title="要点1：立即执行函数"></a>要点1：立即执行函数</h2><p>Underscore 的内容都用这么一个东西包装起来了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;..&#125;());</div></pre></td></tr></table></figure></p>
<p>其实也可以这样写<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)();</div></pre></td></tr></table></figure></p>
<p>Underscore 把全部内容封装在立即执行函数里面，就形成了一个独立的作用域，与外部隔离，并且这样做还形成了闭包，可以模拟私有方法。<br>推荐阅读：</p>
<ul>
<li><a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/" target="_blank" rel="external">immediately-invoked-function-expression(英)</a></li>
<li><a href="http://www.cnblogs.com/tomxu/archive/2011/12/31/2289423.html" target="_blank" rel="external">immediately-invoked-function-expression(中)</a></li>
<li><a href="https://segmentfault.com/a/1190000003902899" target="_blank" rel="external">JavaScript中的立即执行函数</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" target="_blank" rel="external">Closures</a></li>
</ul>
<h2 id="要点2：兼容浏览器和-Node-环境"><a href="#要点2：兼容浏览器和-Node-环境" class="headerlink" title="要点2：兼容浏览器和 Node 环境"></a>要点2：兼容浏览器和 Node 环境</h2><p>浏览器和服务端的一个主要区别是全局对象命名的不同，在浏览器全局变量是 window，在服务端即 Node 环境则是 global。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> root = <span class="keyword">typeof</span> self == <span class="string">'object'</span> &amp;&amp; self.self === self &amp;&amp; self ||</div><div class="line">           <span class="keyword">typeof</span> global == <span class="string">'object'</span> &amp;&amp; global.global === global &amp;&amp; global ||</div><div class="line">           <span class="keyword">this</span>;</div></pre></td></tr></table></figure></p>
<p>这个地方之前的写法是这样的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> root = <span class="keyword">this</span>;</div></pre></td></tr></table></figure></p>
<p>我认为之所以改成前面那种写法，可能是为了确保 root 指向 global 或者 window(self) 。大部分框架和库都采用这种做法，这种做法更加安全。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这一步确保self是一个object，这样self.self才不会出错</span></div><div class="line"><span class="keyword">typeof</span> self == <span class="string">'object'</span></div><div class="line"><span class="comment">// 这一步确保self.self严格等于自身，貌似只有window具备这个特性</span></div><div class="line"><span class="comment">// 即window === window.window.window</span></div><div class="line">self.self === self</div><div class="line"><span class="comment">// 为什么还要进行这一步？</span></div><div class="line">self</div></pre></td></tr></table></figure></p>
<p>推荐阅读：</p>
<ul>
<li><a href="https://zzz.buzz/2016/06/30/the-global-object-in-various-javascript-environments/" target="_blank" rel="external">The Global Object in Various JavaScript Environments</a></li>
</ul>
<h2 id="要点3：提供命名冲突解决方法"><a href="#要点3：提供命名冲突解决方法" class="headerlink" title="要点3：提供命名冲突解决方法"></a>要点3：提供命名冲突解决方法</h2><p>Underscore 在给 root 赋值前，先保存了原先 root 的 <code>_</code> 对象。之所以这样做，是因为可能我们用的其他库也使用了 <code>_</code> 这个作为命名空间。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> previousUnderscore = root._;</div></pre></td></tr></table></figure></p>
<p>我们结合 Underscore 最下面的这个方法来看。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_.noConflict = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    root._ = previousUnderscore;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>如果 <code>_</code> 出现了冲突，可以使用下面方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _new = _.noConflict();</div></pre></td></tr></table></figure></p>
<p>这样一来应该很明显了，<code>noConflict</code> 将 <code>previousUnderscore</code> 即原先的 <code>root._</code> 重新放回去，然后重新定义 Underscore 命名给 <code>_new</code>，这样就解决了 <code>_</code> 冲突问题。</p>
<a id="more"></a>
<h2 id="要点4：考虑压缩问题"><a href="#要点4：考虑压缩问题" class="headerlink" title="要点4：考虑压缩问题"></a>要点4：考虑压缩问题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ArrayProto = <span class="built_in">Array</span>.prototype, ObjProto = <span class="built_in">Object</span>.prototype;</div><div class="line"><span class="keyword">var</span> SymbolProto = <span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">'undefined'</span> ? <span class="built_in">Symbol</span>.prototype : <span class="literal">null</span>;</div><div class="line"><span class="keyword">var</span> push = ArrayProto.push,</div><div class="line">    slice = ArrayProto.slice,</div><div class="line">    toString = ObjProto.toString,</div><div class="line">    hasOwnProperty = ObjProto.hasOwnProperty;</div></pre></td></tr></table></figure>
<p>这里首先说一下<code>Symbol</code>，ES5 规定了六种语言类型即 Null, Undefined, Number, Boolean, String, Object，而新出台的 ES6 则新增了 Symbol。关于 Symbol 查看推荐阅读。<br>这里把 Array 和 Object 和 Symbol 的原型都用变量来引用的原因是变量可以进行压缩，如果有使用过代码压缩工具的话，一个常见的压缩技巧就是用短变量名代替长变量名，而对于一些出现频率高的方法我们可以用变量来进行引用来便于压缩。<br>而 push, slice, toString, hasOwnProperty 这些引用不仅便于压缩，还可以减少在原型链中的查找次数，提高速度。即直接在原型上操作，避免原型链查找。关于原型链是个大问题了，这里不打算过多讲解（其实是我也不怎么懂），下一篇再进行介绍。<br>还有一个地方顺便提一下的是，Underscore 的源码不使用 undefined 而是使用 <code>void  0</code>。这个也是代码压缩的时候会做的事情。虽然从 ES5 开始 undefined 是全局对象的只读属性不能重写，但是在局部作用域中仍然可以被重写，而 <code>void</code> 运算符能对给定的表达式进行求值，然后返回 undefined，可以保证返回的是 undefined，<code>void</code>不能重写。再者，之所以跟的是0，只是因为0短并且习惯问题而已。<br>推荐阅读：</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/void" target="_blank" rel="external">operators-void</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank" rel="external">Symbol</a></li>
</ul>
<h2 id="要点5：区别apply-call和bind"><a href="#要点5：区别apply-call和bind" class="headerlink" title="要点5：区别apply, call和bind"></a>要点5：区别apply, call和bind</h2><p>在 Underscore 源码中我们会经常看到 apply 和 call 的应用。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (startIndex) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> func.call(<span class="keyword">this</span>, rest);</div><div class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> func.call(<span class="keyword">this</span>, <span class="built_in">arguments</span>[<span class="number">0</span>], rest);</div><div class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> func.call(<span class="keyword">this</span>, <span class="built_in">arguments</span>[<span class="number">0</span>], <span class="built_in">arguments</span>[<span class="number">1</span>], rest);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> args = <span class="built_in">Array</span>(startIndex + <span class="number">1</span>);</div><div class="line"><span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; startIndex; index++) &#123;</div><div class="line">    args[index] = <span class="built_in">arguments</span>[index];</div><div class="line">&#125;</div><div class="line">args[startIndex] = rest;</div><div class="line"><span class="keyword">return</span> func.apply(<span class="keyword">this</span>, args);</div></pre></td></tr></table></figure></p>
<p>apply 和 call 都是为了改变某个函数运行时的 context 即上下文而存在的，即改变函数提内部 this 的指向，他们的功能是相同的，只是用法稍有不同。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func1 = <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123;&#125;;</div><div class="line"><span class="comment">// 可以通过下面两个方法来调用</span></div><div class="line">func1.call(<span class="keyword">this</span>, arg1, arg2);</div><div class="line">func1.apply(<span class="keyword">this</span>, [arg1, arg2]);</div></pre></td></tr></table></figure></p>
<p>即 call 传递的是参数列表，而 apply 传递的是数组，当我们知道参数的数量时使用 call 方法，不知道参数数量时可以把参数放到一个数组然后使用 apply 方法调用。bind 也可以更改函数执行的上下文但是不同的是，bind 只进行绑定不会立即调用。<br>再看看上面 Underscore 源码中的一部分，对于<code>startIndex</code>小于3的情况，他分别使用了 call 方法调用，而当<code>startIndex</code>大于3的时候，则将参数转为数组形式使用 apply 方式调用。为什么不直接用 apply 方法呢？<br>简而言之，apply 比 call 慢。<br>对于 apply 方法，Function 会检查传入的参数的类型是否符合要求，还要进行解构操作等等。所以应该尽量使用 call 方法。<br>Underscore 源码关于这段代码还有个地方值得注意<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">startIndex = startIndex == <span class="literal">null</span> ? func.length - <span class="number">1</span> : +startIndex;</div></pre></td></tr></table></figure></p>
<p>为什么使用 <code>+startIndex</code>？<br><code>+</code>运算符尝试将后面的数转为数字，例如将字符串(“123”)转为数(123)，对数字不会产生影响，如果传入(“123NASD”)，会得到 NaN 。<br>推荐阅读：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/23769556/why-is-call-so-much-faster-than-apply/23770316#23770316" target="_blank" rel="external">why-is-call-so-much-faster-than-apply</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;暑假打算研究一下 Underscore 源码，我会对一些我觉得比较有意思的点拿出来讨论下，不过我不会过多介绍，也不会去分析 Underscore 的各个方法，但我会附上一些相关的不错的参考资料。由于我也是初学阶段，所以如果有说的不正确的地方望指出。&lt;/p&gt;
&lt;h2 id=&quot;要点1：立即执行函数&quot;&gt;&lt;a href=&quot;#要点1：立即执行函数&quot; class=&quot;headerlink&quot; title=&quot;要点1：立即执行函数&quot;&gt;&lt;/a&gt;要点1：立即执行函数&lt;/h2&gt;&lt;p&gt;Underscore 的内容都用这么一个东西包装起来了。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;..&amp;#125;());&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其实也可以这样写&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&amp;#125;)();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Underscore 把全部内容封装在立即执行函数里面，就形成了一个独立的作用域，与外部隔离，并且这样做还形成了闭包，可以模拟私有方法。&lt;br&gt;推荐阅读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://benalman.com/news/2010/11/immediately-invoked-function-expression/&quot;&gt;immediately-invoked-function-expression(英)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/tomxu/archive/2011/12/31/2289423.html&quot;&gt;immediately-invoked-function-expression(中)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000003902899&quot;&gt;JavaScript中的立即执行函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures&quot;&gt;Closures&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;要点2：兼容浏览器和-Node-环境&quot;&gt;&lt;a href=&quot;#要点2：兼容浏览器和-Node-环境&quot; class=&quot;headerlink&quot; title=&quot;要点2：兼容浏览器和 Node 环境&quot;&gt;&lt;/a&gt;要点2：兼容浏览器和 Node 环境&lt;/h2&gt;&lt;p&gt;浏览器和服务端的一个主要区别是全局对象命名的不同，在浏览器全局变量是 window，在服务端即 Node 环境则是 global。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; root = &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; self == &lt;span class=&quot;string&quot;&gt;&#39;object&#39;&lt;/span&gt; &amp;amp;&amp;amp; self.self === self &amp;amp;&amp;amp; self ||&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; global == &lt;span class=&quot;string&quot;&gt;&#39;object&#39;&lt;/span&gt; &amp;amp;&amp;amp; global.global === global &amp;amp;&amp;amp; global ||&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个地方之前的写法是这样的&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; root = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我认为之所以改成前面那种写法，可能是为了确保 root 指向 global 或者 window(self) 。大部分框架和库都采用这种做法，这种做法更加安全。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 这一步确保self是一个object，这样self.self才不会出错&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; self == &lt;span class=&quot;string&quot;&gt;&#39;object&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 这一步确保self.self严格等于自身，貌似只有window具备这个特性&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 即window === window.window.window&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;self.self === self&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 为什么还要进行这一步？&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;self&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zzz.buzz/2016/06/30/the-global-object-in-various-javascript-environments/&quot;&gt;The Global Object in Various JavaScript Environments&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;要点3：提供命名冲突解决方法&quot;&gt;&lt;a href=&quot;#要点3：提供命名冲突解决方法&quot; class=&quot;headerlink&quot; title=&quot;要点3：提供命名冲突解决方法&quot;&gt;&lt;/a&gt;要点3：提供命名冲突解决方法&lt;/h2&gt;&lt;p&gt;Underscore 在给 root 赋值前，先保存了原先 root 的 &lt;code&gt;_&lt;/code&gt; 对象。之所以这样做，是因为可能我们用的其他库也使用了 &lt;code&gt;_&lt;/code&gt; 这个作为命名空间。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; previousUnderscore = root._;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们结合 Underscore 最下面的这个方法来看。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;_.noConflict = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    root._ = previousUnderscore;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;_&lt;/code&gt; 出现了冲突，可以使用下面方法&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; _new = _.noConflict();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这样一来应该很明显了，&lt;code&gt;noConflict&lt;/code&gt; 将 &lt;code&gt;previousUnderscore&lt;/code&gt; 即原先的 &lt;code&gt;root._&lt;/code&gt; 重新放回去，然后重新定义 Underscore 命名给 &lt;code&gt;_new&lt;/code&gt;，这样就解决了 &lt;code&gt;_&lt;/code&gt; 冲突问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Underscore" scheme="https://ruiming.github.io/categories/Underscore/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="Underscore" scheme="https://ruiming.github.io/tags/Underscore/"/>
    
  </entry>
  
  <entry>
    <title>ARP 攻击和无线网卡混杂模式</title>
    <link href="https://ruiming.github.io/2016/07/14/ARP%E6%94%BB%E5%87%BB%E5%92%8C%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://ruiming.github.io/2016/07/14/ARP攻击和无线网卡混杂模式/</id>
    <published>2016-07-14T04:32:41.000Z</published>
    <updated>2016-08-04T09:05:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>一次小小的 Hack 尝试…<br>前段时间换上了 Arch，就开始想这捣鼓一些黑科技。脑海中立即浮现出两个词， monitor 和 ARP 。</p>
<h2 id="ARP-攻击"><a href="#ARP-攻击" class="headerlink" title="ARP 攻击"></a>ARP 攻击</h2><p>学过计算机网络了，大概了解ARP攻击这么一回事，但是当我真正去试的时候，才发现局域网原来真的这么脆弱，因为进行ARP攻击实在太容易了。实际上就是几条命令的事情。</p>
<h3 id="主机发现和端口扫描"><a href="#主机发现和端口扫描" class="headerlink" title="主机发现和端口扫描"></a>主机发现和端口扫描</h3><p>进行攻击第一步当然就是找目标了。可以使用 nmap 这个工具来进行，这东西简直渗透利器。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nmap -sP <span class="number">192.168</span><span class="number">.1</span><span class="number">.0</span>/<span class="number">24</span></div></pre></td></tr></table></figure></p>
<p> 这样就可以扫描192.168.1.0这个网段里面的所有主机了，以 ping 方式扫描，当然他有很多参数很多用法，网上很多这方面的资料我就不叙述了。<br><img src="/2016/07/14/ARP攻击和无线网卡混杂模式/nmap.png" alt="Nmap扫描" title="Nmap扫描"></p>
<h3 id="发起攻击"><a href="#发起攻击" class="headerlink" title="发起攻击"></a>发起攻击</h3><p>如果是进行ARP攻击，那也是加多三条命令就搞定的事情。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> 1 &gt;&gt; /proc/sys/net/ipv4/ip_forward</div><div class="line">arpspoof -i wlp3s0 -t 192.168.1.110 192.168.1.1</div><div class="line">arpspoof -i wlp3s0 -t 192.168.1.1   192.168.1.110</div></pre></td></tr></table></figure></p>
<p>第一条是开启转发，不然会受害者流量到我们这里出不去就断网了。<br>第二条是告诉受害者说我是网管。<br>第三条是告诉网管我是受害者。<br>这样就完成了 ARP 欺骗，图片以后再补。这之后对方的网络就完全在你的监控之下了。这告诉我们使用 https 和不连接免费 wifi 的重要性!</p>
<h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><p>抓包推荐使用 wireshark 。具体就不介绍了=.=。你还可以使用 Driftnet 这东西来将对方访问的图片在你这边显示出来～</p>
<h2 id="监听空气包"><a href="#监听空气包" class="headerlink" title="监听空气包"></a>监听空气包</h2><p>大部分无线网卡都可以设置 monitor 模式，即无线网卡默认接受下全部经过他的以太网帧而不丢弃，这种方式可以抓到附近范围里面的所以以太网帧。在 Arch 下也是三条命令搞定的事情。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ifconfig wlp3s0 down</div><div class="line">iwconfig wlp3s0 mode monitor</div><div class="line">ifconfig wlp3s0 up</div></pre></td></tr></table></figure></p>
<p>接着同样开启 wireshark 抓包，你会发现很多802.11帧，不过这个并没有什么卵用，理论上应该对于没有加密的帧应该可以直接得到应用层报文才对，但是很奇怪我一直抓不到，即使是对于有加密的 Wifi，我填入 WAPKEY 解密也不行。这个有待继续研究。。。<br><a id="more"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一次小小的 Hack 尝试…&lt;br&gt;前段时间换上了 Arch，就开始想这捣鼓一些黑科技。脑海中立即浮现出两个词， monitor 和 ARP 。&lt;/p&gt;
&lt;h2 id=&quot;ARP-攻击&quot;&gt;&lt;a href=&quot;#ARP-攻击&quot; class=&quot;headerlink&quot; title=&quot;ARP 攻击&quot;&gt;&lt;/a&gt;ARP 攻击&lt;/h2&gt;&lt;p&gt;学过计算机网络了，大概了解ARP攻击这么一回事，但是当我真正去试的时候，才发现局域网原来真的这么脆弱，因为进行ARP攻击实在太容易了。实际上就是几条命令的事情。&lt;/p&gt;
&lt;h3 id=&quot;主机发现和端口扫描&quot;&gt;&lt;a href=&quot;#主机发现和端口扫描&quot; class=&quot;headerlink&quot; title=&quot;主机发现和端口扫描&quot;&gt;&lt;/a&gt;主机发现和端口扫描&lt;/h3&gt;&lt;p&gt;进行攻击第一步当然就是找目标了。可以使用 nmap 这个工具来进行，这东西简直渗透利器。&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;nmap -sP &lt;span class=&quot;number&quot;&gt;192.168&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.0&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt; 这样就可以扫描192.168.1.0这个网段里面的所有主机了，以 ping 方式扫描，当然他有很多参数很多用法，网上很多这方面的资料我就不叙述了。&lt;br&gt;&lt;img src=&quot;/2016/07/14/ARP攻击和无线网卡混杂模式/nmap.png&quot; alt=&quot;Nmap扫描&quot; title=&quot;Nmap扫描&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;发起攻击&quot;&gt;&lt;a href=&quot;#发起攻击&quot; class=&quot;headerlink&quot; title=&quot;发起攻击&quot;&gt;&lt;/a&gt;发起攻击&lt;/h3&gt;&lt;p&gt;如果是进行ARP攻击，那也是加多三条命令就搞定的事情。&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; 1 &amp;gt;&amp;gt; /proc/sys/net/ipv4/ip_forward&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;arpspoof -i wlp3s0 -t 192.168.1.110 192.168.1.1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;arpspoof -i wlp3s0 -t 192.168.1.1   192.168.1.110&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;第一条是开启转发，不然会受害者流量到我们这里出不去就断网了。&lt;br&gt;第二条是告诉受害者说我是网管。&lt;br&gt;第三条是告诉网管我是受害者。&lt;br&gt;这样就完成了 ARP 欺骗，图片以后再补。这之后对方的网络就完全在你的监控之下了。这告诉我们使用 https 和不连接免费 wifi 的重要性!&lt;/p&gt;
&lt;h3 id=&quot;抓包&quot;&gt;&lt;a href=&quot;#抓包&quot; class=&quot;headerlink&quot; title=&quot;抓包&quot;&gt;&lt;/a&gt;抓包&lt;/h3&gt;&lt;p&gt;抓包推荐使用 wireshark 。具体就不介绍了=.=。你还可以使用 Driftnet 这东西来将对方访问的图片在你这边显示出来～&lt;/p&gt;
&lt;h2 id=&quot;监听空气包&quot;&gt;&lt;a href=&quot;#监听空气包&quot; class=&quot;headerlink&quot; title=&quot;监听空气包&quot;&gt;&lt;/a&gt;监听空气包&lt;/h2&gt;&lt;p&gt;大部分无线网卡都可以设置 monitor 模式，即无线网卡默认接受下全部经过他的以太网帧而不丢弃，这种方式可以抓到附近范围里面的所以以太网帧。在 Arch 下也是三条命令搞定的事情。&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ifconfig wlp3s0 down&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iwconfig wlp3s0 mode monitor&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ifconfig wlp3s0 up&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;接着同样开启 wireshark 抓包，你会发现很多802.11帧，不过这个并没有什么卵用，理论上应该对于没有加密的帧应该可以直接得到应用层报文才对，但是很奇怪我一直抓不到，即使是对于有加密的 Wifi，我填入 WAPKEY 解密也不行。这个有待继续研究。。。&lt;br&gt;
    
    </summary>
    
      <category term="网络安全" scheme="https://ruiming.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Hack" scheme="https://ruiming.github.io/tags/Hack/"/>
    
  </entry>
  
  <entry>
    <title>从输入 URL 到页面展示</title>
    <link href="https://ruiming.github.io/2016/06/24/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA/"/>
    <id>https://ruiming.github.io/2016/06/24/从输入URL到页面展示/</id>
    <published>2016-06-24T07:43:38.000Z</published>
    <updated>2016-08-04T09:20:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文从网络层以上讨论从浏览器输入 HTTPS 协议的 URL 到页面展现的全过程。由于不同浏览器之间也存在差异，这里以 Chrome 浏览器为例。</p>
<h2 id="1-DNS查询"><a href="#1-DNS查询" class="headerlink" title="1. DNS查询"></a>1. <a name="DNS-0"></a>DNS查询</h2><p>DNS 缓存有好几个环节，浏览器缓存，系统缓存，路由器缓存，ISP 缓存。</p>
<ul>
<li><p>浏览器首先会查看自身是否已经有进行 DNS 缓存。Chrome 可以通过 <code>chrome://net-internals/#dns</code> 查看缓存的 DNS，浏览器的 DNS 缓存可以加快 DNS 解析速度，但缓存时间不会太长。</p>
<img src="/2016/06/24/从输入URL到页面展示/chrome-dns-cache.png" alt="Chrome 的 DNS 缓存" title="Chrome 的 DNS 缓存">
</li>
<li><p>如果浏览器没有相应的缓存，则查找系统缓存，浏览器会向系统发送一个查询请求，如果系统存在缓存或者设置了 host ，则返回相应的 ip 地址给浏览器。</p>
</li>
<li><p>如果系统没有缓存，那么它会发出一个 DNS 查询请求给路由器。</p>
<p>如果路由器有 DNS 缓存，他会提取出 IP 地址返回。否则，他会向本地域名服务器发出查询，从请求主机到本地域名服务器的请求一般是递归查询，而其他的查询一般是迭代查询。</p>
<img src="/2016/06/24/从输入URL到页面展示/client-to-server-query.gif" alt="DNS 请求主机到本地域名服务器的查询" title="DNS 请求主机到本地域名服务器的查询">
<img src="/2016/06/24/从输入URL到页面展示/server-to-server-query.gif" alt="DNS 域名服务器之间的查询" title="DNS 域名服务器之间的查询">
<p>请求报文如下</p>
<img src="/2016/06/24/从输入URL到页面展示/dns-request-1.png" alt="DNS 请求报文" title="DNS 请求报文">
<p>我们先简单分析下请求报文。</p>
<ol>
<li>DNS 使用 UDP 协议，端口号53。</li>
<li>在 DNS 报文的 Flags 中的 RD=1。表示它建议域名服务器以递归方式查询。</li>
<li>Question section format 需要给出 <code>QNAME</code>, <code>QTYPE</code>, <code>QCLASS</code>。即查询的域名，查询的类型以及查询的类。</li>
</ol>
<p>有关<code>DNS</code>报文的更多信息可以参考<a href="https://www.ietf.org/rfc/rfc1035" target="_blank" rel="external">RFC1035</a></p>
<p>响应报文如下</p>
<img src="/2016/06/24/从输入URL到页面展示/dns-response-1.png" alt="DNS 响应报文" title="DNS 响应报文">
<p>我们也简单分析下，如果想详细了解，可以查看上面的 <code>RFC1035</code> 标准。</p>
<ol>
<li>与请求报文相比，对比 Flags 可以发现，QR=1 表示这是一个响应报文。RA=1 表示递归查询可用。</li>
<li>ARecord 记录了DNS请求获得的一个或多个IP地址。一般还会得到 CNAME 记录和存活时间等信息。</li>
<li>这里对 Rcode 也稍加说明下，Rcode=0 表示成功，他还有好几种状态码，比如1表示 <code>Format error</code>，2表示 <code>Server failure</code>，3表示 <code>Name error</code>，4表示 <code>Not lmplemented</code>，5表示 <code>Refused</code>，具体信息可以参考 <code>RFC1035</code>。</li>
</ol>
</li>
</ul>
<a id="more"></a>
<h2 id="2-三次握手建立连接"><a href="#2-三次握手建立连接" class="headerlink" title="2. 三次握手建立连接"></a>2. <a name="-1"></a>三次握手建立连接</h2><p>经过上述过程，此时浏览器得到了要访问的域名的 IP 地址。由于 DNS 查询需要一定时间，所以有些网站会使用 DNS Prefetching 进行 DNS 预解析，结合浏览器的 DNS 缓存，以加快网站速度。这里不做详细叙述。</p>
<p>首先贴出 TCP 三次握手的建立图。</p>
<img src="/2016/06/24/从输入URL到页面展示/tcp-shake-hands.jpg" alt="三次握手" title="三次握手">
<p>我们抓包依次进行分析。</p>
<ol>
<li><p>第一个握手包</p>
<img src="/2016/06/24/从输入URL到页面展示/tcp-shake-hands-1.png" alt="第一个握手包" title="第一个握手包">
<p>从这个包我们可以得到以下信息:</p>
<ul>
<li>Seq = 2988862522 这个是本报文段所发送的数据的第一个字节的序号</li>
<li><p>DataOffset = 32（字节） 指明 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远</p>
</li>
<li><p>SYN = 1 SYN=1 而 ACK=0 时表示这是一个连接请求报文。</p>
</li>
<li>Window = 8192（字节） 客户端滑动窗口8192字节，滑动窗口协议是设计来提高报文段的传输效率，这里不详细叙述，可以自己查资料。</li>
<li>Checksum = 0x5818 校验和，校验和字段校验的范围包括首部和数据这两个部分，在计算校验和时，要在 TCP 报文段的前面加上12字节的伪首部。接收方接收到此报文段后，加上这个伪首部来计算校验和。校验和是用来保证数据的无差错。</li>
<li>MaxSegmentSize = 1460（字节） 即 MSS，表示 TCP 报文段中数据字段的最大长度。注意它加上 TCP 首部才等于整个的 TCP 报文。有关 MSS 的信息自己查资料。</li>
</ul>
<p>比较重要的就是上述信息，客户端需要在第一次发包时要告知自身的一些信息。</p>
</li>
<li><p>第二个握手包</p>
<img src="/2016/06/24/从输入URL到页面展示/tcp-shake-hands-2.png" alt="第二个握手包" title="第二个握手包">
<p>在接收到客户端发来的握手包后，服务端进行应答，我们对这个包进行分析：</p>
<ul>
<li>Seq = 1648068786</li>
<li>Ack = 2988862523 表示服务端期望收到对方的下一个报文段的第一个数据字节的序号。</li>
<li>ACK = 1 当 ACK=1 时确认号字段有效。</li>
<li>SYN = 1 ACK=1 且 SYN=1 表示这是一个同意建立连接的响应报文。</li>
<li>Window = 63343（字节） 服务端的滑动窗口为63343字节。</li>
<li>MaxSegmentSize = 1448（字节） 服务端的 TCP 报文中数据字段的最大长度为1448字节。</li>
</ul>
<p>在前两次握手时，双方交换一些信息如 Window 和 MSS，确定 seq 和 ack 起始号。</p>
</li>
<li><p>第三个握手包</p>
<img src="/2016/06/24/从输入URL到页面展示/tcp-shake-hands-3.png" alt="第三个握手包" title="第三个握手包">
<p>服务端接受请求后，客户端还需要在发送一个握手包。这个握手包明显信息更少了，同样我们查看一些关键值：</p>
<ul>
<li>Seq = 2988862523 由于上一个握手包没有携带正文信息，不占用字节空间，所以 Seq 与上一个握手包的 Ack 值相同。</li>
<li>Ack = 1648068787 同上，双方建立通信之后是会进行数据交换，同样的，这个地方表示客户端期望收到对方的下一个报文段的第一个数据字节的序号。</li>
<li>ACK = 1 表示对上一个握手包的确认</li>
<li>Window = 260（字节） TCP 的发送窗口时会不断变化的，TCP 的流量控制和拥塞控制会根据情况动态地调整发送窗口上限值，从而控制发送数据的平均速率。</li>
</ul>
</li>
</ol>
<p>自此三次握手完成，连接建立，可以开始传输数据。</p>
<h2 id="3-建立HTTPS连接"><a href="#3-建立HTTPS连接" class="headerlink" title="3. 建立HTTPS连接"></a>3. <a name="HTTPS-2"></a>建立HTTPS连接</h2><p>以上完成握手，只能建立 HTTP 连接。但如果网站使用了 HTTPS 协议，那么还需要进行 SSL/TLS 握手。</p>
<p>在这之前，我们先介绍下 SSL/TLS。</p>
<p>SSL/TLS 是一种互联网安全加密技术。HTTP 报文是进行明文传输的，这意味着用户的 cookie 或者其提交的信息比如账号和密码都是在互联网上裸奔，如果这个报文被其他人抓取到，会带来很大的不安全性。使用 HTTPS 协议是非常有必要的，并且目前最新的 HTTP2 规范也仅支持 HTTPS。而 SSL/TLS 协议位于 TCP/IP 协议与各个应用层协议之间，为数据通信提供安全支持。他们可以分为记录协议和握手协议。</p>
<p>那么 SSL 和 TLS 又有什么区别呢？</p>
<p>简单的说，TLS 的建立在 SSL 3.0 协议规范之上的，是 SSL v3 的强化版，在整个协议格式上和 SSL 类似。TLS 增强了加密算法，并带来了更严格的警报，在安全性方面有很多改进。</p>
<p>关于 HTTP 与 HTTPS 和 SSL 与 TLS 的具体差别自行搜索。</p>
<img src="/2016/06/24/从输入URL到页面展示/ssl-tls-protocol.png" alt="SSL/TLS Protocol" title="SSL/TLS Protocol">
<p>关于 SSL/TLS 协议这里不做详解，此处主要讲述 TLS 握手的建立过程和 HTTPS 安全的原因。</p>
<p>我们来看看 TLS 握手的大致过程，这里不再详细叙述每个握手包</p>
<img src="/2016/06/24/从输入URL到页面展示/tls-handshake.jpg" alt="TLS-handshake" title="TLS-handshake">
<ul>
<li><p>Client Hello</p>
  <img src="/2016/06/24/从输入URL到页面展示/tls-handshake-1.png" alt="TLS-handshake-1" title="TLS-handshake-1">
<p>  可以看到 TCP 报文的 Push 为1，表示接收方尽快对该报文要尽快交付而不是积累到足够多的数据。</p>
<p>  这是一个 TLS 握手包，我们可以看到 HandShakeType 为 ClientHello ，对应 TLS 握手图的第一步。</p>
<p>   同时，该过程浏览器还发送了自己支持的一套加密规则。</p>
</li>
<li><p>Server Hello</p>
<p>  服务端接受到上述报文后，会发送 TCP 报文进行确认。报文如下</p>
  <img src="/2016/06/24/从输入URL到页面展示/tls-handshake-2.png" alt="TLS-handshake-2" title="TLS-handshake-2">
<p>  服务端发出 ACK 包的同时，发送 TLS 报文，此时 HandShakeType 为 ServerHello，对应 TLS 握手图的第二步。</p>
  <img src="/2016/06/24/从输入URL到页面展示/tls-handshake-3.png" alt="TLS-handshake-3" title="TLS-handshake-3">
<p>  接着上述的报文，服务端从客户端发来的加密规则中选出一组加密算法和 HASH 算法，并把自己的身份信息以证书形式发给客户端。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。如图，发送公钥使用了两个报文，最后客户端发送 ACK 确认报文进行确认，注意这个报文和上面的 ACK 报文一样不占用空间，只是进行确认而已。</p>
  <img src="/2016/06/24/从输入URL到页面展示/tls-handshake-4.png" alt="TLS-handshake-4" title="TLS-handshake-4">
</li>
<li><p>Client Key Exchange</p>
<p>  浏览器获得证书后，会首先验证证书的合法性，如果证书受信任，则浏览器栏里面会显示一个小绿锁。同时浏览器会生成一串随机数的密码，并用证书中提供的公钥进行加密，然后使用约定好的 HASH 算法计算握手信息，并使用未加密的随机数对消息进行加密。然后将消息重新发给服务端。这一步是加密握手包的开始。</p>
</li>
<li><p>Cipher Change Spec</p>
<p>  服务端使用自己的私钥对信息进行解密取出密码（密码被用公钥加密，只有用私钥才能加开，非对称加密），然后用该密码来解密握手消息，然后验证 HASH 是否与浏览器发来的一致。</p>
<p>  接着使用这个密码来加密一段握手信息，发给客户端即浏览器。</p>
</li>
<li><p>Finish</p>
<p>  客户端用密码对加密握手包进行解密（注意此时已经变为对称加密），同时计算 HASH 值，若 HASH 值一致，则握手过程结束。之后双方通信都使用之前浏览器生成的密码来进行加密。</p>
</li>
</ul>
<p>至此， HTTPS 连接已成功建立。由于浏览器会对证书进行校验，由证书授权机构保证其有效性，可以保证证书不被篡改。同时浏览器方面生成的随机数密码，一开始只有浏览器知道，而这个密码用公钥加密之后，只有私钥能解开，公钥也无法解开，这是非对称加密。服务器接收到该数据包后解开得到该密码，双方就可以使用该密码通过对称加密传输数据了。</p>
<p>现给出 TCP 三次握手和 TLS 握手的列表信息。</p>
<img src="/2016/06/24/从输入URL到页面展示/handshake.png" alt="HandsShake" title="HandsShake">
<p>这之后双方都是用 TLS 来传输数据，但不带数据的 ACK 确认包不进行加密，仍然使用 TCP 协议来传输。</p>
<p>需要明确的是，TLS 协议还是建立在 TCP 协议之上的，此处为便于说明将两者区分对待。即 TCP 协议是不进行加密的，TLS 是进行加密的 TCP 协议。</p>
<p>这个过程其实是先进行 HTTP 连接建立的三次握手，然后服务器进行 3xx 重定向，然后再进行 HTTPS 的三次握手。这样既增加了连接建立的开销，而且也可能在 HTTP 连接建立的过程被劫持。所以有出现了 HSTS。</p>
<blockquote>
<p>HTTP 严格传输安全(HTTP Strict Transport Security)是一套由互联网工程任务组发布的互联网安全策略机制。网站可以选择使用 HSTS 策略，来让浏览器强制使用 HTTPS 与网站进行通信，以减少会话劫持风险。</p>
</blockquote>
<p>我们有时候会看到出现证警告的提醒，使用了 HSTS 之后用户将不再允许忽略警告。但是用户首次访问某个网站是不受 HSTS 保护的，因为首次访问时浏览器还未收到 HSTS ，目前比较流行的方案是浏览器预置 HTST 域名列表，Google Chrome, Firefox, IE, Edge 都实现了这一方案，我们可以在服务器配置相关信息后去进行登记。HSTS 可以抵御 SSL 剥离攻击，它利用用户通过 HTTP 建立连接再重定向到 HTTPS 连接，阻止浏览器与服务器建立 HTTPS 连接，攻击者可以在用户访问 HTTP 页面时替换所有 HTTPS 链接为 HTTP，达到阻止 HTTPS 的目的。</p>
<h2 id="4-客户端请求网站信息"><a href="#4-客户端请求网站信息" class="headerlink" title="4. 客户端请求网站信息"></a>4. <a name="-3"></a>客户端请求网站信息</h2><ol>
<li><p>如果访问的是网站的主页，那么此时会发送一个请求给服务器，如下：</p>
<img src="/2016/06/24/从输入URL到页面展示/request-1.png" alt="request-package" title="request-package">
<p>HTTP 里面附带了 URI, ProtocolVersion, Host, Connection 以及 Cookie 等很多信息。</p>
<p>这里只讨论正常访问的情况。</p>
</li>
<li><p>服务端接收到该请求后，验证无误后，首先发送 ACK 报文进行确认。接着对该请求进行处理，如果是静态页面则直接返回。但大多数时候服务端都需要动态生成一个新的页面再返回该页面。这里讨论下 php 的处理。</p>
<p>假设我们这时候访问的是<code>index.php</code>这个页面，服务器例如 Nginx 知道这个不是静态文件，它回去寻找 PHP 解析器去做处理，这依靠的就是 CGI 来实现。</p>
<p>下面介绍几个概念，即 CGI, PHP-CGI, FastCGI, PHP-FPM。</p>
<ul>
<li><p>CGI</p>
<p>CGI 全称是“公共网关接口”（Common Gateway Interface），HTTP 服务器与服务器上其他程序进行通讯的一种协议。</p>
</li>
<li><p>PHP-CGI</p>
<p>简单的说 PHP-CGI 就是HTTP服务器与 PHP 进行通讯的工具，当浏览器发出一个类似 <code>/index.php</code> 的请求时，HTTP 服务器请求 PHP-CGI 去处理这个请求，PHP-CGI 处理完成后再把处理结果发回给 HTTP 服务器，然后由 HTTP 服务器发给浏览器。</p>
<p>PHP-CGI 在处理请求之前，需要解析<code>php.ini</code>文件，初始化执行环境，然后才开始处理请求。</p>
</li>
<li><p>FastCGI</p>
<p>FastCGI 全称是“快速通用网关接口”（Fast Common Gateway Interface / FastCGI）是一种让交互程序与 Web 服务器通信的协议。它是 CGI 的增强版本。</p>
<p>CGI 程序运行在独立的进程中，并对每一个请求建立一个进程，每个建立都要经过解析配置文件和初始化执行环境。这种方法易于实现，但效率很差，难以面对大量请求。</p>
<p>FastCGI 使用持续的进程来处理一连串的请求。这些进程由 FastCGI 服务器管理，而不是 Web 服务器。它是一个常驻型的 CGI(master)，只要激活后就不需要重新去解析 <code>php.ini</code> 和初始化，提高了效率。他在自身初始化后会启动多个 CGI 解析器(worker)，当有请求过来时，他会交给其中一个 worker 去处理。同时，它还可以动态调整 worker 的数量。</p>
</li>
<li><p>PHP-FPM</p>
<p>PHP-FPM 是一个 PHP FastCGI 管理器，从 PHP 5.3.3 开始已经集成了 PHP-FPM，在编译安装时可以通过 <code>-enable-fpm</code> 参数开启。</p>
<img src="/2016/06/24/从输入URL到页面展示/php-fpm.jpg" alt="php-fpm" title="php-fpm">
</li>
</ul>
<p>所以浏览器如果请求 <code>/index.html</code> 那么 Web 服务器会直接把这个静态页面返回，如果是请求 <code>/index.php</code>，则交由 PHP-FPM 进行处理，PHP-FPM 处理后再把结果返回给 Web 服务器，由 Web 服务器发给浏览器。</p>
<p>我们来看看响应报文</p>
<img src="/2016/06/24/从输入URL到页面展示/response-1.png" alt="response-1" title="response-1">
<p>可以看到除了对浏览器请求的 ACK 确认包之外，服务端发回了10个包。第一个报文里面有StatusCode, Etag, ContentEncoding 等信息。这里面涉及到不少网站优化的技巧，我们将在下一篇中再讨论。这里大概了解下就可以了。</p>
<p>接下来的9个报文都是跟着第1个报文一起过来的。最后一个报文设置了 PUSH 标志，因为报文已经传输完毕，所以它请求浏览器客户端尽快交付。</p>
<p>接着客户端会发送 ACK 确认报文，之所以这里客户端对最后一个报文进行了确认，是因为 TCP Delayed Ack 的原因，它是为了避免多次发送 ACK 确认报文而设置的延时，一般为 40ms，也就是说如果接收到一个报文 40ms 后没有接收到第二个报文，他就会对这个报文进行确认。</p>
<p>服务器发送完全部数据后，最后再发送一个报文，即图中的 #191 报文，表示我已经发完。客户端相应的发出 ACK 确认报文。主页请求结束。</p>
</li>
</ol>
<h2 id="5-浏览器渲染"><a href="#5-浏览器渲染" class="headerlink" title="5. 浏览器渲染"></a>5. <a name="-4"></a>浏览器渲染</h2><p>浏览器接收到 <code>index.html</code> 后，开始浏览器渲染，这里讨论 webkit 内核，其他内核不讨论。主要分为四步进行。如下图:</p>
<img src="/2016/06/24/从输入URL到页面展示/html-parse.png" alt="html-parse" title="html-parse">
<p>浏览器渲染不是本文的重点，所以只做简单说明。</p>
<ul>
<li><p>Parsing HTML to construct the DOM tree</p>
<p>数据会交给 HTMLDocumentParser，然后 HTMLDocumentParser 将文本字符的解析交给 HTMLDocumentTokenizer 来负责，HTMLDocumentTokenizer 解析出一个一个的标签，然后 HTMLDocumentParser 将标签交给 HTMLTreeBuilder 来构建 DOM 树。</p>
<p>有些节点需要加载其他资源，比如加载外链 CSS 和图片等。会调用资源加载器进行异步加载，不会阻碍当前 DOM 树的构造。但是如果是非 defer 非 async 的 script 标签，则需要停止当前 DOM 树的构造，直到脚本被加载并被 JavaScript 执行后才继续 DOM 树的构造。</p>
<p>因此我们有时候会要求 &lt;script&gt; 标签放到最后面，目的是为了不影响前面 DOM 树的构建。</p>
<p>对于 css 文件，会解析 css 生成 CSS Rule Tree。</p>
<p>对于 JavaScript` 文件，主要是通过 DOM API 和 CSSOM API 来操作 DOM TREE 和 CSS Rule Tree，从而改变渲染的效果。</p>
</li>
<li><p>Render tree construction</p>
<p>接着浏览器会开始构建渲染树(Rendering Tree)。Renderint Tree 只包括渲染页面需要的节点。</p>
<p>CSS Rule Tree 会匹配的把 CSS Rule 附加到相应的 Rendering Tree 的元素上面。</p>
<img src="/2016/06/24/从输入URL到页面展示/render-tree-construction.png" alt="render-tree-construction" title="render-tree-construction">
</li>
<li><p>Layout of the render tree</p>
<p>到目前为止，我们已经计算了哪些节点是可见的，以及它们的计算样式，但还没有计算它们在设备视窗中的准确位置与尺寸。这就是布局阶段做的事情。</p>
<p>渲染树的构建、布局与绘制所需的时间取决于文档大小、应用的样式，当然，还有运行文档的设备：文档越大，浏览器要完成的工作就越多；样式越复杂，绘制需要的时间就越长（例如，绘制单色成本较低，而计算、呈现阴影的成本就非常高了）。</p>
</li>
<li><p>Painting the render tree</p>
<p>一旦布局完成，浏览器便会发出 Paint Setup 与 Paint 事件，将渲染树转化为屏幕上的实际像素。</p>
</li>
</ul>
<p>大概可以用下图来表示整个过程。</p>
<img src="/2016/06/24/从输入URL到页面展示/webkitflow.png" alt="webkitflow" title="webkitflow">
<hr>
<p>参考资料</p>
<ul>
<li><a href="https://technet.microsoft.com/en-us/library/cc775637.aspx" target="_blank" rel="external">How DNS query works</a></li>
<li><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction" target="_blank" rel="external">Render Tree Construction</a></li>
<li><a href="http://taligarsiel.com/Projects/howbrowserswork1.htm#Render_tree_construction" target="_blank" rel="external">How browsers work</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文从网络层以上讨论从浏览器输入 HTTPS 协议的 URL 到页面展现的全过程。由于不同浏览器之间也存在差异，这里以 Chrome 浏览器为例。&lt;/p&gt;
&lt;h2 id=&quot;1-DNS查询&quot;&gt;&lt;a href=&quot;#1-DNS查询&quot; class=&quot;headerlink&quot; title=&quot;1. DNS查询&quot;&gt;&lt;/a&gt;1. &lt;a name=&#39;DNS-0&#39;&gt;&lt;/a&gt;DNS查询&lt;/h2&gt;&lt;p&gt;DNS 缓存有好几个环节，浏览器缓存，系统缓存，路由器缓存，ISP 缓存。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;浏览器首先会查看自身是否已经有进行 DNS 缓存。Chrome 可以通过 &lt;code&gt;chrome://net-internals/#dns&lt;/code&gt; 查看缓存的 DNS，浏览器的 DNS 缓存可以加快 DNS 解析速度，但缓存时间不会太长。&lt;/p&gt;
&lt;img src=&quot;/2016/06/24/从输入URL到页面展示/chrome-dns-cache.png&quot; alt=&quot;Chrome 的 DNS 缓存&quot; title=&quot;Chrome 的 DNS 缓存&quot;&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果浏览器没有相应的缓存，则查找系统缓存，浏览器会向系统发送一个查询请求，如果系统存在缓存或者设置了 host ，则返回相应的 ip 地址给浏览器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果系统没有缓存，那么它会发出一个 DNS 查询请求给路由器。&lt;/p&gt;
&lt;p&gt;如果路由器有 DNS 缓存，他会提取出 IP 地址返回。否则，他会向本地域名服务器发出查询，从请求主机到本地域名服务器的请求一般是递归查询，而其他的查询一般是迭代查询。&lt;/p&gt;
&lt;img src=&quot;/2016/06/24/从输入URL到页面展示/client-to-server-query.gif&quot; alt=&quot;DNS 请求主机到本地域名服务器的查询&quot; title=&quot;DNS 请求主机到本地域名服务器的查询&quot;&gt;
&lt;img src=&quot;/2016/06/24/从输入URL到页面展示/server-to-server-query.gif&quot; alt=&quot;DNS 域名服务器之间的查询&quot; title=&quot;DNS 域名服务器之间的查询&quot;&gt;
&lt;p&gt;请求报文如下&lt;/p&gt;
&lt;img src=&quot;/2016/06/24/从输入URL到页面展示/dns-request-1.png&quot; alt=&quot;DNS 请求报文&quot; title=&quot;DNS 请求报文&quot;&gt;
&lt;p&gt;我们先简单分析下请求报文。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DNS 使用 UDP 协议，端口号53。&lt;/li&gt;
&lt;li&gt;在 DNS 报文的 Flags 中的 RD=1。表示它建议域名服务器以递归方式查询。&lt;/li&gt;
&lt;li&gt;Question section format 需要给出 &lt;code&gt;QNAME&lt;/code&gt;, &lt;code&gt;QTYPE&lt;/code&gt;, &lt;code&gt;QCLASS&lt;/code&gt;。即查询的域名，查询的类型以及查询的类。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有关&lt;code&gt;DNS&lt;/code&gt;报文的更多信息可以参考&lt;a href=&quot;https://www.ietf.org/rfc/rfc1035&quot;&gt;RFC1035&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;响应报文如下&lt;/p&gt;
&lt;img src=&quot;/2016/06/24/从输入URL到页面展示/dns-response-1.png&quot; alt=&quot;DNS 响应报文&quot; title=&quot;DNS 响应报文&quot;&gt;
&lt;p&gt;我们也简单分析下，如果想详细了解，可以查看上面的 &lt;code&gt;RFC1035&lt;/code&gt; 标准。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;与请求报文相比，对比 Flags 可以发现，QR=1 表示这是一个响应报文。RA=1 表示递归查询可用。&lt;/li&gt;
&lt;li&gt;ARecord 记录了DNS请求获得的一个或多个IP地址。一般还会得到 CNAME 记录和存活时间等信息。&lt;/li&gt;
&lt;li&gt;这里对 Rcode 也稍加说明下，Rcode=0 表示成功，他还有好几种状态码，比如1表示 &lt;code&gt;Format error&lt;/code&gt;，2表示 &lt;code&gt;Server failure&lt;/code&gt;，3表示 &lt;code&gt;Name error&lt;/code&gt;，4表示 &lt;code&gt;Not lmplemented&lt;/code&gt;，5表示 &lt;code&gt;Refused&lt;/code&gt;，具体信息可以参考 &lt;code&gt;RFC1035&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="HTTP" scheme="https://ruiming.github.io/categories/HTTP/"/>
    
    
      <category term="DNS" scheme="https://ruiming.github.io/tags/DNS/"/>
    
      <category term="HTTPS" scheme="https://ruiming.github.io/tags/HTTPS/"/>
    
      <category term="HTTP" scheme="https://ruiming.github.io/tags/HTTP/"/>
    
      <category term="TCP/IP" scheme="https://ruiming.github.io/tags/TCP-IP/"/>
    
      <category term="Webkit" scheme="https://ruiming.github.io/tags/Webkit/"/>
    
  </entry>
  
</feed>
