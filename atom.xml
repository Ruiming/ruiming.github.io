<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ruiming&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ruiming.github.io/"/>
  <updated>2016-09-13T09:08:40.226Z</updated>
  <id>https://ruiming.github.io/</id>
  
  <author>
    <name>Ruiming</name>
    <email>ruiming.zhuang@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>提升网站加载速度的 N 个方法</title>
    <link href="https://ruiming.github.io/2016/09/11/%E6%8F%90%E5%8D%87%E7%BD%91%E7%AB%99%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E7%9A%84%20N%20%E4%B8%AA%E6%96%B9%E6%B3%95/"/>
    <id>https://ruiming.github.io/2016/09/11/提升网站加载速度的 N 个方法/</id>
    <published>2016-09-11T05:53:33.000Z</published>
    <updated>2016-09-13T09:08:40.226Z</updated>
    
    <content type="html"><![CDATA[<p>Web 这几年的一个变化之一估计就是各种优化小技巧不断涌出…自己也琢磨和尝试了不少优化，毕竟自己项目的网页首屏加载也是一度接近 2M 的。以下针对 HTTP1 和 HTTP1.1，在 HTTP2 中，很多最佳实践都适得其反了。</p>
<h2 id="减少文件传输数量"><a href="#减少文件传输数量" class="headerlink" title="减少文件传输数量"></a>减少文件传输数量</h2><p>现在前端代码发布上线的时候一般都会进行压缩，混淆，合并等操作，他们起到了减少文件体积和数量以及混淆代码降低可读性的作用。</p>
<p>浏览器针对同一域名的并发请求数目是有限制的，而在 HTTP1 和 HTTP1.1 中每传输一个资源就得建立一条连接。因此当网站的请求资源数量过多时，会导致后面资源请求的阻塞，也会导致频繁的连接建立和关闭带来的开销。一般浏览器的并发请求数量在4-8之间。因此我们针对同一域名的资源不宜过多，否则就会导致后面资源的阻塞。</p>
<p>针对该问题，我们可以采用合并文件，将资源分到不同域名，缓加载资源，提前加载资源，缓存等手段。具体如下：</p>
<ol>
<li>合并文件以减少并发请求数量<br> 合并文件也不能简单粗暴的合并为一个，对于长时间不会改变的文件我们要单独合并出来，这个文件是可以进行长期缓存的，而一些变动较为频繁的我们就不应该和上面的这些文件合并在一起，并且他们也不应该设置过激的缓存策略。</li>
<li>将次要文件延迟加载，比如 Google Analysis<br> 一些无关痛痒的文件可以放到页面最尾部，这是最佳实践，这里特别想提一下 async 和 defer，他们并没有对文件的请求产生影响，只是影响了执行的过程，所以我们不应该使用 async 或者 defer 方法来优化。 <img src="/2016/09/11/提升网站加载速度的%20N%20个方法/async-defer.jpg" alt="async-defer" title="async-defer">
 使用 async，会立即开始并行加载，加载完成后会进行执行并阻塞主渲染进程。<br> 使用 defer，会立即开始并行加载，但会延迟到最后才执行。</li>
<li>分散资源到不同域名<br> 比如图片有专门的域名(img.xxx.com)来存储。一些资源可以考虑第三方 CDN 比如 Bootcss 的 CDN，因为这类 CDN 使用较广，有可能用户浏览器已经有过缓存，这就避免了再次请求和加载，同时也减轻了服务器压力。</li>
<li>使用雪碧图(css sprites)来合并小图片<br> 这个优化技术其实挺常见，将图片合并为一个后使用 background-image 和 background-position 等来控制显示雪碧图的哪一部分就好了，据说还可以自动生成雪碧图自动定位。</li>
<li>利用 200 缓存<br> 这是一个比较极端的缓存方式，200 缓存时浏览器不发出网络请求，直接调用本地缓存，这需要强制浏览器使用本地缓存。我们可以使用 Expires 标志。即给出日期时间，超出该时间后则认为是过时，浏览器才会重新发起请求。这个具体细节我还不太了解。过后补充。</li>
<li>使用懒加载(lazy load)<br> 很多网站特别是有大量图片的网站都会使用该技术。当用户下滑页面时，才开始加载下面的图片。一来减少了页面加载的请求数和加载时间，二来也减少用户流量。不过可能有人会说这样体验不太好，好在业内有人把这个技术做到了堪称极致的地步，就是预先加载一个高度压缩的原图，然后淡出原图。大家应该有体验到类似的技术，就不多说了。</li>
<li><p>使用预加载技术(prefetch)<br> 这个技术知道的人可能不多，MDN 上面是这样解释的：</p>
<blockquote>
<p>页面资源预加载(Link prefetch)是浏览器提供的一个技巧，目的是让浏览器在空闲时间下载或预读取一些文档资源，用户在将来将会访问这些资源。一个Web页面可以对浏览器设置一系列的预加载指示，当浏览器加载完当前页面后，它会在后台静悄悄的加载指定的文档，并把它们存储在缓存里。当用户访问到这些预加载的文档后，浏览器能快速的从缓存里提取给用户。</p>
</blockquote>
<p> 不过资源预加载其实使用的并不多，可能是因为技术本身不成熟，浏览器支持不够等原因。目前没有发现有哪个网站使用了这个技术。感兴趣的自己去了解下，这里不多阐述这个技术。</p>
</li>
<li>集中加载资源<br> 额，这个名字是我自己起的，姑且我认为也是一种优化手段，主要针对的时 SPA。比如 Angular 搭建的 SPA。Angular 提供了 templateCache 这个模块。这个在前面的博客中已经介绍过，简单说就是一个数组，我们把模板全部都预先放入这个数组中。Angular 在请求页面的时候会先检查 templateCache 是否已经缓存了，如果有则直接调用这个缓存的模板，否则发出网络请求获取该模板，同时会放入 templateCache 中缓存。有人可能会问那不是增加了首屏加载的体积大小了吗？的确，但比起用户每点击一个新的页面就发起一个请求而言，这种方式无疑会更适合不是吗？并且如果你的文件确实太大了，那你应该考虑下你是否充分利用了指令功能。</li>
</ol>
<h2 id="减少文件大小"><a href="#减少文件大小" class="headerlink" title="减少文件大小"></a>减少文件大小</h2><p>除了减少文件数量，减少文件大小也同样重要，不过比起合并文件这样简单的减少文件数量的操作，减少文件大小就没来的那么简单了。常用的方法如下：<br><a id="more"></a></p>
<ol>
<li><p>开启 GZIP 压缩<br> GZIP 压缩应用非常广泛，因其可以有效明显的减少文件的体积。在 Nginx 中，我们可以很简单的进行配置开启 GZIP 压缩。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">gzip on;</div><div class="line">gzip_vary on;</div><div class="line">gzip_comp_level 4;</div><div class="line">gzip_buffers 16 8K;</div><div class="line">gzip_min_length 1k;</div><div class="line">gzip_proxied any;</div><div class="line">gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;</div><div class="line">gzip_<span class="built_in">disable</span> <span class="string">"MSIE [1-6]\."</span>;</div></pre></td></tr></table></figure>
<p> 这是我项目服务器上面 Nginx 关于 gzip 的配置。我们关心的当然还是压缩前后文件大小的差异，找别人的一个图贴下：</p>
 <img src="/2016/09/11/提升网站加载速度的%20N%20个方法/gzip_comp_level.png" alt="gzip_comp_level" title="gzip_comp_level">
<p> 可以看到效果还是很明显的，一般 GZIP 等级不宜高于 4 级。因为压缩意味着浏览器下载后还需要解压，所以压缩等级过高反而会带来性能问题（移动端耗电增加）甚至是降低页面渲染（解压占用CPU影响页面渲染且耗时）。<br> 另外，大文件压缩效果更明显，所以合并文件后再压缩会比分开压缩效果要好。</p>
</li>
<li><p>使用 WebP 格式图片<br> WebP 是 Google 推出的一种同时提供有损压缩与无损压缩的图片文件格式。根据 Google 较早的测试，无损压缩后的 WebP 比 PNG 文件少了45%的文件大小，即使这些 PNG 文件经过其他压缩工具压缩之后，WebP 还是可以减少28%的文件大小。</p>
 <img src="/2016/09/11/提升网站加载速度的%20N%20个方法/WebP.png" alt="WebP" title="WebP">
<p> WebP 在互联网上已经非常流行，主流浏览器都已经支持，并且国内也有大量站点如淘宝网，腾讯网，QQ空间等等都使用了这一格式。另外，针对不支持的浏览器，也可以引入相应的 shim 解决。</p>
 <img src="/2016/09/11/提升网站加载速度的%20N%20个方法/WebP支持情况.png" alt="WebP支持情况" title="WebP支持情况">
</li>
<li><p>书写压缩友好的代码<br> 这个对开发人员就要较高的要求了，并且如果不是对文件体积有很大的要求一般都不会做到这一步。在代码压缩的过程有一步就是进行变量替换，举一个前面博客中的例子来说</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">	<span class="keyword">var</span> ArrayProto = <span class="built_in">Array</span>.prototype, ObjProto = <span class="built_in">Object</span>.prototype;</div><div class="line"><span class="keyword">var</span> SymbolProto = <span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">'undefined'</span> ? <span class="built_in">Symbol</span>.prototype : <span class="literal">null</span>;</div><div class="line"><span class="keyword">var</span> push = ArrayProto.push,</div><div class="line">    slice = ArrayProto.slice,</div><div class="line">    toString = ObjProto.toString,</div><div class="line">    hasOwnProperty = ObjProto.hasOwnProperty;</div></pre></td></tr></table></figure>
<p> <code>Array.prototype.push</code> 是无法压缩的，而如果我们赋值 <code>ArrayProto = Array.prototype</code> ，那么 <code>ArrayProto</code> 就可以被替换掉，同理，上面中的 <code>push</code>, <code>slice</code> 等都是对压缩友好的。除此之外，一般的压缩工具还会把 <code>undefined</code>  都替换为 <code>void 0</code>，一来可以避免 <code>underfined</code> 重写的问题，二来字符数少了。目前我比较清楚的就这两个，有兴趣的话可以去了解下压缩的过程，对比下压缩前后。</p>
</li>
<li><p>避免引入无用代码<br>有一种比较常见的场景是我们使用了 FontAweSome 等的文件后，虽然我们可以很方便的通过写 CSS 类名来添加修改图标，但我们用到的毕竟时少数图标，所以其他没有用到的图标的引入就是非必须的。这个我自己没有实践过，可以看看<a href="http://stackoverflow.com/questions/15331525/optimize-font-awesome-for-only-used-classes" target="_blank" rel="external">Optimize Font Awesome for only used classes</a>这里的讨论。<br>除了去做筛选之外，还有的办法就是我们不要引入整个图标文件，有些提供图标的网站可以让你自己选择需要的图标后以字体和 CSS 文件的形式下载下来。这样做就稍微麻烦一点，不过既然你要图文件小，那麻烦一点也没什么。<br>另外，在使用一些框架的时候，他们可能默认开启了调试模式。比如 Angular，在 Angular 的视图上面我们会经常看到视图上绑定的变量出现了 <code>ng-bind</code> 的 CSS 类名，以及出现再 <code>ng-if</code> 和 <code>ng-repeat</code> 上的注释。这些也是可以关掉的。Angular 只需要在 config 中添加下面这一句话即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$compileProvider.debugInfoEnabled(<span class="literal">false</span>);</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="其他-Web-提速手段"><a href="#其他-Web-提速手段" class="headerlink" title="其他 Web 提速手段"></a>其他 Web 提速手段</h2><p>前面集中就文件请求数和文件体积开展讨论，其实还远远不止上面这些办法。常用的还有以下这些。</p>
<ol>
<li><p>dns-prefetch<br> 这个其实和前面说的资源预加载差不多，只是这个是 DNS 预解析。用户访问一个新的域名之前，会首先通过 DNS 解析得到他的 IP 地址，之后才开始建立连接。DNS 解析也是需要时间的，而这个技术的作用就是在用户页面空闲的时候去预获取 IP 地址并缓存，这样当访问该域名页面的时候，就不需要再解析域名，从而缩短了页面加载时间。</p>
 <img src="/2016/09/11/提升网站加载速度的%20N%20个方法/dns-prefetch.png" alt="淘宝网 dns-prefetch" title="淘宝网 dns-prefetch">
</li>
<li><p>Preconnect<br> 这个和上面差不多，但是不光会解析 DNS 还会建立 TCP 握手连接和 TLS 协议(如果需要的话)用法如下：</p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preconnect"</span> <span class="attr">href</span>=<span class="string">"https://ruiming.github.io"</span>&gt;</span></div></pre></td></tr></table></figure>
<p> 但是这个的支持还比较一般，我也没找到有谁使用了这个技术。</p>
 <img src="/2016/09/11/提升网站加载速度的%20N%20个方法/preconnect.png" alt="preconnect" title="preconnect">
<p> 其实类似的预xx技术还挺多，还有预渲染等，感兴趣的可以参考<a href="http://www.alloyteam.com/2015/10/prefetching-preloading-prebrowsing/" target="_blank" rel="external">此处</a></p>
</li>
<li><p>使用第三方 CDN<br> 前面也有稍微提了下 CDN。对于 CDN 的使用应该根据实际情况来，如果整个页面就只引入了两三个第三方库，我们可以考虑使用公共 CDN 比如 Bootcss 的 CDN。其一是真的很快，比七牛什么都快好多，其二是用的人多，可能用户浏览器已经缓存了，另外 Bootcss 的 CDN 默认使用 HTTP2，在支持 HTTP2 的浏览器中，他也可以避免影响我们网站资源并发请求数量的问题，当然如果你也是用 HTTP2 这个问题就不大了。<br> 如果不使用公共 CDN，对于个人也可以使用七牛或者其他的提供的 CDN 存储。CDN 的好处在可以根据用户位置就近分配资源，同时也可以减轻服务器压力。</p>
</li>
</ol>
<hr>
<p>参考资料：<br>WebP 探寻之路: <a href="https://isux.tencent.com/introduction-of-webp.html" target="_blank" rel="external">https://isux.tencent.com/introduction-of-webp.html</a><br>一箩筐的预加载技术: <a href="http://www.alloyteam.com/2015/10/prefetching-preloading-prebrowsing" target="_blank" rel="external">http://www.alloyteam.com/2015/10/prefetching-preloading-prebrowsing</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web 这几年的一个变化之一估计就是各种优化小技巧不断涌出…自己也琢磨和尝试了不少优化，毕竟自己项目的网页首屏加载也是一度接近 2M 的。以下针对 HTTP1 和 HTTP1.1，在 HTTP2 中，很多最佳实践都适得其反了。&lt;/p&gt;
&lt;h2 id=&quot;减少文件传输数量&quot;&gt;&lt;a href=&quot;#减少文件传输数量&quot; class=&quot;headerlink&quot; title=&quot;减少文件传输数量&quot;&gt;&lt;/a&gt;减少文件传输数量&lt;/h2&gt;&lt;p&gt;现在前端代码发布上线的时候一般都会进行压缩，混淆，合并等操作，他们起到了减少文件体积和数量以及混淆代码降低可读性的作用。&lt;/p&gt;
&lt;p&gt;浏览器针对同一域名的并发请求数目是有限制的，而在 HTTP1 和 HTTP1.1 中每传输一个资源就得建立一条连接。因此当网站的请求资源数量过多时，会导致后面资源请求的阻塞，也会导致频繁的连接建立和关闭带来的开销。一般浏览器的并发请求数量在4-8之间。因此我们针对同一域名的资源不宜过多，否则就会导致后面资源的阻塞。&lt;/p&gt;
&lt;p&gt;针对该问题，我们可以采用合并文件，将资源分到不同域名，缓加载资源，提前加载资源，缓存等手段。具体如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;合并文件以减少并发请求数量&lt;br&gt; 合并文件也不能简单粗暴的合并为一个，对于长时间不会改变的文件我们要单独合并出来，这个文件是可以进行长期缓存的，而一些变动较为频繁的我们就不应该和上面的这些文件合并在一起，并且他们也不应该设置过激的缓存策略。&lt;/li&gt;
&lt;li&gt;将次要文件延迟加载，比如 Google Analysis&lt;br&gt; 一些无关痛痒的文件可以放到页面最尾部，这是最佳实践，这里特别想提一下 async 和 defer，他们并没有对文件的请求产生影响，只是影响了执行的过程，所以我们不应该使用 async 或者 defer 方法来优化。 &lt;img src=&quot;/2016/09/11/提升网站加载速度的%20N%20个方法/async-defer.jpg&quot; alt=&quot;async-defer&quot; title=&quot;async-defer&quot;&gt;
 使用 async，会立即开始并行加载，加载完成后会进行执行并阻塞主渲染进程。&lt;br&gt; 使用 defer，会立即开始并行加载，但会延迟到最后才执行。&lt;/li&gt;
&lt;li&gt;分散资源到不同域名&lt;br&gt; 比如图片有专门的域名(img.xxx.com)来存储。一些资源可以考虑第三方 CDN 比如 Bootcss 的 CDN，因为这类 CDN 使用较广，有可能用户浏览器已经有过缓存，这就避免了再次请求和加载，同时也减轻了服务器压力。&lt;/li&gt;
&lt;li&gt;使用雪碧图(css sprites)来合并小图片&lt;br&gt; 这个优化技术其实挺常见，将图片合并为一个后使用 background-image 和 background-position 等来控制显示雪碧图的哪一部分就好了，据说还可以自动生成雪碧图自动定位。&lt;/li&gt;
&lt;li&gt;利用 200 缓存&lt;br&gt; 这是一个比较极端的缓存方式，200 缓存时浏览器不发出网络请求，直接调用本地缓存，这需要强制浏览器使用本地缓存。我们可以使用 Expires 标志。即给出日期时间，超出该时间后则认为是过时，浏览器才会重新发起请求。这个具体细节我还不太了解。过后补充。&lt;/li&gt;
&lt;li&gt;使用懒加载(lazy load)&lt;br&gt; 很多网站特别是有大量图片的网站都会使用该技术。当用户下滑页面时，才开始加载下面的图片。一来减少了页面加载的请求数和加载时间，二来也减少用户流量。不过可能有人会说这样体验不太好，好在业内有人把这个技术做到了堪称极致的地步，就是预先加载一个高度压缩的原图，然后淡出原图。大家应该有体验到类似的技术，就不多说了。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用预加载技术(prefetch)&lt;br&gt; 这个技术知道的人可能不多，MDN 上面是这样解释的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;页面资源预加载(Link prefetch)是浏览器提供的一个技巧，目的是让浏览器在空闲时间下载或预读取一些文档资源，用户在将来将会访问这些资源。一个Web页面可以对浏览器设置一系列的预加载指示，当浏览器加载完当前页面后，它会在后台静悄悄的加载指定的文档，并把它们存储在缓存里。当用户访问到这些预加载的文档后，浏览器能快速的从缓存里提取给用户。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 不过资源预加载其实使用的并不多，可能是因为技术本身不成熟，浏览器支持不够等原因。目前没有发现有哪个网站使用了这个技术。感兴趣的自己去了解下，这里不多阐述这个技术。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;集中加载资源&lt;br&gt; 额，这个名字是我自己起的，姑且我认为也是一种优化手段，主要针对的时 SPA。比如 Angular 搭建的 SPA。Angular 提供了 templateCache 这个模块。这个在前面的博客中已经介绍过，简单说就是一个数组，我们把模板全部都预先放入这个数组中。Angular 在请求页面的时候会先检查 templateCache 是否已经缓存了，如果有则直接调用这个缓存的模板，否则发出网络请求获取该模板，同时会放入 templateCache 中缓存。有人可能会问那不是增加了首屏加载的体积大小了吗？的确，但比起用户每点击一个新的页面就发起一个请求而言，这种方式无疑会更适合不是吗？并且如果你的文件确实太大了，那你应该考虑下你是否充分利用了指令功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;减少文件大小&quot;&gt;&lt;a href=&quot;#减少文件大小&quot; class=&quot;headerlink&quot; title=&quot;减少文件大小&quot;&gt;&lt;/a&gt;减少文件大小&lt;/h2&gt;&lt;p&gt;除了减少文件数量，减少文件大小也同样重要，不过比起合并文件这样简单的减少文件数量的操作，减少文件大小就没来的那么简单了。常用的方法如下：&lt;br&gt;
    
    </summary>
    
      <category term="还不知道分什么类好" scheme="https://ruiming.github.io/categories/%E8%BF%98%E4%B8%8D%E7%9F%A5%E9%81%93%E5%88%86%E4%BB%80%E4%B9%88%E7%B1%BB%E5%A5%BD/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="HTTP" scheme="https://ruiming.github.io/tags/HTTP/"/>
    
      <category term="Web" scheme="https://ruiming.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 Angular 脏检查</title>
    <link href="https://ruiming.github.io/2016/09/04/%E6%B5%85%E8%B0%88%20Angular%20%E8%84%8F%E6%A3%80%E6%9F%A5/"/>
    <id>https://ruiming.github.io/2016/09/04/浅谈 Angular 脏检查/</id>
    <published>2016-09-04T06:57:22.000Z</published>
    <updated>2016-09-09T11:11:58.374Z</updated>
    
    <content type="html"><![CDATA[<p>Angular 的脏值检查机制一直是 Angular 被人诟病的地方，但瑕不掩瑜，Angular 还是一个非常优秀的框架，并且 Angular2 也已经抛弃了这个脏值检查的算法。<br>最近在看《AngularJS 深度剖析与最佳实践》，不得不说是一本很好的书籍，作者在第三章开始讲背后的原理，这里分析了 Angular 的 $digest 函数，即脏检查机制。所以自己也去下载了 Angular 最新的源码去瞧了下，然后做下笔记吧。</p>
<p>首先要注意，Angular 的 digest 的触发不是定时的，只有在指定的事件触发之后才会进入 $digest。基本上我们用的带 <code>$</code> 的东西调用之后都可能会触发 digest。比如我们使用 <code>setTimeout</code> 就不会触发 digest，即当你使用 <code>setTimeout</code> 更改 viewmodel 的值后，它不会同步的反映到用户的视图中去，解决方法有两个，一个是使用 Angular 提供的 <code>$timeout</code> 替代 <code>setTimeout</code>，<code>$timeout</code> 会在执行结束之后自动触发 digest； 另一个方法是手动调用 $apply，$apply 是 Angular 对 digest 的一层封装，我们一般不会直接调用 digest 而是通过使用 $apply 方法。比如对于 <code>setTimeout</code>，我们就可以这样触发 digest。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">  $scope.$apply(() =&gt; &#123;</div><div class="line">    $scope.test = <span class="number">123</span>;</div><div class="line">  &#125;)    </div><div class="line">&#125;, <span class="number">500</span>);</div></pre></td></tr></table></figure></p>
<p>我们看一个例子，这也是 Angular 源码 $digest 部分的一个示例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scope = ...;</div><div class="line">scope.name = <span class="string">'misko'</span>;</div><div class="line">scope.counter = <span class="number">0</span>;</div><div class="line"></div><div class="line">expect(scope.counter).toEqual(<span class="number">0</span>);</div><div class="line">scope.$watch(<span class="string">'name'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue</span>)</span>&#123;</div><div class="line">  scope.counter = scope.counter + <span class="number">1</span>;</div><div class="line">&#125;);</div><div class="line">expect(scope.counter).toEqual(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">// 执行第一次 digest，第一次 digest 会遍历全部的 watcher，并触发上面的方法，从而使的 count+1</span></div><div class="line">scope.$digest();</div><div class="line">expect(scope.counter).toEqual(<span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="comment">// 第二次调用时，由于上一次调用检查 name 不脏，所以不会再去处理</span></div><div class="line">scope.$digest();</div><div class="line">expect(scope.counter).toEqual(<span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="comment">// 第三次调用时，由于 name 发生了变化，使得当前值和上一次保存的值不同，所以会触发起 $watch 方法</span></div><div class="line">scope.name = <span class="string">'adam'</span>;</div><div class="line">scope.$digest();</div><div class="line">expect(scope.counter).toEqual(<span class="number">2</span>);</div></pre></td></tr></table></figure></p>
<p>Angular 的脏值检查过程大致如下：<br>对当前作用域和子作用域上的 <code>$$watchers</code> 进行遍历，<code>$$watches</code> 保存着 scope 上的所有变量以及其 <code>$watch</code> 方法，调用时会取当前值和上一次值进行比较，如果不相等则会调用 <code>$watch</code> 方法，同时会保存当前的值以在下一次进行比较，并且记录此次检查结果为脏。然后重复进行直到数据不脏为止，因此至少要 digest 两次，超出 10 次会报错，可以调高这个次数限制。当数据不再脏即 model 稳定下来之后， Angular 才会开始一次性批量更新 UI。从而减少了浏览器的 repaint 次数，提升性能。</p>
<p>深入到源码来看：<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div></pre></td><td class="code"><pre><div class="line">$digest: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> watch, value, last, fn, get,</div><div class="line">      watchers,</div><div class="line">      length,</div><div class="line">      dirty, ttl = TTL,</div><div class="line">      next, current, target = <span class="keyword">this</span>,</div><div class="line">      watchLog = [],</div><div class="line">      logIdx, asyncTask;</div><div class="line">      </div><div class="line">  beginPhase(<span class="string">'$digest'</span>);</div><div class="line">  $browser.$$checkUrlChange();</div><div class="line">  </div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> === $rootScope &amp;&amp; applyAsyncId !== <span class="literal">null</span>) &#123;</div><div class="line">    $browser.defer.cancel(applyAsyncId);</div><div class="line">    flushApplyAsync();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  lastDirtyWatch = <span class="literal">null</span>;</div><div class="line">  </div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    dirty = <span class="literal">false</span>;</div><div class="line">    current = target;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> asyncQueuePosition = <span class="number">0</span>; asyncQueuePosition &lt; asyncQueue.length; asyncQueuePosition++) &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        asyncTask = asyncQueue[asyncQueuePosition];</div><div class="line">        asyncTask.scope.$<span class="built_in">eval</span>(asyncTask.expression, asyncTask.locals);</div><div class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        $exceptionHandler(e);</div><div class="line">      &#125;</div><div class="line">      lastDirtyWatch = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">    asyncQueue.length = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 脏值检查开始</span></div><div class="line">    traverseScopesLoop:</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">      <span class="comment">// 获取当前 scope 的 $$watchers</span></div><div class="line">      <span class="keyword">if</span> ((watchers = current.$$watchers)) &#123;</div><div class="line">        <span class="comment">// process our watches</span></div><div class="line">        <span class="comment">// 遍历执行这些 watches</span></div><div class="line">        length = watchers.length;</div><div class="line">        <span class="keyword">while</span> (length--) &#123;</div><div class="line">          <span class="keyword">try</span> &#123;</div><div class="line">            watch = watchers[length];</div><div class="line">            <span class="keyword">if</span> (watch) &#123;</div><div class="line">              get = watch.get;</div><div class="line">              <span class="keyword">if</span> ((value = get(current)) !== (last = watch.last) &amp;&amp;</div><div class="line">                  !(watch.eq</div><div class="line">                      ? equals(value, last)</div><div class="line">                      : (<span class="keyword">typeof</span> value === <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> last === <span class="string">'number'</span></div><div class="line">                         &amp;&amp; <span class="built_in">isNaN</span>(value) &amp;&amp; <span class="built_in">isNaN</span>(last)))) &#123;</div><div class="line">                           <span class="comment">// 优先使用 === 判断 value 和 last，其次再是根据他们是否为数字做 ng 的深度相等判断或者 isNaN 判断</span></div><div class="line">                dirty = <span class="literal">true</span>;</div><div class="line">                lastDirtyWatch = watch;</div><div class="line">                <span class="comment">// 如果 watch.eq 为 true，表示该 watch 的目标为对象，所以把该对象克隆到 watch.last 上面以下一次 digest 时来判断</span></div><div class="line">                <span class="comment">// 如果 watch.eq 为 false，表示该 watch 的目标为数字，所以直接赋值就可以了</span></div><div class="line">                <span class="comment">// 这里和上面一样都是为了提高速度和性能用</span></div><div class="line">                watch.last = watch.eq ? copy(value, <span class="literal">null</span>) : value;</div><div class="line">                <span class="comment">// 获取该 watch 的表达式并执行</span></div><div class="line">                fn = watch.fn;</div><div class="line">                <span class="comment">// 如果 last 和最开始的值相同则使用后者，否则使用前者。</span></div><div class="line">                fn(value, ((last === initWatchVal) ? value : last), current);</div><div class="line">                <span class="keyword">if</span> (ttl &lt; <span class="number">5</span>) &#123;</div><div class="line">                  logIdx = <span class="number">4</span> - ttl;</div><div class="line">                  <span class="keyword">if</span> (!watchLog[logIdx]) watchLog[logIdx] = [];</div><div class="line">                  watchLog[logIdx].push(&#123;</div><div class="line">                    msg: isFunction(watch.exp) ? <span class="string">'fn: '</span> + (watch.exp.name || watch.exp.toString()) : watch.exp,</div><div class="line">                    newVal: value,</div><div class="line">                    oldVal: last</div><div class="line">                  &#125;);</div><div class="line">                &#125;</div><div class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (watch === lastDirtyWatch) &#123;</div><div class="line">                dirty = <span class="literal">false</span>;</div><div class="line">                <span class="keyword">break</span> traverseScopesLoop;</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">            $exceptionHandler(e);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// Insanity Warning: scope depth-first traversal</span></div><div class="line">      <span class="comment">// yes, this code is a bit crazy, but it works and we have tests to prove it!</span></div><div class="line">      <span class="comment">// this piece should be kept in sync with the traversal in $broadcast</span></div><div class="line">      <span class="comment">// 对当前 scope 的子 scope 做遍历</span></div><div class="line">      <span class="keyword">if</span> (!(next = ((current.$$watchersCount &amp;&amp; current.$$childHead) ||</div><div class="line">          (current !== target &amp;&amp; current.$$nextSibling)))) &#123;</div><div class="line">        <span class="keyword">while</span> (current !== target &amp;&amp; !(next = current.$$nextSibling)) &#123;</div><div class="line">          current = current.$parent;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">while</span> ((current = next));</div><div class="line">    </div><div class="line">    <span class="comment">// 脏值检查未结束但此时 ttl 为 0，则抛出错误</span></div><div class="line">    <span class="keyword">if</span> ((dirty || asyncQueue.length) &amp;&amp; !(ttl--)) &#123;</div><div class="line">      clearPhase();</div><div class="line">      <span class="keyword">throw</span> $rootScopeMinErr(<span class="string">'infdig'</span>,</div><div class="line">          <span class="string">'&#123;0&#125; $digest() iterations reached. Aborting!\n'</span> +</div><div class="line">          <span class="string">'Watchers fired in the last 5 iterations: &#123;1&#125;'</span>,</div><div class="line">          TTL, watchLog);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 循环遍历直到 dirty 为 false 并且 asyncQueue.length = 0</span></div><div class="line">  &#125; <span class="keyword">while</span> (dirty || asyncQueue.length);</div><div class="line"></div><div class="line">  clearPhase();</div><div class="line"></div><div class="line">  <span class="comment">// 执行 postDigest 序列</span></div><div class="line">  <span class="keyword">while</span> (postDigestQueuePosition &lt; postDigestQueue.length) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      postDigestQueue[postDigestQueuePosition++]();</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">      $exceptionHandler(e);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  postDigestQueue.length = postDigestQueuePosition = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不过这段代码我也不是全都理解了，但是核心的算了解了。总体来看这个算法还是很简单粗暴的，这里保留了一段注释，有意思，官方吐槽的感觉。</p>
<p>由于脏检查的性能问题，在页面绑定数据较多的时候，我们应该尽量减少双向绑定的数量，比如使用 <code>ngInfiniteScroll</code> 这样的插件，适当使用单向绑定，甚至是取消一些变量的 watch 方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Angular 的脏值检查机制一直是 Angular 被人诟病的地方，但瑕不掩瑜，Angular 还是一个非常优秀的框架，并且 Angular2 也已经抛弃了这个脏值检查的算法。&lt;br&gt;最近在看《AngularJS 深度剖析与最佳实践》，不得不说是一本很好的书籍，作者在第三章开始讲背后的原理，这里分析了 Angular 的 $digest 函数，即脏检查机制。所以自己也去下载了 Angular 最新的源码去瞧了下，然后做下笔记吧。&lt;/p&gt;
&lt;p&gt;首先要注意，Angular 的 digest 的触发不是定时的，只有在指定的事件触发之后才会进入 $digest。基本上我们用的带 &lt;code&gt;$&lt;/code&gt; 的东西调用之后都可能会触发 digest。比如我们使用 &lt;code&gt;setTimeout&lt;/code&gt; 就不会触发 digest，即当你使用 &lt;code&gt;setTimeout&lt;/code&gt; 更改 viewmodel 的值后，它不会同步的反映到用户的视图中去，解决方法有两个，一个是使用 Angular 提供的 &lt;code&gt;$timeout&lt;/code&gt; 替代 &lt;code&gt;setTimeout&lt;/code&gt;，&lt;code&gt;$timeout&lt;/code&gt; 会在执行结束之后自动触发 digest； 另一个方法是手动调用 $apply，$apply 是 Angular 对 digest 的一层封装，我们一般不会直接调用 digest 而是通过使用 $apply 方法。比如对于 &lt;code&gt;setTimeout&lt;/code&gt;，我们就可以这样触发 digest。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;setTimeout(() =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  $scope.$apply(() =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    $scope.test = &lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;)    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;number&quot;&gt;500&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们看一个例子，这也是 Angular 源码 $digest 部分的一个示例。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; scope = ...;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;scope.name = &lt;span class=&quot;string&quot;&gt;&#39;misko&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;scope.counter = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;expect(scope.counter).toEqual(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;scope.$watch(&lt;span class=&quot;string&quot;&gt;&#39;name&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;newValue, oldValue&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  scope.counter = scope.counter + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;expect(scope.counter).toEqual(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 执行第一次 digest，第一次 digest 会遍历全部的 watcher，并触发上面的方法，从而使的 count+1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;scope.$digest();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;expect(scope.counter).toEqual(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 第二次调用时，由于上一次调用检查 name 不脏，所以不会再去处理&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;scope.$digest();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;expect(scope.counter).toEqual(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 第三次调用时，由于 name 发生了变化，使得当前值和上一次保存的值不同，所以会触发起 $watch 方法&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;scope.name = &lt;span class=&quot;string&quot;&gt;&#39;adam&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;scope.$digest();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;expect(scope.counter).toEqual(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Angular 的脏值检查过程大致如下：&lt;br&gt;对当前作用域和子作用域上的 &lt;code&gt;$$watchers&lt;/code&gt; 进行遍历，&lt;code&gt;$$watches&lt;/code&gt; 保存着 scope 上的所有变量以及其 &lt;code&gt;$watch&lt;/code&gt; 方法，调用时会取当前值和上一次值进行比较，如果不相等则会调用 &lt;code&gt;$watch&lt;/code&gt; 方法，同时会保存当前的值以在下一次进行比较，并且记录此次检查结果为脏。然后重复进行直到数据不脏为止，因此至少要 digest 两次，超出 10 次会报错，可以调高这个次数限制。当数据不再脏即 model 稳定下来之后， Angular 才会开始一次性批量更新 UI。从而减少了浏览器的 repaint 次数，提升性能。&lt;/p&gt;
&lt;p&gt;深入到源码来看：&lt;br&gt;
    
    </summary>
    
      <category term="Angular" scheme="https://ruiming.github.io/categories/Angular/"/>
    
    
      <category term="Angular" scheme="https://ruiming.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>项目采坑笔记</title>
    <link href="https://ruiming.github.io/2016/08/15/%E9%A1%B9%E7%9B%AE%E9%87%87%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    <id>https://ruiming.github.io/2016/08/15/项目采坑笔记/</id>
    <published>2016-08-15T08:37:19.000Z</published>
    <updated>2016-08-15T15:38:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>有段时间没写博客了，前段时间在看 Underscore 源码所以写的多了点，这段时间还是在忙自己的其他项目去了，还是有不少收获的。</p>
<h2 id="Angular-视图过渡动画"><a href="#Angular-视图过渡动画" class="headerlink" title="Angular 视图过渡动画"></a>Angular 视图过渡动画</h2><p>之前使用 <code>angular-promise-button</code> 这个模块实现了按钮的自动变化，以前自己是用很多标志位来判断特别二。不仅如此，页面切换动画也是用标志位判断，这样就特别不好维护特别不优雅，上次重构的时候就把这些全部去掉了。但是问题来了，页面数据未到达时候页面就渲染肯定会造成视觉上的问题，怎么解决呢。<br>我们都想写一些应用很广的代码，比如指令，比如上面这个 <code>angular-promise-button</code> 模块等等。其实要解决上面的问题，也是几行代码就可以解决的事情了。<br>我所使用的是 Angular 的 ui-router。ngRoute 应该也差不多。<br>在 ui-router 中可以使用 resolve 达到在控制器初始化以及视图加载前确保数据到达。比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$stateProvider</div><div class="line">    .state(<span class="string">'me'</span>,&#123;</div><div class="line">        url: <span class="string">'/me'</span>,</div><div class="line">        controller: <span class="string">'MeCtrl'</span>,</div><div class="line">        templateUrl: <span class="string">'me/me_tpl.html'</span>,</div><div class="line">        controllerAs: <span class="string">'vm'</span>,</div><div class="line">        nav: <span class="literal">true</span>,</div><div class="line">        resolve: &#123;</div><div class="line">            me: <span class="function"><span class="keyword">function</span>(<span class="params">userservice</span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> userservice.getUserInfo()</div><div class="line">                    .then(response =&gt; response);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;)</div></pre></td></tr></table></figure></p>
<p>只有 resolve 中的全部方法执行完后，才会开始初始化控制和加载视图。这个数据如果在控制器或者视图中要使用，可以在控制器中进行依赖注入。例如上面这个我的控制器是这样写的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="meta">    'use strict'</span>;</div><div class="line">    </div><div class="line">    angular</div><div class="line">        .module(<span class="string">'index'</span>)</div><div class="line">        .controller(<span class="string">'MeCtrl'</span>, MeCtrl);</div><div class="line">        </div><div class="line">    MeCtrl.$inject = [<span class="string">'me'</span>];</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">MeCtrl</span>(<span class="params">me</span>) </span>&#123;</div><div class="line">        <span class="keyword">let</span> vm = <span class="keyword">this</span>;</div><div class="line">        vm.user = me;</div><div class="line">    &#125;</div><div class="line">&#125;());</div></pre></td></tr></table></figure></p>
<p>resolve中的方法是阻塞页面进行的，这样就会带来问题了，如果数据请求比较久将导致网站停滞，我们这时候就希望可以有过渡动画出来。要达到全局过渡效果的作用，可以直接监听 <code>$rootScope</code> 中的三个状态即 <code>$stateChangeStart</code> 和 <code>$stateChangeSuccess</code> 以及 <code>$stateChangeError</code> 事件。例如上面这个例子中，当我们触发 <code>me</code> 这个 state 时，也就触发了 $rootScope 上的 <code>$stateChangeStart</code> 事件，当处理结束后将出发 <code>$stateChangeSuccess</code> 并加载视图， 处理失败就会触发 <code>$stateChangeError</code> 事件。代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">angular</div><div class="line">    .module(<span class="string">'index'</span>, [</div><div class="line">        <span class="string">'ui.router'</span>,</div><div class="line">        <span class="string">'ui.bootstrap'</span>,</div><div class="line">        <span class="string">'ngAnimate'</span>,</div><div class="line">        <span class="string">'ngSanitize'</span>,</div><div class="line">        <span class="string">'ngTouch'</span>,</div><div class="line">        <span class="string">'infinite-scroll'</span>,</div><div class="line">        <span class="string">'angularPromiseButtons'</span></div><div class="line">    ])</div><div class="line">    .config(config)</div><div class="line">    .run(($state,$rootScope) =&gt; &#123;</div><div class="line">        $rootScope.$state = $state;</div><div class="line">        $rootScope.$on(<span class="string">"$stateChangeStart"</span>, (event, toState, toStateParams, fromState, fromStateParams) =&gt; &#123;</div><div class="line">            <span class="keyword">var</span> isLoading = toState.resolve;</div><div class="line">            <span class="keyword">if</span>(!isLoading) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> toState.views) &#123;</div><div class="line">                    <span class="keyword">if</span> (toState.views.hasOwnProperty(prop)) &#123;</div><div class="line">                        <span class="keyword">if</span>(toState.views[prop].resolve) &#123;</div><div class="line">                            isLoading = <span class="literal">true</span>;</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (isLoading) &#123;</div><div class="line">                $rootScope.loading = <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        $rootScope.$on(<span class="string">"$stateChangeSuccess"</span>, (event, toState, toParams, fromState, fromParams) =&gt; &#123;</div><div class="line">            $rootScope.loading = <span class="literal">false</span>;</div><div class="line">        &#125;);</div><div class="line">        $rootScope.$on(<span class="string">"$stateChangeError"</span>, (event, toState, toParams, fromState, fromParams, error) =&gt; &#123;</div><div class="line">            $rootScope.loading = <span class="literal">false</span>;</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p>
<p>入口页面，省去了其他代码，这里第一行就是视图，第二行是加载动画，通过ng-show来控制显示。第三行是引入导航栏，这个在后面会说下。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span> <span class="attr">class</span>=<span class="string">"uiview"</span> <span class="attr">ng-show</span>=<span class="string">"!$root.loading"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cssload-thecube"</span> <span class="attr">ng-show</span>=<span class="string">"$root.loading"</span>&gt;</span> loading... <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-show</span>=<span class="string">"$state.current.nav"</span> <span class="attr">ng-include</span>=<span class="string">"'navbar/navbar_tpl.html'"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>可以看到上面的代码中是监听了 <code>$stateChangeStart</code> 事件，然后获取目标 state 上的 resolve 方法，当 state 上的 resolve 方法全部结束后，<code>$rootScope.loading</code> 设置为 false，否则保持为 true。<br>当监听到 <code>$stateChangeSuccess</code> 或者 <code>$stateChangeError</code> 事件时，置 <code>$rootScope.loading</code> 为 false，退出过渡动画。在视图中可以使用 <code>$root</code> 得到 <code>$rootScope</code>。<br>可以看到这里有很多参数，可见其功能是很强大的。<br><a id="more"></a><br>再看下上面这个第三行<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-show</span>=<span class="string">"$state.current.nav"</span> <span class="attr">ng-include</span>=<span class="string">"'navbar/navbar_tpl.html'"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>结合上面的 JS 代码来看，我已经把 <code>$state</code> 注入到了 <code>$rootScope</code> 中了，之后我就可以使用 <code>$state.current</code> 来获取当前的视图状态和信息。我需要实现导航栏仅仅出现在我指定的页面中，下方按钮可以根据当前视图来激活。第一点可以通过给路由 state 补充变量比如我这里的 <code>nav</code> 来实现，需要导航栏的地方就设置 <code>nav</code> 为 true, 否则就不设置。第二点则可以利用 <code>ui-sref-active</code> 来实现。如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- navbar/navbar_tpl.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"bookist-nav navbar navbar-default"</span> <span class="attr">role</span>=<span class="string">"navigation"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"nav navbar-nav"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">ui-sref-active</span>=<span class="string">"active"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">ui-sref</span>=<span class="string">"index"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-home fa-lg"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">ui-sref-active</span>=<span class="string">"active"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">ui-sref</span>=<span class="string">"booklists"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-th-large fa-lg"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>书单<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">ui-sref-active</span>=<span class="string">"active"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">ui-sref</span>=<span class="string">"cart"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-shopping-cart fa-lg"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>购物车<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">ui-sref-active</span>=<span class="string">"active"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">ui-sref</span>=<span class="string">"me"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-user fa-lg"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>我的<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>最后还有一个地方就是，下面这个代码<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span> <span class="attr">class</span>=<span class="string">"uiview"</span> <span class="attr">ng-show</span>=<span class="string">"!$root.loading"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>ui-view 的用法其实还不少，如果你有去注意的话，会看到这个视图在变化的时候其类名会变化，依次我们可以结合 angular-animate 来实现切换动画。注意这个切换动画是在视图加载后才开始的，和上面的不一样，如果同时使用，则会在上方过渡效果结束后触发。例如，我们可以实现淡入淡出：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.uiview &#123;</div><div class="line">  &amp;.ng-enter &#123;</div><div class="line">    transition: .5s;</div><div class="line">    opacity: 0;</div><div class="line">  &#125;</div><div class="line">  &amp;.ng-enter-active &#123;</div><div class="line">    opacity: 1;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以上面其实说了好几点：</p>
<ul>
<li>使用路由上的 resolve 来实现在控制器初始化前获取到需要的数据</li>
<li>监听 $rootScope 上的事件来实现 resolve 等待动画</li>
<li>在 ui-view 上通过使用 angular-animate 来实现视图的切换动画</li>
<li>通过 ui-sref-active 在当 ui-sref 和当前 state 一致时激活 active 类名</li>
<li>把 $state 注入到 $rootScope 达到在视图中获取 $state 用途</li>
<li>使用 $root 得到 $rootScope，利用 $root 获取 $rootScope 上的对象</li>
</ul>
<h2 id="静态资源自动发布七牛云"><a href="#静态资源自动发布七牛云" class="headerlink" title="静态资源自动发布七牛云"></a>静态资源自动发布七牛云</h2><p>这个很简单啦，我使用了 gulp-qiniu 这个模块来实现，很简单，结合前面说的 gulp-usemin 就更完美了。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- build:js //cdn.bookist.org/bookist.min.js --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"src/js/bookist.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"src/js/templates.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- endbuild --&gt;</span></div></pre></td></tr></table></figure></p>
<p>例如对上面 index.html 中的这一片段，我们要在开发环境中使用本地资源，而在线上环境则使用 CDN 资源。我们可以这样配置 gulpfile。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">gulp</span><span class="selector-class">.task</span>(<span class="string">'cdn'</span>, () =&gt; &#123;</div><div class="line">    gulp<span class="selector-class">.src</span>(<span class="string">'index.html'</span>)</div><div class="line">        <span class="selector-class">.pipe</span>(usemin())</div><div class="line">        <span class="selector-class">.pipe</span>(gulp.dest(<span class="string">'backend/app/templates'</span>));</div><div class="line">    <span class="selector-tag">gulp</span><span class="selector-class">.src</span>([<span class="string">'./src/js/bookist.js'</span>, <span class="string">'./src/js/templates.js'</span>])</div><div class="line">        <span class="selector-class">.pipe</span>(plumber())</div><div class="line">        <span class="selector-class">.pipe</span>(uglify())</div><div class="line">        <span class="selector-class">.pipe</span>(babel())</div><div class="line">        <span class="selector-class">.pipe</span>(concat(<span class="string">'bookist.min.js'</span>))</div><div class="line">        <span class="selector-class">.pipe</span>(qiniu(&#123;</div><div class="line">            <span class="attribute">accessKey</span>: <span class="string">"xxx"</span>,</div><div class="line">            <span class="attribute">secretKey</span>: <span class="string">"xxx"</span>,</div><div class="line">            <span class="attribute">bucket</span>: <span class="string">"bookist"</span>,</div><div class="line">            <span class="attribute">private</span>: false</div><div class="line">        &#125;));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行上面的任务后就会在 <code>backend/app/templates</code> 生成一个修改过的 index.html。对于上面的片段，处理之后是这样的：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.bookist.org/bookist.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>前面的注释是给 usemin 使用的，所以要按照规范书写。<br>同时上面的任务也会把资源发布到七牛云上面，如果你还想指定文件头或者版本号之类的信息，可以参考 gulp-qiniu 的文档进行配置。<br>上面的方法有一个小问题就是还会在 <code>backend/app/templates</code> 生成一个 <code>cdn.bookist.org</code> 的文件夹，不过无所谓咯，放到 .gitignore 就好了。<br>至于图片和 css 都差不多吧，就不多说了。</p>
<h2 id="微信坑逼"><a href="#微信坑逼" class="headerlink" title="微信坑逼"></a>微信坑逼</h2><p>有段时间我的网站在微信显示部分地方是有问题的，但在手机浏览器和电脑都没任何问题，一开始以为是样式的问题。等到自己要去解决这个问题了，才知道是 js 的问题。<br>由于微信开发工具不支持 linux，然后我虚拟机的 win10 有不知道什么原因一直连接不到手机。所以就手动调试了，这边改一点，发布上去，然后等微信缓存没了看效果(微信恶心的缓存…我都叫用苹果的人帮我看，因为苹果可以刷新..)。就这样一步步看，最后定位了问题代码。中间过程就不描述了，直接看：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> book <span class="keyword">of</span> books) &#123;</div><div class="line">    <span class="keyword">if</span>(book.rate)   book.star = <span class="built_in">Math</span>.ceil(book.rate/<span class="number">2</span>);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(book.star)   book.star = <span class="built_in">Math</span>.ceil(book.star/<span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>省略了无关代码，这是一个方法里面的部分代码，如果一个对象传入这个方法中，在微信会得不到返回值，在手机浏览器和电脑上都正常。<br>虽然这里使用了 ES6 的语法，但是我其实已经大量使用 let…of… 语句，项目并没有出现太大问题，就只是上面描述的一些地方异常而已。再者我使用了 babel 转码了。越想越觉得没道理啊。。。<br>最后虚拟机换了 win7 然后手机连接上了，打开了微信开发工具，调试微信 webview，报错 <code>Symbol is not defined</code>。<br>果断控制台敲 Symbol，结果 <code>Symbol is not defined</code>。<br>好吧，问题出来了，微信这个辣鸡不支持 Symbol…<br>但问题是我没有用 Symbol 这个东西啊，我瞄了 babel 一眼。<br>看下上面那段代码转码的结果：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _iteratorNormalCompletion5 = <span class="literal">true</span>;</div><div class="line"><span class="keyword">var</span> _didIteratorError5 = <span class="literal">false</span>;</div><div class="line"><span class="keyword">var</span> _iteratorError5 = <span class="literal">undefined</span>;</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> _iterator5 = books[<span class="built_in">Symbol</span>.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = <span class="literal">true</span>) &#123;</div><div class="line">        <span class="keyword">var</span> book = _step5.value;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (book.rate) book.star = <span class="built_in">Math</span>.ceil(book.rate / <span class="number">2</span>);<span class="keyword">else</span> <span class="keyword">if</span> (book.star) book.star = <span class="built_in">Math</span>.ceil(book.star / <span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">    _didIteratorError5 = <span class="literal">true</span>;</div><div class="line">    _iteratorError5 = err;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (!_iteratorNormalCompletion5 &amp;&amp; _iterator5.return) &#123;</div><div class="line">            _iterator5.return();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (_didIteratorError5) &#123;</div><div class="line">            <span class="keyword">throw</span> _iteratorError5;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>什么鬼…算了，不看了，但是确定了是 babel 转码导致的。然后查了下资料：</p>
<blockquote>
<p>Babel默认只转换新的JavaScript句法(syntax)，而不转换新的API，比如Iterator, Generator, Set, Maps, Proxy, Reflect, Symbol, Promise等全局对象，以及一些定义在全局对象上的方法(比如Object.assign)都不会转码。</p>
</blockquote>
<p>其实早有耳闻 polyfill 这个东西，但我想他一般是用在 IE 这种辣鸡浏览器上的，没想到微信 webview 这么不争气。<br>多打包一个 babel-polyfill 解决了这个问题。<br>坑比微信…</p>
<p>故事还没结束…<br>昨天发现网站并没有使用 http2，但是已经进行了设置了，最后查了很多资料原因好像是 openssl 的问题，但由于使用的是 docker，貌似不太好搞，但其实更换 nginx 版本就好了，原先是1.9版本，换成1.11-alpine 版就解决了，用 docker 更换 nginx 版本非常方便。额，具体原因不深究了，可能跟 alpine 这个字眼有关？不清楚…<br>http2 具备多路复用的特点，在 http1.1 中，并行传输文件是有限制的，因为用户端和服务端的最大连接数是有限制的，而连接的建立和销毁又会带来开销，所以在 http1.1 中对文件进行压缩合并是很有必要的。不过在 http2 就不需要这样做了，http2 可以在一条通道上传输多个文件，如果合并剩几个，就没法发挥并行传输的优势，而且文件太大，还会降低运输层的效率，即丢包或者乱序到达的影响。<br>我把网站改到了 http2 后，就不再进行文件合并了，转而可以大量使用 bootcss 的 CDN，bootcss 的 CDN 支持 http2，传输很快。至于上面没有的和自己写的，就发布到七牛云上面。恩，电脑上加载是变快了很多。<br>但是感觉不到微信加载变快…最后发现是微信不支持 http2…<br>好伤心…<br>最后我的方案是产生两个 css 文件和两个 js 文件，之所以是两个，因为一个是自己写的，经常变，另一个是用别人的，几乎不会变。</p>
<p>最后又发现微信好像支持 spdy… 心好累，算了，降了 nginx 版本开启 spdy 不理了。</p>
<hr>
<p>总结：</p>
<ul>
<li>Angular 是一个大而全的框架，我觉得很强大很牛逼，越来越喜欢 Angular 了</li>
<li>使用 CDN 可以大大的加速，尽量使用 CDN</li>
<li>微信这个坑比我就不说了，不支持 Symbol 不支持 http2</li>
<li>能用 http2 就尽量用 http2</li>
<li>考虑浏览器兼容性，根据需要引入 babel-polyfill</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有段时间没写博客了，前段时间在看 Underscore 源码所以写的多了点，这段时间还是在忙自己的其他项目去了，还是有不少收获的。&lt;/p&gt;
&lt;h2 id=&quot;Angular-视图过渡动画&quot;&gt;&lt;a href=&quot;#Angular-视图过渡动画&quot; class=&quot;headerlink&quot; title=&quot;Angular 视图过渡动画&quot;&gt;&lt;/a&gt;Angular 视图过渡动画&lt;/h2&gt;&lt;p&gt;之前使用 &lt;code&gt;angular-promise-button&lt;/code&gt; 这个模块实现了按钮的自动变化，以前自己是用很多标志位来判断特别二。不仅如此，页面切换动画也是用标志位判断，这样就特别不好维护特别不优雅，上次重构的时候就把这些全部去掉了。但是问题来了，页面数据未到达时候页面就渲染肯定会造成视觉上的问题，怎么解决呢。&lt;br&gt;我们都想写一些应用很广的代码，比如指令，比如上面这个 &lt;code&gt;angular-promise-button&lt;/code&gt; 模块等等。其实要解决上面的问题，也是几行代码就可以解决的事情了。&lt;br&gt;我所使用的是 Angular 的 ui-router。ngRoute 应该也差不多。&lt;br&gt;在 ui-router 中可以使用 resolve 达到在控制器初始化以及视图加载前确保数据到达。比如：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$stateProvider&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    .state(&lt;span class=&quot;string&quot;&gt;&#39;me&#39;&lt;/span&gt;,&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        url: &lt;span class=&quot;string&quot;&gt;&#39;/me&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        controller: &lt;span class=&quot;string&quot;&gt;&#39;MeCtrl&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        templateUrl: &lt;span class=&quot;string&quot;&gt;&#39;me/me_tpl.html&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        controllerAs: &lt;span class=&quot;string&quot;&gt;&#39;vm&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        nav: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        resolve: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            me: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;userservice&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; userservice.getUserInfo()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    .then(response =&amp;gt; response);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;只有 resolve 中的全部方法执行完后，才会开始初始化控制和加载视图。这个数据如果在控制器或者视图中要使用，可以在控制器中进行依赖注入。例如上面这个我的控制器是这样写的：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;    &#39;use strict&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    angular&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        .module(&lt;span class=&quot;string&quot;&gt;&#39;index&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        .controller(&lt;span class=&quot;string&quot;&gt;&#39;MeCtrl&#39;&lt;/span&gt;, MeCtrl);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    MeCtrl.$inject = [&lt;span class=&quot;string&quot;&gt;&#39;me&#39;&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MeCtrl&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;me&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; vm = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        vm.user = me;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;());&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;resolve中的方法是阻塞页面进行的，这样就会带来问题了，如果数据请求比较久将导致网站停滞，我们这时候就希望可以有过渡动画出来。要达到全局过渡效果的作用，可以直接监听 &lt;code&gt;$rootScope&lt;/code&gt; 中的三个状态即 &lt;code&gt;$stateChangeStart&lt;/code&gt; 和 &lt;code&gt;$stateChangeSuccess&lt;/code&gt; 以及 &lt;code&gt;$stateChangeError&lt;/code&gt; 事件。例如上面这个例子中，当我们触发 &lt;code&gt;me&lt;/code&gt; 这个 state 时，也就触发了 $rootScope 上的 &lt;code&gt;$stateChangeStart&lt;/code&gt; 事件，当处理结束后将出发 &lt;code&gt;$stateChangeSuccess&lt;/code&gt; 并加载视图， 处理失败就会触发 &lt;code&gt;$stateChangeError&lt;/code&gt; 事件。代码如下：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;angular&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    .module(&lt;span class=&quot;string&quot;&gt;&#39;index&#39;&lt;/span&gt;, [&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;ui.router&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;ui.bootstrap&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;ngAnimate&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;ngSanitize&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;ngTouch&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;infinite-scroll&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;angularPromiseButtons&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    .config(config)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    .run(($state,$rootScope) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        $rootScope.$state = $state;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        $rootScope.$on(&lt;span class=&quot;string&quot;&gt;&quot;$stateChangeStart&quot;&lt;/span&gt;, (event, toState, toStateParams, fromState, fromStateParams) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; isLoading = toState.resolve;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!isLoading) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; prop &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; toState.views) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (toState.views.hasOwnProperty(prop)) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(toState.views[prop].resolve) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                            isLoading = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isLoading) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                $rootScope.loading = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        $rootScope.$on(&lt;span class=&quot;string&quot;&gt;&quot;$stateChangeSuccess&quot;&lt;/span&gt;, (event, toState, toParams, fromState, fromParams) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            $rootScope.loading = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        $rootScope.$on(&lt;span class=&quot;string&quot;&gt;&quot;$stateChangeError&quot;&lt;/span&gt;, (event, toState, toParams, fromState, fromParams, error) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            $rootScope.loading = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;入口页面，省去了其他代码，这里第一行就是视图，第二行是加载动画，通过ng-show来控制显示。第三行是引入导航栏，这个在后面会说下。&lt;br&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ui-view&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;uiview&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ng-show&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;!$root.loading&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;cssload-thecube&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ng-show&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;$root.loading&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt; loading... &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ng-show&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;$state.current.nav&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ng-include&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;&#39;navbar/navbar_tpl.html&#39;&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看到上面的代码中是监听了 &lt;code&gt;$stateChangeStart&lt;/code&gt; 事件，然后获取目标 state 上的 resolve 方法，当 state 上的 resolve 方法全部结束后，&lt;code&gt;$rootScope.loading&lt;/code&gt; 设置为 false，否则保持为 true。&lt;br&gt;当监听到 &lt;code&gt;$stateChangeSuccess&lt;/code&gt; 或者 &lt;code&gt;$stateChangeError&lt;/code&gt; 事件时，置 &lt;code&gt;$rootScope.loading&lt;/code&gt; 为 false，退出过渡动画。在视图中可以使用 &lt;code&gt;$root&lt;/code&gt; 得到 &lt;code&gt;$rootScope&lt;/code&gt;。&lt;br&gt;可以看到这里有很多参数，可见其功能是很强大的。&lt;br&gt;
    
    </summary>
    
      <category term="Angular" scheme="https://ruiming.github.io/categories/Angular/"/>
    
    
      <category term="Angular" scheme="https://ruiming.github.io/tags/Angular/"/>
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 JavaScript 模块定义规范</title>
    <link href="https://ruiming.github.io/2016/08/06/%E6%B5%85%E8%B0%88JavaScript%E6%A8%A1%E5%9D%97%E5%AE%9A%E4%B9%89%E8%A7%84%E8%8C%83/"/>
    <id>https://ruiming.github.io/2016/08/06/浅谈JavaScript模块定义规范/</id>
    <published>2016-08-06T14:28:35.000Z</published>
    <updated>2016-08-06T14:31:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>JS 模块定义常见的有三种方式，即 AMD, CMD 和 CommonJS。其实还有一个 UMD，他是 CommonJS 和 AMD 揉和在一起而已。不过这些都 out 了，拥抱 ES6 吧。话虽这么说，你让那些不用 ES6 不用 babel 的怎么活，所以还是要了解下滴。</p>
<h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>CommonJS 是服务端即 Node.js 采用的模块化方案，我们应该都很熟悉了。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line">fs.readFileSync();</div></pre></td></tr></table></figure></p>
<p>这个过程是同步的，只有成功加载 <code>fs</code> 后才能执行后面的步骤。但在服务器文件都在本地，所以这个问题不大。但这个在浏览器就不合适了，如果文件加载耗时很长，将导致一直等待。</p>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>AMD 全称 Asynchronous Module Definition，意思就是异步模块定义。<br>用法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">math</span>) </span>&#123;</div><div class="line">    math.add(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>math 模块的加载和 <code>math.add()</code> 方法的执行不是同步的，这样浏览器就不会假死。<br>RequireJs 和 CurlJs 实现了 AMD 规范，将他们嵌入网页，就可以在浏览器端进行模块化编程了。<br>关于 AMD 的详细模块定义可以参考<a href="https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88" target="_blank" rel="external">wiki</a>)。这里给出 Underscore 的 AMD 定义方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> define == <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</div><div class="line">    define(<span class="string">'underscore'</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> _;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>CMD 全称 Common Module Definition，意思就是通用模块定义。。<br>对于依赖的模块，AMD 是提前执行，而 CMD 是延迟执行。AMD 推崇依赖前置，而 CMD 则推崇依赖就近。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> math = <span class="built_in">require</span>(<span class="string">'./math'</span>);</div><div class="line">    math.add(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>CMD 的主要实现是 SeaJS<br>AMD 预先加载所有依赖，使用的时候才去执行，速度快，可以并行加载多个模块。但这就需要开发的时候把全部依赖都提前定义，不便于开发和阅读，而且部分依赖（弱依赖）可能只在少数情况下使用。<br>CMD 只有在真正需要的时候才去加载依赖，使用的时候才去定义执行，但这个加载逻辑偏重，耗性能。</p>
<h2 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h2><p>UMD 全称 Universal Module Definition。<br>UMD 是 AMD 和 CommonJS 的揉和，他优先使用 CommonJS 的加载方式，其次才使用 AMD 的加载方式。<br>例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">window, factory</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">'object'</span>) &#123;</div><div class="line">     </div><div class="line">        <span class="built_in">module</span>.exports = factory();</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</div><div class="line">     </div><div class="line">        define(factory);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">     </div><div class="line">        <span class="built_in">window</span>.eventUtil = factory();</div><div class="line">    &#125;</div><div class="line">&#125;)(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//module ...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>其实就是一个服务端和浏览端通用的模块解决方案。</p>
<h2 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h2><p>ES6 在语言规格的层面上实现了模块功能，并且实现非常简单，完全可以替代现有的模块加载方案，成为浏览器和服务端都通用的模块解决方案。<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;stat, exists, readFile&#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</div></pre></td></tr></table></figure></p>
<p>这种做法将只在 fs 模块加载3个方法，其他方法不会进行加载。ES6 可以在编译时就完成模块加载，效率比 CommonJS 的加载方式高。<br>在浏览器中使用 ES6 模块的语法：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"foo.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>目前 Node 默认模块格式是 CommonJS，ES6 的模块方案还不支持，但可以通过 babel 来使用。</p>
<p>现在推荐做法是广泛使用 ES6 甚至 ES7 来书写 JavaScript 以提高开发效率，再使用 babel 转码就好了。所以前后端我们也都可以使用 ES6 的 Module 来进行。其他的模块加载方案应该会渐渐退出历史舞台。</p>
<hr>
<p><a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="external">ECMAScript6 入门 Module</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS 模块定义常见的有三种方式，即 AMD, CMD 和 CommonJS。其实还有一个 UMD，他是 CommonJS 和 AMD 揉和在一起而已。不过这些都 out 了，拥抱 ES6 吧。话虽这么说，你让那些不用 ES6 不用 babel 的怎么活，所以还是要了解下滴。&lt;/p&gt;
&lt;h2 id=&quot;CommonJS&quot;&gt;&lt;a href=&quot;#CommonJS&quot; class=&quot;headerlink&quot; title=&quot;CommonJS&quot;&gt;&lt;/a&gt;CommonJS&lt;/h2&gt;&lt;p&gt;CommonJS 是服务端即 Node.js 采用的模块化方案，我们应该都很熟悉了。例如：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; fs = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;fs&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;fs.readFileSync();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个过程是同步的，只有成功加载 &lt;code&gt;fs&lt;/code&gt; 后才能执行后面的步骤。但在服务器文件都在本地，所以这个问题不大。但这个在浏览器就不合适了，如果文件加载耗时很长，将导致一直等待。&lt;/p&gt;
&lt;h2 id=&quot;AMD&quot;&gt;&lt;a href=&quot;#AMD&quot; class=&quot;headerlink&quot; title=&quot;AMD&quot;&gt;&lt;/a&gt;AMD&lt;/h2&gt;&lt;p&gt;AMD 全称 Asynchronous Module Definition，意思就是异步模块定义。&lt;br&gt;用法如下：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;([&lt;span class=&quot;string&quot;&gt;&#39;math&#39;&lt;/span&gt;], &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;math&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    math.add(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;math 模块的加载和 &lt;code&gt;math.add()&lt;/code&gt; 方法的执行不是同步的，这样浏览器就不会假死。&lt;br&gt;RequireJs 和 CurlJs 实现了 AMD 规范，将他们嵌入网页，就可以在浏览器端进行模块化编程了。&lt;br&gt;关于 AMD 的详细模块定义可以参考&lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88&quot;&gt;wiki&lt;/a&gt;)。这里给出 Underscore 的 AMD 定义方法：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; define == &lt;span class=&quot;string&quot;&gt;&#39;function&#39;&lt;/span&gt; &amp;amp;&amp;amp; define.amd) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    define(&lt;span class=&quot;string&quot;&gt;&#39;underscore&#39;&lt;/span&gt;, [], &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;CMD&quot;&gt;&lt;a href=&quot;#CMD&quot; class=&quot;headerlink&quot; title=&quot;CMD&quot;&gt;&lt;/a&gt;CMD&lt;/h2&gt;&lt;p&gt;CMD 全称 Common Module Definition，意思就是通用模块定义。。&lt;br&gt;对于依赖的模块，AMD 是提前执行，而 CMD 是延迟执行。AMD 推崇依赖前置，而 CMD 则推崇依赖就近。例如：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;define(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;require, exports, module&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; math = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;./math&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    math.add(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;CMD 的主要实现是 SeaJS&lt;br&gt;AMD 预先加载所有依赖，使用的时候才去执行，速度快，可以并行加载多个模块。但这就需要开发的时候把全部依赖都提前定义，不便于开发和阅读，而且部分依赖（弱依赖）可能只在少数情况下使用。&lt;br&gt;CMD 只有在真正需要的时候才去加载依赖，使用的时候才去定义执行，但这个加载逻辑偏重，耗性能。&lt;/p&gt;
&lt;h2 id=&quot;UMD&quot;&gt;&lt;a href=&quot;#UMD&quot; class=&quot;headerlink&quot; title=&quot;UMD&quot;&gt;&lt;/a&gt;UMD&lt;/h2&gt;&lt;p&gt;UMD 全称 Universal Module Definition。&lt;br&gt;UMD 是 AMD 和 CommonJS 的揉和，他优先使用 CommonJS 的加载方式，其次才使用 AMD 的加载方式。&lt;br&gt;例如：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;window, factory&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; exports === &lt;span class=&quot;string&quot;&gt;&#39;object&#39;&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = factory();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; define === &lt;span class=&quot;string&quot;&gt;&#39;function&#39;&lt;/span&gt; &amp;amp;&amp;amp; define.amd) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        define(factory);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.eventUtil = factory();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//module ...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其实就是一个服务端和浏览端通用的模块解决方案。&lt;/p&gt;
&lt;h2 id=&quot;ES6-Module&quot;&gt;&lt;a href=&quot;#ES6-Module&quot; class=&quot;headerlink&quot; title=&quot;ES6 Module&quot;&gt;&lt;/a&gt;ES6 Module&lt;/h2&gt;&lt;p&gt;ES6 在语言规格的层面上实现了模块功能，并且实现非常简单，完全可以替代现有的模块加载方案，成为浏览器和服务端都通用的模块解决方案。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://ruiming.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Underscore 源码学习(七)</title>
    <link href="https://ruiming.github.io/2016/08/06/Underscore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0(%E4%B8%83)/"/>
    <id>https://ruiming.github.io/2016/08/06/Underscore源码学习(七)/</id>
    <published>2016-08-06T07:53:18.000Z</published>
    <updated>2016-08-06T13:03:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>Underscore 中间 flatten 相关的方法之前一直不是很理解，现在完全搞懂了，稍微说一下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> flatten = <span class="function"><span class="keyword">function</span>(<span class="params">input, shallow, strict, output</span>) </span>&#123;</div><div class="line">    output = output || [];</div><div class="line">    <span class="keyword">var</span> idx = output.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = getLength(input); i &lt; length; i++) &#123;</div><div class="line">        <span class="keyword">var</span> value = input[i];</div><div class="line">        <span class="comment">// 若value为数组，把里面东西去出来赋值给output</span></div><div class="line">        <span class="comment">// 否则直接赋值给output</span></div><div class="line">        <span class="comment">// isArrayLike的判断可以去掉，保留的原因是因为他用来判断value是否为数组很快，可以迅速筛选掉非数组</span></div><div class="line">        <span class="keyword">if</span> (isArrayLike(value) &amp;&amp; (_.isArray(value) || _.isArguments(value))) &#123;</div><div class="line">        <span class="comment">// Flatten current level of array or arguments object.</span></div><div class="line">        <span class="keyword">if</span> (shallow) &#123;</div><div class="line">            <span class="comment">// 如果给了shallow参数，只只遍历一层</span></div><div class="line">            <span class="keyword">var</span> j = <span class="number">0</span>, len = value.length;</div><div class="line">            <span class="keyword">while</span> (j &lt; len) output[idx++] = value[j++];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 一直遍历下去，如果是元素则按下面赋值，如果是数组则继续遍历</span></div><div class="line">            flatten(value, shallow, strict, output);</div><div class="line">            idx = output.length;</div><div class="line">        &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strict) &#123;</div><div class="line">        output[idx++] = value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> output;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个方法不难看懂，作用是将input平铺展开，如果 <code>shallow</code> 为 <code>true</code>，则只展开一层。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_.flatten([<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>], [[<span class="number">4</span>, [<span class="number">5</span>]]]])              <span class="comment">// [1, 2, 3, 4, 5]</span></div><div class="line">_.flatten([<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>], [[<span class="number">4</span>, [<span class="number">5</span>]]]], <span class="literal">true</span>)        <span class="comment">// [1, 2, 3, [4, [5]]]</span></div></pre></td></tr></table></figure></p>
<p>这里的 <code>strict</code> 参数就是之前一直卡住的原因，就是下面这个地方：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">_.without = restArgs(<span class="function"><span class="keyword">function</span>(<span class="params">array, otherArrays</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> _.difference(array, otherArrays);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">_.difference = restArgs(<span class="function"><span class="keyword">function</span>(<span class="params">array, rest</span>) </span>&#123;</div><div class="line">    rest = flatten(rest, <span class="literal">true</span>, <span class="literal">true</span>);</div><div class="line">    <span class="comment">// 遍历array，如果array中一个元素包含在rest中，则去掉该元素</span></div><div class="line">    <span class="keyword">return</span> _.filter(array, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> !_.contains(rest, value);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这是两个方法，那时候想 <code>without</code> 方法调用的时候, <code>otherArrays</code>是一个数组了，到 <code>difference</code> 方法的时候，这个数组去调用 <code>flatten</code> 方法的时候不是会出问题吗？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_.flatten([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="literal">true</span>, <span class="literal">true</span>)        <span class="comment">// []</span></div></pre></td></tr></table></figure></p>
<p>脑子里面就这样想…卡了好久，等我基本看了全部源码才会过来看才理解了。<br><code>difference</code> 方法的 <code>restArgs</code> 很重要，他们两个是各自独立的方法，但是 <code>without</code> 可以共用 <code>difference</code> 的逻辑。<br>上面那样子理解是有问题的，因为在 <code>without</code> 方法中 <code>otherArrays</code> 如果是[1, 2, 3]，到了 <code>flatten</code> 调用的时候因为 <code>restArgs</code> 的关系他变成了 [[1, 2, 3]]，调用最后返回结果[1, 2, 3]。然后我就纳闷了，加了一层又解除这是何解…<br>不过抛开 <code>without</code> 方法去看 <code>difference</code> 方法就能理解了。<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">_.without([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line"><span class="comment">// 1, 2, 3通过restArgs变为[1, 2, 3]，传入difference方法</span></div><div class="line"><span class="comment">// [1, 2, 3]通过restArgs变为[[1, 2, 3]]，传入flatten方法</span></div><div class="line"><span class="comment">// 返回[1, 2, 3]，剩下的可以看懂了不解释</span></div><div class="line"><span class="comment">// 之所以shallow和strict都为true，是因为不需要两个数组即使内容一样他们也是不想等的，</span></div><div class="line"><span class="comment">// 不需要进行处理，所以没必要展开</span></div><div class="line">_.difference([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>]);</div><div class="line"><span class="comment">// [1, 2], [3]通过restArgs变为[1, 2, 3]，传入difference方法，其余同</span></div></pre></td></tr></table></figure></p>
<p>所以其实 <code>difference</code> 方法的 <code>restArgs</code> 虽然对与 <code>without</code> 方法中的调用是多余的，但是作为一个独立的方法，他还是有必要的。<br>上面注释应该说的很清楚了，完。</p>
<p>其实只是我自己没看清楚而已，也不难。这个地方的很多方法比如 <code>union</code>, <code>intersection</code>等等都是集合的相关操作。比如 <code>difference</code> 就是差集，<code>union</code> 就是并集，而<code>intersection</code> 就是交集。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Underscore 中间 flatten 相关的方法之前一直不是很理解，现在完全搞懂了，稍微说一下。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; flatten = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;input, shallow, strict, output&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    output = output || [];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; idx = output.length;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, length = getLength(input); i &amp;lt; length; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; value = input[i];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 若value为数组，把里面东西去出来赋值给output&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 否则直接赋值给output&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// isArrayLike的判断可以去掉，保留的原因是因为他用来判断value是否为数组很快，可以迅速筛选掉非数组&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isArrayLike(value) &amp;amp;&amp;amp; (_.isArray(value) || _.isArguments(value))) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Flatten current level of array or arguments object.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (shallow) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 如果给了shallow参数，只只遍历一层&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, len = value.length;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (j &amp;lt; len) output[idx++] = value[j++];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 一直遍历下去，如果是元素则按下面赋值，如果是数组则继续遍历&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            flatten(value, shallow, strict, output);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            idx = output.length;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!strict) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        output[idx++] = value;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; output;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个方法不难看懂，作用是将input平铺展开，如果 &lt;code&gt;shallow&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt;，则只展开一层。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;_.flatten([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;], [[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, [&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]]]])              &lt;span class=&quot;comment&quot;&gt;// [1, 2, 3, 4, 5]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;_.flatten([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;], [[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, [&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]]]], &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;)        &lt;span class=&quot;comment&quot;&gt;// [1, 2, 3, [4, [5]]]&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里的 &lt;code&gt;strict&lt;/code&gt; 参数就是之前一直卡住的原因，就是下面这个地方：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;_.without = restArgs(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;array, otherArrays&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _.difference(array, otherArrays);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;_.difference = restArgs(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;array, rest&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    rest = flatten(rest, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 遍历array，如果array中一个元素包含在rest中，则去掉该元素&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _.filter(array, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;value&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; !_.contains(rest, value);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这是两个方法，那时候想 &lt;code&gt;without&lt;/code&gt; 方法调用的时候, &lt;code&gt;otherArrays&lt;/code&gt;是一个数组了，到 &lt;code&gt;difference&lt;/code&gt; 方法的时候，这个数组去调用 &lt;code&gt;flatten&lt;/code&gt; 方法的时候不是会出问题吗？&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;_.flatten([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;], &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;)        &lt;span class=&quot;comment&quot;&gt;// []&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;脑子里面就这样想…卡了好久，等我基本看了全部源码才会过来看才理解了。&lt;br&gt;&lt;code&gt;difference&lt;/code&gt; 方法的 &lt;code&gt;restArgs&lt;/code&gt; 很重要，他们两个是各自独立的方法，但是 &lt;code&gt;without&lt;/code&gt; 可以共用 &lt;code&gt;difference&lt;/code&gt; 的逻辑。&lt;br&gt;上面那样子理解是有问题的，因为在 &lt;code&gt;without&lt;/code&gt; 方法中 &lt;code&gt;otherArrays&lt;/code&gt; 如果是[1, 2, 3]，到了 &lt;code&gt;flatten&lt;/code&gt; 调用的时候因为 &lt;code&gt;restArgs&lt;/code&gt; 的关系他变成了 [[1, 2, 3]]，调用最后返回结果[1, 2, 3]。然后我就纳闷了，加了一层又解除这是何解…&lt;br&gt;不过抛开 &lt;code&gt;without&lt;/code&gt; 方法去看 &lt;code&gt;difference&lt;/code&gt; 方法就能理解了。&lt;br&gt;
    
    </summary>
    
      <category term="Underscore" scheme="https://ruiming.github.io/categories/Underscore/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="Underscore" scheme="https://ruiming.github.io/tags/Underscore/"/>
    
  </entry>
  
  <entry>
    <title>Underscore 源码学习(六)</title>
    <link href="https://ruiming.github.io/2016/08/05/Underscore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0(%E5%85%AD)/"/>
    <id>https://ruiming.github.io/2016/08/05/Underscore源码学习(六)/</id>
    <published>2016-08-05T05:59:06.000Z</published>
    <updated>2016-08-05T06:07:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于 Underscore 的 mixin 方法。<br>首先先看个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Panel</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  consoe.log(<span class="keyword">this</span>, <span class="keyword">this</span> <span class="keyword">instanceof</span> Panel);</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> Panel) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Panel();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">a = Panel();        <span class="comment">// Window   false</span></div><div class="line">b = <span class="keyword">new</span> Panel();    <span class="comment">// Panel&#123;&#125;  true</span></div></pre></td></tr></table></figure></p>
<p>当函数作为构造器使用时，函数内的 <code>this</code> 执行被新建的对象。当函数被调用时，函数内的 <code>this</code> 则为被调用的对象，在这里是 <code>Window</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _ = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> _) <span class="keyword">return</span> obj;</div><div class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> _)) <span class="keyword">return</span> <span class="keyword">new</span> _(obj);</div><div class="line">  <span class="keyword">this</span>._wrapped = obj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>同样的，如果我们使用下面方法调用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> under = _();</div></pre></td></tr></table></figure></p>
<p>第二个条件成立，所以新建一个 <code>_</code> 对象后返回，注意这里是再次调用这个函数。<br>如果我们这样调用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> under = <span class="keyword">new</span> _();</div></pre></td></tr></table></figure></p>
<p>就好像上面第二次调用一样，这时候就构造了 <code>under</code> 这个对象，如果传入了参数 <code>obj</code>，则把 <code>obj</code> 存入 <code>under</code> 这个对象的 <code>_wrapped</code> 属性中。<br><code>Underscore</code> 提供了一个 OO 的调用方法，即:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> chainResult = <span class="function"><span class="keyword">function</span>(<span class="params">instance, obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> instance._chain ? _(obj).chain() : obj;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">_.mixin = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="comment">// 遍历obj中的函数</span></div><div class="line">    _.each(_.functions(obj), <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="comment">// 避免原型链查找，提升性能</span></div><div class="line">        <span class="keyword">var</span> func = _[name] = obj[name];</div><div class="line">        _.prototype[name] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">// 把wrapped作为数组第一个参数(context)，其余传参push到这个数组中</span></div><div class="line">            <span class="keyword">var</span> args = [<span class="keyword">this</span>._wrapped];</div><div class="line">            push.apply(args, <span class="built_in">arguments</span>);</div><div class="line">            <span class="comment">// 如果this是一个_实例，则使用func调用的结果来新建_实例后返回以供继续链式调用</span></div><div class="line">            <span class="comment">// 如果this不是一个_实例，则直接返回func调用的结果</span></div><div class="line">            <span class="keyword">return</span> chainResult(<span class="keyword">this</span>, func.apply(_, args));</div><div class="line">        &#125;;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> _;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 把Underscore对象mixin化，这样就可以直接在_上调用方法</span></div><div class="line">_.mixin(_);</div></pre></td></tr></table></figure></p>
<p>当然我们还可以把自己写的方法通过 <code>mixin</code> 加入到 <code>Underscore</code> 对象中。<br><a id="more"></a><br>在这段代码后面还把原生的一些操作方法也添加到这个 <code>_</code> 上面，这样我们就可以直接在 <code>_</code> 上调用这些方法。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Add all mutator Array functions to the wrapper.</span></div><div class="line">_.each([<span class="string">'pop'</span>, <span class="string">'push'</span>, <span class="string">'reverse'</span>, <span class="string">'shift'</span>, <span class="string">'sort'</span>, <span class="string">'splice'</span>, <span class="string">'unshift'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> method = ArrayProto[name];</div><div class="line">    _.prototype[name] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> obj = <span class="keyword">this</span>._wrapped;</div><div class="line">        method.apply(obj, <span class="built_in">arguments</span>);</div><div class="line">        <span class="keyword">if</span> ((name === <span class="string">'shift'</span> || name === <span class="string">'splice'</span>) &amp;&amp; obj.length === <span class="number">0</span>) <span class="keyword">delete</span> obj[<span class="number">0</span>];</div><div class="line">        <span class="keyword">return</span> chainResult(<span class="keyword">this</span>, obj);</div><div class="line">    &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>上面这些方法并不是 Underscore 新建的，不存在于 Underscore 对象的原型链上，所以我们要把他们加进去。和上面 <code>mixin</code> 方法类似，下面这段代码是为了兼容 IE 而采取的操作：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ((name === <span class="string">'shift'</span> || name === <span class="string">'splice'</span>) &amp;&amp; obj.length === <span class="number">0</span>) <span class="keyword">delete</span> obj[<span class="number">0</span>];</div></pre></td></tr></table></figure></p>
<blockquote>
<p>jdalton commented on 6 Dec 2011<br>IE bugs with splice() and shift(), failing to remove the 0 indexed value, when using an array-like-object with _(…).<br>IE compatibility mode and IE &lt; 9 have buggy Array shift() and splice() functions that fail to remove the last element, object[0], of array-like-objects even though the length property is set to 0.</p>
</blockquote>
<p>通过上面这些方法把 Underscore 转化为可面向对象编程，调用更加优雅，我们可以有以下两种使用方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_.map([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123; <span class="keyword">return</span> n * <span class="number">2</span>; &#125;);</div><div class="line">_([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).map(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123; <span class="keyword">return</span> n * <span class="number">2</span>; &#125;);</div></pre></td></tr></table></figure></p>
<p>至于选择哪一种就看你的喜好了～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 Underscore 的 mixin 方法。&lt;br&gt;首先先看个例子：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Panel&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  consoe.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; Panel);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; Panel) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Panel();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;a = Panel();        &lt;span class=&quot;comment&quot;&gt;// Window   false&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;b = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Panel();    &lt;span class=&quot;comment&quot;&gt;// Panel&amp;#123;&amp;#125;  true&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当函数作为构造器使用时，函数内的 &lt;code&gt;this&lt;/code&gt; 执行被新建的对象。当函数被调用时，函数内的 &lt;code&gt;this&lt;/code&gt; 则为被调用的对象，在这里是 &lt;code&gt;Window&lt;/code&gt;。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; _ = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (obj &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; _) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; obj;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; _)) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; _(obj);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._wrapped = obj;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;同样的，如果我们使用下面方法调用：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; under = _();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;第二个条件成立，所以新建一个 &lt;code&gt;_&lt;/code&gt; 对象后返回，注意这里是再次调用这个函数。&lt;br&gt;如果我们这样调用：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; under = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; _();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;就好像上面第二次调用一样，这时候就构造了 &lt;code&gt;under&lt;/code&gt; 这个对象，如果传入了参数 &lt;code&gt;obj&lt;/code&gt;，则把 &lt;code&gt;obj&lt;/code&gt; 存入 &lt;code&gt;under&lt;/code&gt; 这个对象的 &lt;code&gt;_wrapped&lt;/code&gt; 属性中。&lt;br&gt;&lt;code&gt;Underscore&lt;/code&gt; 提供了一个 OO 的调用方法，即:&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; chainResult = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;instance, obj&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance._chain ? _(obj).chain() : obj;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;_.mixin = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 遍历obj中的函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    _.each(_.functions(obj), &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 避免原型链查找，提升性能&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; func = _[name] = obj[name];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        _.prototype[name] = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 把wrapped作为数组第一个参数(context)，其余传参push到这个数组中&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; args = [&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._wrapped];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            push.apply(args, &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 如果this是一个_实例，则使用func调用的结果来新建_实例后返回以供继续链式调用&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 如果this不是一个_实例，则直接返回func调用的结果&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; chainResult(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, func.apply(_, args));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 把Underscore对象mixin化，这样就可以直接在_上调用方法&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;_.mixin(_);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当然我们还可以把自己写的方法通过 &lt;code&gt;mixin&lt;/code&gt; 加入到 &lt;code&gt;Underscore&lt;/code&gt; 对象中。&lt;br&gt;
    
    </summary>
    
      <category term="Underscore" scheme="https://ruiming.github.io/categories/Underscore/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="Underscore" scheme="https://ruiming.github.io/tags/Underscore/"/>
    
  </entry>
  
  <entry>
    <title>Underscore 源码学习(五)</title>
    <link href="https://ruiming.github.io/2016/08/04/Underscore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0(%E4%BA%94)/"/>
    <id>https://ruiming.github.io/2016/08/04/Underscore源码学习(五)/</id>
    <published>2016-08-04T07:18:48.000Z</published>
    <updated>2016-08-04T11:41:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>Underscore 的函数大部分还是挺好理解的，感觉过一遍就行了，不过今天看到两个函数感觉还是挺有意思的，并且也挺常用。这两个函数就是 throttle 和 debounce。</p>
<h2 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">_.throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, options</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> timeout, context, args, result;</div><div class="line">  <span class="keyword">var</span> previous = <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span> (!options) options = &#123;&#125;;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 更改previous即上一次执行时间为当前时间</span></div><div class="line">    previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : _.now();</div><div class="line">    timeout = <span class="literal">null</span>;</div><div class="line">    result = func.apply(context, args);</div><div class="line">    <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> now = _.now();</div><div class="line">    <span class="comment">// 如果leading为false时禁用第一次首先执行，previous等于now（效果同已经执行过一次，所以第一次被禁用）</span></div><div class="line">    <span class="comment">// 这个if语句只在第一次执行该函数的时候有效</span></div><div class="line">    <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</div><div class="line">    <span class="keyword">var</span> remaining = wait - (now - previous);</div><div class="line">    context = <span class="keyword">this</span>;</div><div class="line">    args = <span class="built_in">arguments</span>;</div><div class="line">    <span class="comment">// 超时处理和未到时的处理</span></div><div class="line">    <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</div><div class="line">      <span class="comment">// timeout不为null时清除掉并设置为null</span></div><div class="line">      <span class="keyword">if</span> (timeout) &#123;</div><div class="line">        clearTimeout(timeout);</div><div class="line">        timeout = <span class="literal">null</span>;</div><div class="line">      &#125;</div><div class="line">      previous = now;</div><div class="line">      <span class="comment">// 立即调用</span></div><div class="line">      result = func.apply(context, args);</div><div class="line">      <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;    <span class="comment">// 如果没有禁用最后一次执行</span></div><div class="line">      timeout = setTimeout(later, remaining);               <span class="comment">// remaining毫秒后执行later</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 返回调用的结果</span></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  throttled.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    clearTimeout(timeout);</div><div class="line">    previous = <span class="number">0</span>;</div><div class="line">    timeout = context = args = <span class="literal">null</span>;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> throttled;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其实一步步去理解也不难，就不细说这个方法了。这个方法有可选项设置，分别为 {leading: false} 和 {trailing: false}。</p>
<p>所以一般有四类情况：</p>
<ul>
<li>默认情况<br>第一次调用时立即响应，之后每个周期内最多执行一次，周期内触发会产生定时执行使在上一次执行时间 <code>preview</code> 周期时间后再次执行。</li>
<li>设置 <code>leading</code> 为 <code>false</code><br>同默认情况区别在于第一次调用不会立即执行而是等待周期时间后再次执行，如果在周期时间内触发，一样等待上一次执行时间 <code>preview</code> 周期时间后再执行。</li>
<li>设置 <code>trailing</code> 为 <code>false</code><br>最后周期内最多执行一次，但在周期时间内调用不会触发 <code>timeout</code>，只能在上一次 <code>timeout</code> 失效后调用才能生效并且此时调用将立即执行。</li>
<li>设置 <code>leading</code> 和 <code>trailing</code> 为 <code>false</code><br>如果同时还设置 <code>leading</code> 为 <code>false</code> 的话，那么第一次调用不会立即执行而是等待周期时间后才执行，在这段时间内调用都不会有效果。</li>
</ul>
<a id="more"></a>
<p>比如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = _.throttle(updatePosition, <span class="number">100</span>);</div><div class="line">$(<span class="built_in">window</span>).scroll(func);</div></pre></td></tr></table></figure></p>
<p>由于 scroll 过程时, <code>func</code> 函数的调用是很密集的，我们不能每次调用都去执行，可以通过设置 throttle 来达到节流阀的作用。<code>leading</code> 和 <code>trailing</code> 只是实现上细微的不同而已。</p>
<p>throll 主要应用在鼠标移动，mousemove 事件，DOM 元素动态定位，window 对象的 resize 和 scroll 等事件。这些事件触发频率高，但又要尽可能进行响应。</p>
<h2 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">_.debounce = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> timeout, result;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params">context, args</span>) </span>&#123;</div><div class="line">    timeout = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">if</span> (args) result = func.apply(context, args);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> debounced = restArgs(<span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</div><div class="line">    <span class="comment">// 再次调用且上次还未执行，则清除上次的timeout</span></div><div class="line">    <span class="comment">// 只是timeout事件不再执行，但timeout依旧存在</span></div><div class="line">    <span class="keyword">if</span> (timeout) clearTimeout(timeout);</div><div class="line">    <span class="comment">// 如果immediate为true</span></div><div class="line">    <span class="keyword">if</span> (immediate) &#123;</div><div class="line">      <span class="comment">// 如果timeout为null，则立即调用函数</span></div><div class="line">      <span class="comment">// 如果timeout不为null，则callNow为false，函数不执行</span></div><div class="line">      <span class="keyword">var</span> callNow = !timeout;</div><div class="line">      timeout = setTimeout(later, wait);</div><div class="line">      <span class="keyword">if</span> (callNow) result = func.apply(<span class="keyword">this</span>, args);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 延迟later执行，如果这个还没到时间再来一次，则新的会覆盖上一次的</span></div><div class="line">      timeout = _.delay(later, wait, <span class="keyword">this</span>, args);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  debounced.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    clearTimeout(timeout);</div><div class="line">    timeout = <span class="literal">null</span>;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> debounced;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数就要比上面那个好理解一点，说明下这个函数：</p>
<ul>
<li><p>如果 <code>immediate</code> 为 <code>true</code>，周期 100ms</p>
<ul>
<li>0   =&gt; 立即执行，设置 <code>timeout</code></li>
<li>50  =&gt; 重新设置 <code>timeout</code>，不执行</li>
<li>100 =&gt; 重新设置 <code>timeout</code>，不执行</li>
<li>200 =&gt; <code>timeout</code> 到时，执行函数</li>
</ul>
</li>
<li><p>如果 <code>immediate</code> 为 <code>false</code>, 周期 100ms</p>
<ul>
<li>0   =&gt; 设置 <code>timeout</code>，不执行</li>
<li>100 =&gt; <code>timeout</code> 到时，执行函数</li>
<li>120 =&gt; 设置 <code>timeout</code>，不执行</li>
<li>180 =&gt; 重新设置 <code>timeout</code>，不执行</li>
<li>280 =&gt; <code>timeout</code> 到时，执行函数</li>
</ul>
</li>
</ul>
<p>其实 <code>timeout</code> 就变成一个控制两次事件触发间隔用的，并且和上面的 throttle 不同，<code>timeout</code> 会被重新设置。</p>
<p>debounce 主要应用在文本输入 keydown 事件，keyup 事件，例如做 autocomplete。</p>
<p>结合两个的应用细细体味下他们差别。如果想自己体验下差别，<a href="http://jsfiddle.net/missinglink/19e2r2we/" target="_blank" rel="external">传送门</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Underscore 的函数大部分还是挺好理解的，感觉过一遍就行了，不过今天看到两个函数感觉还是挺有意思的，并且也挺常用。这两个函数就是 throttle 和 debounce。&lt;/p&gt;
&lt;h2 id=&quot;throttle&quot;&gt;&lt;a href=&quot;#throttle&quot; class=&quot;headerlink&quot; title=&quot;throttle&quot;&gt;&lt;/a&gt;throttle&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;_.throttle = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;func, wait, options&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; timeout, context, args, result;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; previous = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!options) options = &amp;#123;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; later = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 更改previous即上一次执行时间为当前时间&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    previous = options.leading === &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt; ? &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; : _.now();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    timeout = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    result = func.apply(context, args);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!timeout) context = args = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; throttled = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; now = _.now();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果leading为false时禁用第一次首先执行，previous等于now（效果同已经执行过一次，所以第一次被禁用）&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 这个if语句只在第一次执行该函数的时候有效&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!previous &amp;amp;&amp;amp; options.leading === &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;) previous = now;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; remaining = wait - (now - previous);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    context = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    args = &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 超时处理和未到时的处理&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (remaining &amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; || remaining &amp;gt; wait) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// timeout不为null时清除掉并设置为null&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (timeout) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        clearTimeout(timeout);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        timeout = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      previous = now;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 立即调用&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      result = func.apply(context, args);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!timeout) context = args = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!timeout &amp;amp;&amp;amp; options.trailing !== &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;) &amp;#123;    &lt;span class=&quot;comment&quot;&gt;// 如果没有禁用最后一次执行&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      timeout = setTimeout(later, remaining);               &lt;span class=&quot;comment&quot;&gt;// remaining毫秒后执行later&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 返回调用的结果&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  throttled.cancel = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    clearTimeout(timeout);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    previous = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    timeout = context = args = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; throttled;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其实一步步去理解也不难，就不细说这个方法了。这个方法有可选项设置，分别为 {leading: false} 和 {trailing: false}。&lt;/p&gt;
&lt;p&gt;所以一般有四类情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认情况&lt;br&gt;第一次调用时立即响应，之后每个周期内最多执行一次，周期内触发会产生定时执行使在上一次执行时间 &lt;code&gt;preview&lt;/code&gt; 周期时间后再次执行。&lt;/li&gt;
&lt;li&gt;设置 &lt;code&gt;leading&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt;&lt;br&gt;同默认情况区别在于第一次调用不会立即执行而是等待周期时间后再次执行，如果在周期时间内触发，一样等待上一次执行时间 &lt;code&gt;preview&lt;/code&gt; 周期时间后再执行。&lt;/li&gt;
&lt;li&gt;设置 &lt;code&gt;trailing&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt;&lt;br&gt;最后周期内最多执行一次，但在周期时间内调用不会触发 &lt;code&gt;timeout&lt;/code&gt;，只能在上一次 &lt;code&gt;timeout&lt;/code&gt; 失效后调用才能生效并且此时调用将立即执行。&lt;/li&gt;
&lt;li&gt;设置 &lt;code&gt;leading&lt;/code&gt; 和 &lt;code&gt;trailing&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt;&lt;br&gt;如果同时还设置 &lt;code&gt;leading&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 的话，那么第一次调用不会立即执行而是等待周期时间后才执行，在这段时间内调用都不会有效果。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Underscore" scheme="https://ruiming.github.io/categories/Underscore/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="Underscore" scheme="https://ruiming.github.io/tags/Underscore/"/>
    
  </entry>
  
  <entry>
    <title>谈谈 React 和 Redux</title>
    <link href="https://ruiming.github.io/2016/08/01/%E8%B0%88%E8%B0%88React%E5%92%8CRedux/"/>
    <id>https://ruiming.github.io/2016/08/01/谈谈React和Redux/</id>
    <published>2016-08-01T07:53:32.000Z</published>
    <updated>2016-08-04T08:33:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚回到家的时候学习了 React 和 Redux，现在才想来总结一下，不知道会不会忘的差不多了…本来是想写一个问卷发布系统的，使用 React 和 Redux 已经完成了基础的几个功能，但是那个代码量…用 Angular 写简直轻轻松松的好吧…然后就去重构项目还有现在学的 Underscore 去了。是时候重新回顾下了。<br>此处主要讲的是 Redux 。</p>
<h3 id="关于-Redux"><a href="#关于-Redux" class="headerlink" title="关于 Redux"></a>关于 Redux</h3><blockquote>
<p>redux 是facebook 提出的 flux 架构的一种优秀实现；而且不局限于为 react 提供数据状态处理。它是零依赖的，可以配合其他任何框架或者类库一起使用。要想配合 react，还得引入 react-redux。</p>
</blockquote>
<h3 id="关于-Flux"><a href="#关于-Flux" class="headerlink" title="关于 Flux"></a>关于 Flux</h3><p>那什么是 Flux 呢？见下图<br><img src="/2016/08/01/谈谈React和Redux/flux-overview.png" alt="flux-overview.png" title="flux-overview.png"><br>Flux 可以分为四个部分：</p>
<ul>
<li>View: 视图层</li>
<li>Action: 视图层触发的动作</li>
<li>Dispatcher: 派发器，用来接受 Actions, 执行回调函数</li>
<li>Store：数据层，用来存放应用的状态，其变更会触发 View 层更新</li>
</ul>
<p>Flux 的最大特点就是单向流动，他的过程大概如下：</p>
<ol>
<li>用户访问 View ，触发了动作 Action</li>
<li>Dispatcher 收到 Action ，根据 Action 类别进行相应的处理，处理结束后要求 Store 更新</li>
<li>Store 进行更新，通知 View 层刷新</li>
<li>View 层收到通知更新页面</li>
</ol>
<p>额，其实我没有用 Flux，不敢讲太多了，简单的说就是一种单项数据流动的解决方案吧。我是直接学 Redux，对 Flux 也就大概了解这么多了。</p>
<h3 id="Redux-和-Flux"><a href="#Redux-和-Flux" class="headerlink" title="Redux 和 Flux"></a>Redux 和 Flux</h3><p>Redux 是 Flux 的一种实现，但他们又有所不同，在 Flux 中，Store 可以有多个，但 Redux 有且只能有一个 Store，Flux 中存在 Dispatcher，在 Redux 则没有这个，而是用 reducer 代替了。不多说了，直接往下说 Redux 吧，我快扯不下去 Flux 了=.=</p>
<h3 id="理解Redux"><a href="#理解Redux" class="headerlink" title="理解Redux"></a>理解Redux</h3><p>Redux 由四部分组成：</p>
<ul>
<li>Action</li>
<li>Reducer</li>
<li>Store</li>
<li>Views</li>
</ul>
<p>我们结合具体的应用场景来看</p>
<h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>先从 Action 说起，一个 Action 是一个普通的对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> SET_PAPER_TITLE = <span class="string">'SET_PAPER_TITLE'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_QUESTION = <span class="string">'ADD_QUESTION'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> REMOVE_QUESTION = <span class="string">'REMOVE_QUESTION'</span>;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setPaperTitle</span>(<span class="params">newTitle</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        type: SET_PAPER_TITLE,</div><div class="line">        value: newTitle</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addQuestion</span>(<span class="params">type</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        type: ADD_QUESTION,</div><div class="line">        questionType: type</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">removeQuestion</span>(<span class="params">questionId</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        type: REMOVE_QUESTION,</div><div class="line">        questionId: questionId</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>type 属性是必须的，表示动作类别，其他的参数可以自定。<br>我们先不用管 Action 有什么用，后面会提到。<br><a id="more"></a></p>
<h4 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h4><p>在 Action 这一层中，可以筛选掉脏数据，多余的参数不会传入，真正处理数据是在 Reducer 中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; SET_PAPER_TITLE, ADD_QUESTION, REMOVE_QUESTION, ADD_OPTION, REMOVE_OPTION, SET_QUESTION_TITLE, SET_OPTION_TITLE &#125; <span class="keyword">from</span> <span class="string">'../action/action'</span></div><div class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">paperReducer</span>(<span class="params">state=[], action</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span>(action.type) &#123;</div><div class="line">        <span class="keyword">case</span> SET_PAPER_TITLE:</div><div class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</div><div class="line">                title: action.value</div><div class="line">            &#125;);</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">questionsReducer</span>(<span class="params">state=[], action</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span>(action.type) &#123;</div><div class="line">        <span class="keyword">case</span> ADD_QUESTION:</div><div class="line">            <span class="keyword">return</span> [</div><div class="line">                ...state,</div><div class="line">                &#123;</div><div class="line">                    title: <span class="string">''</span>,</div><div class="line">                    type: action.questionType,</div><div class="line">                    content: [<span class="string">''</span>,<span class="string">''</span>,<span class="string">''</span>,<span class="string">''</span>]</div><div class="line">                &#125;</div><div class="line">            ];</div><div class="line">        <span class="keyword">case</span> REMOVE_QUESTION:</div><div class="line">            <span class="keyword">return</span> [</div><div class="line">                ...state.slice(<span class="number">0</span>, action.questionId),</div><div class="line">                ...state.slice(action.questionId+<span class="number">1</span>)</div><div class="line">            ];</div><div class="line">        <span class="keyword">case</span> ADD_OPTION:</div><div class="line">        <span class="keyword">case</span> REMOVE_OPTION:</div><div class="line">        <span class="keyword">case</span> SET_QUESTION_TITLE:</div><div class="line">        <span class="keyword">case</span> SET_OPTION_TITLE:</div><div class="line">            <span class="keyword">return</span> [</div><div class="line">                ...state.slice(<span class="number">0</span>, action.questionId),</div><div class="line">                questionReducer(state[action.questionId], action),</div><div class="line">                ...state.slice(action.questionId+<span class="number">1</span>)</div><div class="line">            ];</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> paperApp = combineReducers(&#123;</div><div class="line">    paper: paperReducer,</div><div class="line">    questions: questionsReducer</div><div class="line">&#125;);</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> paperApp;</div></pre></td></tr></table></figure></p>
<p>这里列了很多 Action，但在上面的 Action 部分我只提了两个，其他的其实都一样的，就是参数可能有些区别而已。<br>这里就要好好说一笔了，reducer 之所以叫 reducer，一个原因就是他很类似 JavaScript 中数组的 reduce 方法，接收两个参数，一个是当前状态，一个是处理方法。<br>但在 Redux 中，不要直接修改当前状态即 <code>state</code>，而应该返回一个新的 <code>state</code>，而这样做的其中一个好处就是可以实现时间旅行的功能，即可以回溯到任意版本的数据，并且对于判断 <code>state</code> 是否发生修改也很重要，如果是在原引用上修改我们得用 <code>deepEqual</code> 深度遍历来对比值，而如果返回了一个新的对象则可以直接使用 <code>===</code> 来判断两个数据是否一致，不一致则触发更改。reducer 方法应该都能看懂，接下来是 combineReducers 这个。<br>我上面其实涉及到三个 reducer 了，分别是</p>
<ul>
<li>paperReducer</li>
<li>questionsReducer</li>
<li>questionReducer</li>
</ul>
<p>但为了减少空间，我没有把 <code>questionReducer</code> 写出来。其实注意看从29行到32行的四个 Action，我都传入 <code>state</code> 中的部分数据给了 <code>questionReducer</code> 去做处理。因为这些都是涉及一个问题的修改的，所以就单独列出来。这样就不致于一个 reducer 写太多东西。<br>实质上还是两个 reducer 而已，这里的 combineReducers 就是把这两个 reducer 合并在一起。这两个 reducer 一个是处理问卷信息如问卷标题，一个是处理问卷的问题比如新建删除问题，问题修改这些。</p>
<h4 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h4><p>使用 combineReducers 就要求我们 Store 的设计合理，因为 Store 和 reducer 是要对应的，<code>questionsReducer</code> 只要处理问题，而 <code>paperReducer</code> 只要处理问卷本身，所以也就不需要往 <code>paperReducer</code> 传入完整的 <code>state</code> 信息。我们看下 Store。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></div><div class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span></div><div class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></div><div class="line"><span class="keyword">import</span> paperApp <span class="keyword">from</span> <span class="string">'./reducer/reducer'</span></div><div class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./containers/App'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> initialState = &#123;</div><div class="line">    paper: &#123;</div><div class="line">        title: <span class="string">'asd'</span>,</div><div class="line">        time: <span class="string">"2016-7-19"</span>,</div><div class="line">        author: <span class="string">"Ruiming"</span>,</div><div class="line">    &#125;,</div><div class="line">    questions: [&#123;</div><div class="line">        title: <span class="string">''</span>,</div><div class="line">        type: <span class="string">'radio'</span>,</div><div class="line">        content: [<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>]</div><div class="line">    &#125;, &#123;</div><div class="line">        title: <span class="string">''</span>,</div><div class="line">        type: <span class="string">'checkbox'</span>,</div><div class="line">        content: [<span class="string">''</span>,<span class="string">''</span>,<span class="string">''</span>,<span class="string">''</span>]</div><div class="line">    &#125;]</div><div class="line">&#125;;</div><div class="line"><span class="keyword">let</span> store = createStore(paperApp, initialState);</div><div class="line"><span class="keyword">let</span> rootElement = <span class="built_in">document</span>.getElementById(<span class="string">'index'</span>);</div><div class="line">render (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">App</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span>,</div><div class="line">    rootElement</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>我们初始一个数据 initialState，调用 createStore 方法需要传入两个参数，分别就是我们上面 combineReducers 后的<code>paperApp</code>和我们的数据。在初始数据中，有两个对象分别是<code>paper</code>和<code>questions</code>，这就刚好和 combineReducers 中的<code>paper</code>和<code>questions</code>对应，从而实现传递部分<code>state</code>。<br>下面的 render 部分是就是渲染部分了， Provider 是 react-redux 提供的一个容器，将 Store 作为属性传递给该容器。</p>
<h4 id="Views"><a href="#Views" class="headerlink" title="Views"></a>Views</h4><p>我们看下 App 的内容<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component, PropTypes &#125; <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></div><div class="line"><span class="keyword">import</span> &#123; addQuestion, addOption, setPaperTitle, setQuestionTitle, setOptionTitle, removeQuestion, removeOption &#125; <span class="keyword">from</span> <span class="string">'../action/action'</span></div><div class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'../components/Header'</span></div><div class="line"><span class="keyword">import</span> NewQuestionBar <span class="keyword">from</span> <span class="string">'../components/NewQuestionBar'</span></div><div class="line"><span class="keyword">import</span> OptionsBar <span class="keyword">from</span> <span class="string">'../components/OptionsBar'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">const</span> &#123; dispatch, title, questions &#125; = <span class="keyword">this</span>.props;</div><div class="line">        <span class="keyword">return</span> &lt;div ref="paper"&gt;</div><div class="line">            &lt;Header title=&#123;title&#125;</div><div class="line">                    setPaperTitle=&#123;(title) =&gt; dispatch(setPaperTitle(title))&#125;</div><div class="line">                /&gt;</div><div class="line">            &lt;NewQuestionBar addQuestion=&#123;(type) =&gt; dispatch(addQuestion(type))&#125; /&gt;</div><div class="line">            &lt;section className="paper"&gt;</div><div class="line">                &lt;ul className="paper-list"&gt;</div><div class="line">                    &#123;questions.map(function(question, i) &#123;</div><div class="line">                        return &lt;OptionsBar content=&#123;question.content&#125;</div><div class="line">                                           addQuestion=&#123;() =&gt; dispatch(addQuestion())&#125;</div><div class="line">                                           addOption=&#123;(questionId) =&gt; dispatch(addOption(questionId))&#125;</div><div class="line">                        /&gt;</div><div class="line">                    &#125;.bind(this))</div><div class="line">                    &#125;</div><div class="line">                &lt;/ul&gt;</div><div class="line">            &lt;/section&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function select(state) &#123;</div><div class="line">    return &#123;</div><div class="line">        paper: state.paper,</div><div class="line">        questions: state.questions</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default connect(select)(App);</div></pre></td></tr></table></figure></p>
<p>上面我去掉了很多部分，只保留了 <code>addQuestion</code> 和 <code>addOption</code> 这两个，我们看下这两个就好了。其实这部分的写法就是 React 写法而已，只是多了个 dispatch 方法。注意下最后的 connect 方法，他的作用是：</p>
<ul>
<li>把所需要的 <code>state</code> 属性挂载到组件的 <code>props</code> 上。</li>
<li>为组件的 <code>props</code> 添加 <code>dispatch</code> 方法。</li>
</ul>
<h3 id="Redux-运行过程"><a href="#Redux-运行过程" class="headerlink" title="Redux 运行过程"></a>Redux 运行过程</h3><p>介绍完了 Redux 的四个部分，接下来就要说下这个运行的流程了。这才是理解 Redux 的关键。</p>
<ol>
<li>用户在视图触发 dispatch 事件</li>
<li>Redux 响应用户操作生成 action </li>
<li>action 传到 store 层，可以使用中间件进行一些处理</li>
<li>action 传 <code>state</code> 和 <code>action</code> 给 reducer 处理</li>
<li>reducer 返回一个新的 <code>state</code></li>
<li>store 读取 reducer 返回的内容，设置新的状态</li>
</ol>
<p>大致就是以上过程，action 是唯一可以改变状态的途径，不仅包括用户的触发，也可以是来自服务器的推送，action 进行预处理后会传到 store，由 store 发送动作给 reducer，带上当前状态和当前动作，reducer 根据动作的 type 来进行不同的处理。注意 action 和 reducer 都是纯函数。</p>
<p>Redux 大致就是这么一回事，我们可以看到所有数据都来自一个对象 Store，这样就方便了调试测试，可以把 Store 就想象成一个数据库。state 只读，只能通过 action 改变，并且必须保证 reducer 是纯函数，所谓纯函数就是相同参数传入无数次他们都返回相同的东西，其实就是内部没有使用外部变量，外部变量总是伴随着不确定性。</p>
<h3 id="React-和-Angular"><a href="#React-和-Angular" class="headerlink" title="React 和 Angular"></a>React 和 Angular</h3><p>React 现在很博人眼球，虚拟DOM提升了页面渲染性能，并且衍生的 React Native 也非常有诱惑力，单向数据流动虽然带来了清晰的逻辑和更高的性能，但降低了开发效率。另外，使用 React 开发的应用天然组件化，也方便了后期的维护。</p>
<p>Angular 是一个功能完善全面的框架，还自带了 $http, ngRoute, jQlite, $q, service 等等。提供了一整套的解决方案，估计这点很合大公司的胃口。并且 Angular 社区成熟活跃，生态完整，目前仍是最流行的前端框架，没有之一，非常适合用来写单页应用。数据双向绑定给开发带来了很大的便利，但双向绑定带来了性能损耗并且脏值检查性能也不好。</p>
<p>对比起来，我还是更喜欢 Angular，他的开发效率高，而且写起来很清晰，虽然他也有一些问题，但是在没有达到一个量级前这些问题是很难被体现出来的。而 React 可能在开发多端或者注重体积或者是在大型应用中可能才会去考虑吧。</p>
<p>另外 Angular2 也实现了虚拟 DOM，同样支持服务端渲染，使用 web worker 提升性能，TypeScript 提升了 JavaScript 项目的健壮性，而 Web Components 无疑是是未来趋势。我对 Angular2 同样满怀期待，我认为 Angular2 未来也会同 Angular1 一样火起来。</p>
<p>计划是再学习 react-router，写一个完整的 React 应用，后端使用 Koa 来开发。不过还是等手头上的东西处理完先吧。</p>
<p>除了 Angular1 和 Angular2 以及 React ，还有 Vue 和 Vue2 以及阿里的 Weex，前端的水深着呢！</p>
<hr>
<p><a href="https://github.com/Lucifier129/Lucifier129.github.io/issues/9" target="_blank" rel="external">深入到源码：解读 redux 的设计思路与用法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚回到家的时候学习了 React 和 Redux，现在才想来总结一下，不知道会不会忘的差不多了…本来是想写一个问卷发布系统的，使用 React 和 Redux 已经完成了基础的几个功能，但是那个代码量…用 Angular 写简直轻轻松松的好吧…然后就去重构项目还有现在学的 Underscore 去了。是时候重新回顾下了。&lt;br&gt;此处主要讲的是 Redux 。&lt;/p&gt;
&lt;h3 id=&quot;关于-Redux&quot;&gt;&lt;a href=&quot;#关于-Redux&quot; class=&quot;headerlink&quot; title=&quot;关于 Redux&quot;&gt;&lt;/a&gt;关于 Redux&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;redux 是facebook 提出的 flux 架构的一种优秀实现；而且不局限于为 react 提供数据状态处理。它是零依赖的，可以配合其他任何框架或者类库一起使用。要想配合 react，还得引入 react-redux。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;关于-Flux&quot;&gt;&lt;a href=&quot;#关于-Flux&quot; class=&quot;headerlink&quot; title=&quot;关于 Flux&quot;&gt;&lt;/a&gt;关于 Flux&lt;/h3&gt;&lt;p&gt;那什么是 Flux 呢？见下图&lt;br&gt;&lt;img src=&quot;/2016/08/01/谈谈React和Redux/flux-overview.png&quot; alt=&quot;flux-overview.png&quot; title=&quot;flux-overview.png&quot;&gt;&lt;br&gt;Flux 可以分为四个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;View: 视图层&lt;/li&gt;
&lt;li&gt;Action: 视图层触发的动作&lt;/li&gt;
&lt;li&gt;Dispatcher: 派发器，用来接受 Actions, 执行回调函数&lt;/li&gt;
&lt;li&gt;Store：数据层，用来存放应用的状态，其变更会触发 View 层更新&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Flux 的最大特点就是单向流动，他的过程大概如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户访问 View ，触发了动作 Action&lt;/li&gt;
&lt;li&gt;Dispatcher 收到 Action ，根据 Action 类别进行相应的处理，处理结束后要求 Store 更新&lt;/li&gt;
&lt;li&gt;Store 进行更新，通知 View 层刷新&lt;/li&gt;
&lt;li&gt;View 层收到通知更新页面&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;额，其实我没有用 Flux，不敢讲太多了，简单的说就是一种单项数据流动的解决方案吧。我是直接学 Redux，对 Flux 也就大概了解这么多了。&lt;/p&gt;
&lt;h3 id=&quot;Redux-和-Flux&quot;&gt;&lt;a href=&quot;#Redux-和-Flux&quot; class=&quot;headerlink&quot; title=&quot;Redux 和 Flux&quot;&gt;&lt;/a&gt;Redux 和 Flux&lt;/h3&gt;&lt;p&gt;Redux 是 Flux 的一种实现，但他们又有所不同，在 Flux 中，Store 可以有多个，但 Redux 有且只能有一个 Store，Flux 中存在 Dispatcher，在 Redux 则没有这个，而是用 reducer 代替了。不多说了，直接往下说 Redux 吧，我快扯不下去 Flux 了=.=&lt;/p&gt;
&lt;h3 id=&quot;理解Redux&quot;&gt;&lt;a href=&quot;#理解Redux&quot; class=&quot;headerlink&quot; title=&quot;理解Redux&quot;&gt;&lt;/a&gt;理解Redux&lt;/h3&gt;&lt;p&gt;Redux 由四部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Action&lt;/li&gt;
&lt;li&gt;Reducer&lt;/li&gt;
&lt;li&gt;Store&lt;/li&gt;
&lt;li&gt;Views&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们结合具体的应用场景来看&lt;/p&gt;
&lt;h4 id=&quot;Action&quot;&gt;&lt;a href=&quot;#Action&quot; class=&quot;headerlink&quot; title=&quot;Action&quot;&gt;&lt;/a&gt;Action&lt;/h4&gt;&lt;p&gt;先从 Action 说起，一个 Action 是一个普通的对象。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; SET_PAPER_TITLE = &lt;span class=&quot;string&quot;&gt;&#39;SET_PAPER_TITLE&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; ADD_QUESTION = &lt;span class=&quot;string&quot;&gt;&#39;ADD_QUESTION&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; REMOVE_QUESTION = &lt;span class=&quot;string&quot;&gt;&#39;REMOVE_QUESTION&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setPaperTitle&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;newTitle&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        type: SET_PAPER_TITLE,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        value: newTitle&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;addQuestion&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;type&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        type: ADD_QUESTION,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        questionType: type&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;removeQuestion&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;questionId&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        type: REMOVE_QUESTION,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        questionId: questionId&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;type 属性是必须的，表示动作类别，其他的参数可以自定。&lt;br&gt;我们先不用管 Action 有什么用，后面会提到。&lt;br&gt;
    
    </summary>
    
      <category term="React" scheme="https://ruiming.github.io/categories/React/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="React" scheme="https://ruiming.github.io/tags/React/"/>
    
      <category term="Redux" scheme="https://ruiming.github.io/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>Underscore 源码学习(四)</title>
    <link href="https://ruiming.github.io/2016/08/01/Underscore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0(%E5%9B%9B)/"/>
    <id>https://ruiming.github.io/2016/08/01/Underscore源码学习(四)/</id>
    <published>2016-08-01T07:37:14.000Z</published>
    <updated>2016-08-04T08:33:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>终于看完了 Underscore 的集合部分了，看 Underscore 源码真的是长见识了，感觉真的受益匪浅。<br>但是集合里面方法也挺多的，我都不知道该拿哪些出来讲下，最近接触了 Redux，就说下 createRedux 这个方法吧，为后面讲 Redux 做个铺垫。<br>先看源码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> createReduce = <span class="function"><span class="keyword">function</span>(<span class="params">dir</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> reducer = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, memo, initial</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</div><div class="line">        length = (keys || obj).length,</div><div class="line">        index = dir &gt; <span class="number">0</span> ? <span class="number">0</span> : length - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(!initial) &#123;</div><div class="line">      memo = obj[keys ? keys[index] : index];</div><div class="line">      index += dir;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(; index &gt;= <span class="number">0</span> &amp;&amp; index &lt; length; index += dir) &#123;</div><div class="line">      <span class="keyword">var</span> currentKey = keys ? keys[index] : index;</div><div class="line">      memo = iteratee(memo, obj[currentKey], currentKey, obj);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> memo;</div><div class="line">  &#125;;</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, memo, context</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> initial = <span class="built_in">arguments</span>.length &gt;= <span class="number">3</span>;</div><div class="line">    <span class="keyword">return</span> reducer(obj, opitimizeCb(iteratee, context, <span class="number">4</span>), memo, initial);</div><div class="line">  &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这是 reduce 函数的工厂函数，用于生成一个 reducer ，dir 是决定方向用的。<br>我们从最后一个 return 开始看起，即<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, memo, context</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> initial = <span class="built_in">arguments</span>.length &gt;= <span class="number">3</span>;</div><div class="line">  <span class="keyword">return</span> reducer(obj, opitimizeCb(iteratee, context, <span class="number">4</span>), memo, initial);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>我们使用 reduce 的时候，如果没有指定 memo 值，这时候参数个数只有两个即 obj 和 iteratee，所以 initial 为 false 表示没有初始化。对于没初始的情况，就是增加了一个 if 语句里面的内容而已，作用是把第一个元素作为 memo 值。<br>接着就是有没有初始化都共用的部分了，通过一个 for 循环把 keys 遍历，并把相应的信息交给 iteratee 去处理，参数 memo 是上一次处理结果。遍历完后把最后的处理结果 memo 返回就完了。<br>这个函数派生了两个方法，即<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_.reduce = _.foldl = _.inject = createReduce(<span class="number">1</span>);</div><div class="line">_.reduceRight = _.foldr = createReduce(<span class="number">-1</span>);</div></pre></td></tr></table></figure></p>
<p>只是方向不同而已。<br>举个例子方便理解些，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = _.reduce([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="function"><span class="keyword">function</span>(<span class="params">accumulator, value, index, collection</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> accmulator + value;</div><div class="line">&#125;, <span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p>结果为 15 这个应该很明显，js 原生也有 reduce 方法，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">left, right</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> left + right;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>我们看下 Underscore 的例子，主要想说明下他的运行过程，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!initial)</div><div class="line">    memo = <span class="number">1</span>; index = <span class="number">1</span>;</div><div class="line">endif</div><div class="line"><span class="keyword">for</span></div><div class="line">    memo = iteratee(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) = <span class="number">3</span>;</div><div class="line">    memo = iteratee(<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) = <span class="number">6</span>;</div><div class="line">    memo = iteratee(<span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) = <span class="number">10</span>;</div><div class="line">    memo = iteratee(<span class="number">10</span>, <span class="number">5</span>, <span class="number">4</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) = <span class="number">15</span>;</div><div class="line">endfor</div><div class="line"><span class="keyword">return</span> memo = <span class="number">15</span>;</div></pre></td></tr></table></figure></p>
<p>额，我也不知道写的是什么东西，只是描述下过程而已，你懂的。<br>剩下的集合部分感觉也没啥好说的了，花点时间看下就可以看懂了=.=。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于看完了 Underscore 的集合部分了，看 Underscore 源码真的是长见识了，感觉真的受益匪浅。&lt;br&gt;但是集合里面方法也挺多的，我都不知道该拿哪些出来讲下，最近接触了 Redux，就说下 createRedux 这个方法吧，为后面讲 Redux 做个铺垫。&lt;br&gt;先看源码&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; createReduce = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;dir&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; reducer = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj, iteratee, memo, initial&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; keys = !isArrayLike(obj) &amp;amp;&amp;amp; _.keys(obj),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        length = (keys || obj).length,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        index = dir &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ? &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; : length - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!initial) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      memo = obj[keys ? keys[index] : index];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      index += dir;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(; index &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; index &amp;lt; length; index += dir) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; currentKey = keys ? keys[index] : index;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      memo = iteratee(memo, obj[currentKey], currentKey, obj);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; memo;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj, iteratee, memo, context&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; initial = &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;.length &amp;gt;= &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; reducer(obj, opitimizeCb(iteratee, context, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;), memo, initial);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这是 reduce 函数的工厂函数，用于生成一个 reducer ，dir 是决定方向用的。&lt;br&gt;我们从最后一个 return 开始看起，即&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj, iteratee, memo, context&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; initial = &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;.length &amp;gt;= &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; reducer(obj, opitimizeCb(iteratee, context, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;), memo, initial);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们使用 reduce 的时候，如果没有指定 memo 值，这时候参数个数只有两个即 obj 和 iteratee，所以 initial 为 false 表示没有初始化。对于没初始的情况，就是增加了一个 if 语句里面的内容而已，作用是把第一个元素作为 memo 值。&lt;br&gt;接着就是有没有初始化都共用的部分了，通过一个 for 循环把 keys 遍历，并把相应的信息交给 iteratee 去处理，参数 memo 是上一次处理结果。遍历完后把最后的处理结果 memo 返回就完了。&lt;br&gt;这个函数派生了两个方法，即&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;_.reduce = _.foldl = _.inject = createReduce(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;_.reduceRight = _.foldr = createReduce(&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;只是方向不同而已。&lt;br&gt;举个例子方便理解些，例如：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; sum = _.reduce([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;], &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;accumulator, value, index, collection&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; accmulator + value;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;结果为 15 这个应该很明显，js 原生也有 reduce 方法，如下：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;].reduce(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;left, right&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; left + right;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Underscore" scheme="https://ruiming.github.io/categories/Underscore/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="Underscore" scheme="https://ruiming.github.io/tags/Underscore/"/>
    
  </entry>
  
  <entry>
    <title>Underscore 源码学习(三)</title>
    <link href="https://ruiming.github.io/2016/07/31/Underscore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0(%E4%B8%89)/"/>
    <id>https://ruiming.github.io/2016/07/31/Underscore源码学习(三)/</id>
    <published>2016-07-31T06:37:31.000Z</published>
    <updated>2016-08-04T08:32:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>这次主要说剩余参数。<br>在 ES5 中，如果想要函数接收任意数量的参数，必须使用特殊变量 <code>arguments</code>，举个例子，我们要实现一个加法函数，要求第一个数乘2，然后与其他数相加。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> sum = <span class="built_in">arguments</span>[<span class="number">0</span>] * <span class="number">2</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</div><div class="line">        sum += <span class="built_in">arguments</span>[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 ES6 中，我们可以使用 <code>...</code> 操作符，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, ...args</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> sum = first*<span class="number">2</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> arg <span class="keyword">of</span> args) &#123;</div><div class="line">        sum += arg;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用 ES5 我们无法给函数定义参数，而只能通过 <code>arguments</code> 来获取参数，这样写明显带来了可读性的降低。而 ES6 我们就可以在函数声明里面写明参数，对于不定长的参数，则可以使用 <code>...</code> 操作符。<br><code>...</code> 还有另一个常用的应用场景，比如下面例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span> <span class="keyword">instanceof</span> <span class="built_in">Array</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</div><div class="line">&#125;</div><div class="line">test(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line"><span class="comment">// Result:</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="literal">false</span></div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>如果细看输出的[1, 2, 3]会发现他是这样的：<br><img src="/2016/07/31/Underscore源码学习(三)/result1.png" alt="result1.png" title="result1.png"><br>我们再试试下面的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="built_in">console</span>.log(arr);</div><div class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>);</div><div class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</div><div class="line"><span class="comment">// Result:</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="literal">true</span></div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>再看下[1, 2, 3]这行输出里面是什么：<br><img src="/2016/07/31/Underscore源码学习(三)/result2.png" alt="result2.png" title="result2.png"><br>从 <code>instanceof</code> 我们就知道了 <code>arguments</code> 并不是真正的数组。伪数组实质是一个对象。<br>要把一个伪数组转为数组，可以这样用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div></pre></td></tr></table></figure></p>
<p>上面这种做法在很多地方都可以看到。除了上面这样做之外，我们还可以使用 ES6 的 <code>Array.from</code> 来处理，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</div></pre></td></tr></table></figure></p>
<p>但在 ES6 中，我们使用 <code>...</code> 运算符并不存在这个问题，比如上面第二个例子，<code>args</code> 是一个数组。<br>鉴于此，我们应该尽量使用 ES6 剩余参数写法和 <code>Array.from</code> 的写法，因为这样更容易理解，而且写起来更简洁。<br>另外，我们还可以使用 <code>...</code> 操作符来复制数组，如下：<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> itemsCopy = [...items];</div></pre></td></tr></table></figure></p>
<p>额，说多了，其实我是想说说 Underscore 中的 restArgs 这个东西…<br>看下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> restArgs = <span class="function"><span class="keyword">function</span>(<span class="params">func, startIndex</span>) </span>&#123;</div><div class="line">    startIndex = startIndex == <span class="literal">null</span> ? func.length <span class="number">-1</span> : +startIndex;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> length = <span class="built_in">Math</span>.max(<span class="built_in">arguments</span>.length - startIndex, <span class="number">0</span>);</div><div class="line">        <span class="keyword">var</span> rest = <span class="built_in">Array</span>(length);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</div><div class="line">            rest[index] = <span class="built_in">arguments</span>[index + startIndex];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">switch</span> (startIndex) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> func.call(<span class="keyword">this</span>, rest);</div><div class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> func.call(<span class="keyword">this</span>, <span class="built_in">arguments</span>[<span class="number">0</span>], rest);</div><div class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> func.call(<span class="keyword">this</span>, <span class="built_in">arguments</span>[<span class="number">0</span>], <span class="built_in">arguments</span>[<span class="number">1</span>], rest);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>(startIndex + <span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; startIndex; index++) &#123;</div><div class="line">            args[index] = <span class="built_in">arguments</span>[index];</div><div class="line">        &#125;</div><div class="line">        args[startIndex] = rest;</div><div class="line">        <span class="keyword">return</span> func.apply(<span class="keyword">this</span>, args);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个的作用就类似与 ES6 中的 <code>...</code> 操作符。这段代码作用是把 <code>func</code> 中 <code>startIndex</code> 开始的（如果没有指定则为被函数声明参数的最后一位开始）后面的参数全部变为一个数组传入 <code>func</code> 中。<br>这里有几个可圈可点的地方：</p>
<ul>
<li><p>fun.length 和 arguments.length<br>函数也具有 <code>length</code> 方法，得到的值是函数定义的参数的个数，但注意如果中间有一个含默认值的参数，则这个数和后面的参数都不会计算进去。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params">arg1, arg2, arg3 = 1, arg4</span>) </span>&#123;&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params">arg1, arg2, arg3</span>) </span>&#123;&#125;;</div><div class="line">test1.length;   <span class="comment">// 2</span></div><div class="line">test2.length    <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>而 <code>arguments.length</code> 则一直表示传入函数的参数个数。</p>
</li>
<li><p>使用 <code>+</code> 转换为数字<br>你可能注意到了下面这句话有个 <code>+</code> 运算符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">startIndex = startIndex == <span class="literal">null</span> ? func.length - <span class="number">1</span> : +startIndex;</div></pre></td></tr></table></figure>
<p>其用途就是尝试把 <code>startIndex</code> 转为数字，我们举例看下就明白了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="string">'123'</span>, b = <span class="string">'123s'</span>, c = <span class="string">'0x321'</span>, d = <span class="string">'-0'</span>, e = <span class="string">'-Infinity'</span></div><div class="line">+a;           <span class="comment">// 123</span></div><div class="line">+b;           <span class="comment">// NaN</span></div><div class="line">+c;           <span class="comment">// 801</span></div><div class="line">+d;           <span class="comment">// -0</span></div><div class="line">+e;           <span class="comment">// -Infinity</span></div></pre></td></tr></table></figure>
<p>应该很清楚了，就不说明了。<br>然后关于这里的 <code>switch</code> 其实就是一个优化而已，前面都提到过了，不提了。</p>
</li>
</ul>
<p>我们看下 Underscore 运用到 restArgs 方法的地方：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">_.invoke = restArgs(<span class="function"><span class="keyword">function</span>(<span class="params">obj, method, args</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> isFunc = _.isFunction(method);</div><div class="line">    <span class="keyword">return</span> _.map(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> func = isFunc ? method : value[method];</div><div class="line">        <span class="keyword">return</span> func == <span class="literal">null</span> ? func : func.apply(value, args);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这个方法的作用是在 <code>obj</code> 的每个元素上面执行 <code>method</code> 方法，例如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">_.invoke([[5, 1, 7], [3, 2, 1]], 'sort');</div><div class="line">_.invoke([['a', 'b', 'c'], ['w', 'g', 's']], 'join', '#');</div><div class="line">// Result:</div><div class="line">1,5,7,1,2,3</div><div class="line">a#b#c,w#g#s</div></pre></td></tr></table></figure></p>
<p>由于 <code>method</code> 需要的参数个数是未知的，所以我们这里使用了 <code>args</code> 再用 <code>restArgs</code> 达到类似 <code>...</code> 操作符的效果。<br>本来还想说说 Underscore 的几个方法的…但是好像已经写了挺多的了，还是下一次再介绍吧，后面的很多方法其实都不难理解，不过最好结合他的实际应用例子这样就更容易去理解些。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次主要说剩余参数。&lt;br&gt;在 ES5 中，如果想要函数接收任意数量的参数，必须使用特殊变量 &lt;code&gt;arguments&lt;/code&gt;，举个例子，我们要实现一个加法函数，要求第一个数乘2，然后与其他数相加。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; sum = &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;.length; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        sum += &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;[i];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sum;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在 ES6 中，我们可以使用 &lt;code&gt;...&lt;/code&gt; 操作符，例如：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;first, ...args&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; sum = first*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; arg &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; args) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        sum += arg;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sum;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用 ES5 我们无法给函数定义参数，而只能通过 &lt;code&gt;arguments&lt;/code&gt; 来获取参数，这样写明显带来了可读性的降低。而 ES6 我们就可以在函数声明里面写明参数，对于不定长的参数，则可以使用 &lt;code&gt;...&lt;/code&gt; 操作符。&lt;br&gt;&lt;code&gt;...&lt;/code&gt; 还有另一个常用的应用场景，比如下面例子：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;test(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Result:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果细看输出的[1, 2, 3]会发现他是这样的：&lt;br&gt;&lt;img src=&quot;/2016/07/31/Underscore源码学习(三)/result1.png&quot; alt=&quot;result1.png&quot; title=&quot;result1.png&quot;&gt;&lt;br&gt;我们再试试下面的&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(arr);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(arr &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(arr &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Result:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;再看下[1, 2, 3]这行输出里面是什么：&lt;br&gt;&lt;img src=&quot;/2016/07/31/Underscore源码学习(三)/result2.png&quot; alt=&quot;result2.png&quot; title=&quot;result2.png&quot;&gt;&lt;br&gt;从 &lt;code&gt;instanceof&lt;/code&gt; 我们就知道了 &lt;code&gt;arguments&lt;/code&gt; 并不是真正的数组。伪数组实质是一个对象。&lt;br&gt;要把一个伪数组转为数组，可以这样用&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr = &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;.prototype.slice.call(&lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面这种做法在很多地方都可以看到。除了上面这样做之外，我们还可以使用 ES6 的 &lt;code&gt;Array.from&lt;/code&gt; 来处理，如下：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr = &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;.from(&lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但在 ES6 中，我们使用 &lt;code&gt;...&lt;/code&gt; 运算符并不存在这个问题，比如上面第二个例子，&lt;code&gt;args&lt;/code&gt; 是一个数组。&lt;br&gt;鉴于此，我们应该尽量使用 ES6 剩余参数写法和 &lt;code&gt;Array.from&lt;/code&gt; 的写法，因为这样更容易理解，而且写起来更简洁。&lt;br&gt;另外，我们还可以使用 &lt;code&gt;...&lt;/code&gt; 操作符来复制数组，如下：&lt;br&gt;
    
    </summary>
    
      <category term="Underscore" scheme="https://ruiming.github.io/categories/Underscore/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="Underscore" scheme="https://ruiming.github.io/tags/Underscore/"/>
    
  </entry>
  
  <entry>
    <title>Underscore 源码学习(二)</title>
    <link href="https://ruiming.github.io/2016/07/29/Underscore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/"/>
    <id>https://ruiming.github.io/2016/07/29/Underscore源码学习(二)/</id>
    <published>2016-07-29T13:29:23.000Z</published>
    <updated>2016-08-04T08:32:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>Underscore 源码的学习落下了好几天，因为前几天一直正在重构项目和搞 React，不过这几天应该会花较多时间在 Underscore 上面了。<br>这次主要说下 Underscore 两个比较重要的函数吧，一个是<code>optimizeCb</code>，另一个是<code>cb</code>，这两个花了我挺长时间看的，而且是整个 Underscore 非常重要的函数，后面很多地方都使用到了它。</p>
<h2 id="optimizeCb-函数"><a href="#optimizeCb-函数" class="headerlink" title="optimizeCb 函数"></a>optimizeCb 函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> optimizeCb = <span class="function"><span class="keyword">function</span>(<span class="params">func, context, argCount</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (context === <span class="keyword">void</span> <span class="number">0</span>) <span class="keyword">return</span> func;</div><div class="line">    <span class="keyword">switch</span> (argCount == <span class="literal">null</span> ? <span class="number">3</span> : argCount) &#123;</div><div class="line">      <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> func.call(context, value);</div><div class="line">      &#125;;</div><div class="line">      <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">value, index, collection</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> func.call(context, value, index, collection);</div><div class="line">      &#125;;</div><div class="line">      <span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">accumulator, value, index, collection</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> func.call(context, accumulator, value, index, collection);</div><div class="line">      &#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> func.apply(context, <span class="built_in">arguments</span>);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个地方 <code>switch</code> 只是一个性能的优化，其实简化来看就是这样的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> optimizeCb = <span class="function"><span class="keyword">function</span>(<span class="params">func, context, argCount</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (context === <span class="keyword">void</span> <span class="number">0</span>) <span class="keyword">return</span> func;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> func.apply(context, <span class="built_in">arguments</span>);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>之所以有那段 <code>switch</code> 前面一篇已经有提到了，只是一个优化而已。使用 call 快于 apply。不过好像最新的 Chrome 已经可以自己优化这个过程，但为了提升性能，加上也无妨。<br>解释下段代码的意思，字如起名 optimizeCb 优化回调。这个函数传入三个参数依次是函数，上下文，参数个数。如果没有指定上下文则返回函数本身，如果有，则对该上下文绑定到传入的函数，根据传入的参数个数，在做一个性能优化。这个函数就是这个意思。我们看下他的使用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">_.each = _.forEach = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) </span>&#123;</div><div class="line">  iteratee = optimizeCb(iteratee, context);</div><div class="line">  <span class="keyword">var</span> i, length;</div><div class="line">  <span class="keyword">if</span> (isArrayLike(obj)) &#123;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, length = obj.length; i &lt; length; i++) &#123;</div><div class="line">      iteratee(obj[i], i, obj);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">var</span> keys = _.keys(obj);</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, length = keys.length; i &lt; length; i++) &#123;</div><div class="line">      iteratee(obj[keys[i]], keys[i], obj);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个函数是用来实现数组或者对象的遍历的，他是怎么做到呢？<br>首先是<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iteratee = optimizeCb(iteratee, context);</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>这个是优化 <code>iteratee</code> 这个函数，如果指定了上下文(<code>context</code>)则做绑定。一开始没理解 <code>iteratee</code> 这东西，其实他就是一个函数而已，比如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stu = &#123;</div><div class="line">  <span class="string">'age'</span>: <span class="number">20</span>,</div><div class="line">  <span class="string">'school'</span>: <span class="string">'SCNU'</span>,</div><div class="line">  <span class="string">'sex'</span>: <span class="string">'male'</span></div><div class="line">&#125;;</div><div class="line">_.each(stu, <span class="function"><span class="keyword">function</span>(<span class="params">value, key, obj</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(key + <span class="string">' : '</span> + value); </div><div class="line">&#125;);</div><div class="line"><span class="comment">// console</span></div><div class="line">age : <span class="number">20</span></div><div class="line">school : SCNU</div><div class="line">sex : male</div></pre></td></tr></table></figure></p>
<p>我们传入了一个函数，这个函数可以有三个回调参数分别是 value, key, obj 分别表示键值，键名，迭代对象。<br>重新看回 <code>each</code> 这个函数，<code>isArrayLike</code> 函数判断 <code>obj</code> 是不是数组，如果是的话，一个循环分别把 <code>obj[i]</code>, <code>i</code>, <code>obj</code> 分别传入这个 <code>iteratee</code> 这个传入来的函数，比如上面的 <code>function(value, key, obj){}</code> 里面，一一对应到 <code>value</code>, <code>key</code>, <code>obj</code>。从而实现迭代。在下面的是对象的处理，没什么好说的。<br>然后我们就讲完了 optimizeCb 这个函数了，其实也挺好理解的。</p>
<h2 id="cb-函数"><a href="#cb-函数" class="headerlink" title="cb 函数"></a>cb 函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> cb = <span class="function"><span class="keyword">function</span>(<span class="params">value, context, argCount</span>) </span>&#123;</div><div class="line">    <span class="comment">// 如果改变了iteratee的行为，则返回自定义的iteratee</span></div><div class="line">    <span class="keyword">if</span> (_.iteratee !== builtinIteratee) <span class="keyword">return</span> _.iteratee(value, context);</div><div class="line">    <span class="comment">// 没有传入value，返回当前迭代元素自身，比如var results = _.map([1,2,3]) =&gt; results: [1,2,3]</span></div><div class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) <span class="keyword">return</span> _.identity;</div><div class="line">    <span class="comment">// 是函数返回优化回调函数，比如var results = _.map([1,2,3], function(value, index, obj) &#123;...&#125;)</span></div><div class="line">    <span class="keyword">if</span> (_.isFunction(value)) <span class="keyword">return</span> optimizeCb(value, context, argCount);</div><div class="line">    <span class="comment">// 是对象返回一个能判断对象是否相等的函数，比如</span></div><div class="line">    <span class="comment">// var results = _.map([&#123;name:'qq'&#125;,&#123;name:'w',age:13&#125;], &#123;name:'w'&#125;) =&gt; results: [false, true]</span></div><div class="line">    <span class="keyword">if</span> (_.isObject(value)) <span class="keyword">return</span> _.matcher(value);</div><div class="line">    <span class="comment">// 返回获取对象属性的函数，比如</span></div><div class="line">    <span class="comment">// var results = _.map([&#123;name: 'qq'&#125;, &#123;name: 'ww'&#125;], 'name') =&gt; results: ['qq', 'ww']</span></div><div class="line"><span class="keyword">return</span> _.property(value);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>首先是 <code>buildinIteratee</code> 这东西，这要结合下面这个来看<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_.iteratee = builtinIteratee = <span class="function"><span class="keyword">function</span>(<span class="params">value, context</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> cb(value, context, <span class="literal">Infinity</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个是给用户自定义迭代规则用的。怎么自定义呢，比如这样<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">_.iteratee = <span class="function"><span class="keyword">function</span>(<span class="params">value, context</span>) </span>&#123;</div><div class="line">  <span class="comment">// value 为对象时返回自身</span></div><div class="line">  <span class="keyword">if</span> (value == <span class="literal">null</span> || _.isObject(value)) <span class="keyword">return</span> _.identity;</div><div class="line">  <span class="keyword">if</span> (_.isFunction(value)) <span class="keyword">return</span> optimizeCb(value, context, argCount);</div><div class="line">  <span class="keyword">return</span> _.property(value);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>还有 <code>identity</code> 其实就这样，返回一个返回自身的函数…<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Keep the identity function around for default iteratees.</span></div><div class="line">_.identity = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> value;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>我们自定义的这个迭代规则，如果 <code>value</code> 不为空而且是对象，则返回一个可以返回自身的函数。注意我们改变的只是 <code>iteratee</code> 函数，<code>builtinIteratee</code> 存的是默认规则，在 <code>cb</code> 函数中如果发现 <code>iteratee</code> 的行为更改了，则使用更改的行为来处理，否则往下默认处理，上面已经备注的很清楚了，自己看吧。<br>我们举个例子说下 <code>cb</code> 函数的用法，例如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">_.map = _.collect = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) </span>&#123;</div><div class="line">    iteratee = cb(iteratee, context);</div><div class="line">    <span class="keyword">var</span> keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</div><div class="line">        length = (keys || obj).length,</div><div class="line">        results = <span class="built_in">Array</span>(length);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</div><div class="line">      <span class="keyword">var</span> currentKey = keys ? keys[index] : index;</div><div class="line">      results[index] = iteratee(obj[currentKey], currentKey, obj);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>注意我们是怎么使用 map 的，比如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> results = _.map([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function"><span class="keyword">function</span>(<span class="params">value, index, obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'['</span>+obj+<span class="string">']'</span> + <span class="string">'\'s '</span>+index+<span class="string">' position is '</span>+value;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>我们使用 map 传入两个参数，一个是迭代对象，这里是 <code>[1, 2, 3]</code>，第二个参数是迭代函数，这里是 <code>function (value, index, obj){...}</code>。这个函数在 map 内部也就是 <code>iteratee</code>，然后我们再来看<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iteratee = cb(iteratee, context)</div></pre></td></tr></table></figure></p>
<p><code>iteratee</code> 是一个函数，使用上面这个句子返回了 <code>optimizeCb(value, context, argCount)</code>，这里的 <code>value</code> 就对应了我们的 <code>function(value, index, obj){...}</code> 函数。接着回到 map，他对对象进行遍历依次把通过调用 <code>iteratee</code> 也就是我们传入的函数得到的结果复制给 <code>result</code>，最后返回了 <code>result</code>。<br>所以上面例子的结果是<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">results:  [</div><div class="line">    <span class="string">"[1,2,3]'s 0 position is 1"</span>, </div><div class="line">    <span class="string">"[1,2,3]'s 1 position is 2"</span>, </div><div class="line">    <span class="string">"[1,2,3]'s 2 position is 3"</span></div><div class="line">];</div></pre></td></tr></table></figure></p>
<p>一定要理解 cb 和 optimizeCb 这两个的用法，他们在后面多次用到。好了，完了～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Underscore 源码的学习落下了好几天，因为前几天一直正在重构项目和搞 React，不过这几天应该会花较多时间在 Underscore 上面了。&lt;br&gt;这次主要说下 Underscore 两个比较重要的函数吧，一个是&lt;code&gt;optimizeCb&lt;/code&gt;，另一个是&lt;code&gt;cb&lt;/code&gt;，这两个花了我挺长时间看的，而且是整个 Underscore 非常重要的函数，后面很多地方都使用到了它。&lt;/p&gt;
&lt;h2 id=&quot;optimizeCb-函数&quot;&gt;&lt;a href=&quot;#optimizeCb-函数&quot; class=&quot;headerlink&quot; title=&quot;optimizeCb 函数&quot;&gt;&lt;/a&gt;optimizeCb 函数&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; optimizeCb = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;func, context, argCount&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (context === &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; func;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (argCount == &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; ? &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; : argCount) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;value&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; func.call(context, value);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;value, index, collection&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; func.call(context, value, index, collection);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;accumulator, value, index, collection&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; func.call(context, accumulator, value, index, collection);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; func.apply(context, &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个地方 &lt;code&gt;switch&lt;/code&gt; 只是一个性能的优化，其实简化来看就是这样的&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; optimizeCb = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;func, context, argCount&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (context === &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; func;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; func.apply(context, &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;之所以有那段 &lt;code&gt;switch&lt;/code&gt; 前面一篇已经有提到了，只是一个优化而已。使用 call 快于 apply。不过好像最新的 Chrome 已经可以自己优化这个过程，但为了提升性能，加上也无妨。&lt;br&gt;解释下段代码的意思，字如起名 optimizeCb 优化回调。这个函数传入三个参数依次是函数，上下文，参数个数。如果没有指定上下文则返回函数本身，如果有，则对该上下文绑定到传入的函数，根据传入的参数个数，在做一个性能优化。这个函数就是这个意思。我们看下他的使用。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;_.each = _.forEach = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj, iteratee, context&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  iteratee = optimizeCb(iteratee, context);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i, length;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isArrayLike(obj)) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, length = obj.length; i &amp;lt; length; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      iteratee(obj[i], i, obj);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; keys = _.keys(obj);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, length = keys.length; i &amp;lt; length; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      iteratee(obj[keys[i]], keys[i], obj);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; obj;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个函数是用来实现数组或者对象的遍历的，他是怎么做到呢？&lt;br&gt;首先是&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;iteratee = optimizeCb(iteratee, context);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Underscore" scheme="https://ruiming.github.io/categories/Underscore/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="Underscore" scheme="https://ruiming.github.io/tags/Underscore/"/>
    
  </entry>
  
  <entry>
    <title>一次项目重构</title>
    <link href="https://ruiming.github.io/2016/07/26/%E4%B8%80%E6%AC%A1%E9%A1%B9%E7%9B%AE%E9%87%8D%E6%9E%84/"/>
    <id>https://ruiming.github.io/2016/07/26/一次项目重构/</id>
    <published>2016-07-26T11:57:36.000Z</published>
    <updated>2016-08-04T09:29:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>上学期由于期末停工的项目又要继续开展了，然而停了一个多月的时间，我已经看不下去他的代码了，简直惨不忍睹，花了我将近40个小时的时间去做了重构。虽然重构说明有进步了，但是一改就要改几十个页面啊…累觉不爱..说一说这次将近40小时的重构吧。<br><img src="/2016/07/26/一次项目重构/git-diff.jpg" alt="git-diff" title="git-diff"></p>
<h2 id="Angular-重构"><a href="#Angular-重构" class="headerlink" title="Angular 重构"></a>Angular 重构</h2><p>项目是基于 Angular 的 SPA，项目参考<a href="https://github.com/johnpapa/angular-styleguide/blob/master/a1/i18n/zh-CN.md" target="_blank" rel="external">Angular规范</a>进行重构，主要是以下几点：</p>
<ul>
<li>把控制器的业务逻辑(主要是 HTTP 请求)分离到 Factory</li>
<li>Controller 和 Directive 以及 Factory 全部用立即函数包装</li>
<li>Controller 和 Directive 以及 Factory 内部书写格式</li>
<li>使用 controllerAs 代替 $scope </li>
<li>全部 JavaScript 文件使用 use strict 严格模式</li>
<li>利用单体做部分数据的缓存</li>
<li>提取大部分可复用模块到 directive</li>
<li>全部 ng-repeat 加上 track by</li>
<li>过大的试图使用 ng-include 进行分离</li>
<li>去掉全部辅助变量，用 angular-promise-buttons 来达到按钮状态变化</li>
<li>去掉全部页面切换动画</li>
<li>手动进行依赖注入</li>
<li>使用 ES6 语法，用 babel 转为 ES5</li>
<li>使用 eslint 来做代码格式检查</li>
</ul>
<p>之前我几乎没有使用 Factory 这一层，全部业务逻辑都在 Controller 里面做，随着项目越来越大(有26个页面)，页面之间函数重复的情况很多，而且控制器太厚，可读性差，给维护带来了巨大的困难。在这次重构之中，我把全部的 HTTP 请求全部放在 Factory 实现，从而做到了以下几点：</p>
<ul>
<li>函数复用，多个控制器用一个 Factory，避免同个函数多次书写</li>
<li>HTTP 请求返回 promise，结合 angular-promise-buttons 做到了按钮状态的自动变化以及过渡效果，去掉了先前实现同样目的的全部辅助变量</li>
<li>对部分相对不变的数据，在第一次缓存后直接在该 Factory 进行缓存，第二次获取的时候直接返回内存中的数据，加快了部分页面的二次加载速度，对跨页面你的同个请求同样有效</li>
<li>容易做单元测试和更改逻辑，因为全部 HTTP 请求都放在 Factory 实现，对后期修改以及代码测试都带来了很大的方便</li>
</ul>
<a id="more"></a>
<p>举个例子，这是我项目中的部分代码，现在是能拿出手了，以前的代码我都不能再吐槽了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** IndexCtrl.js */</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;                   <span class="comment">// 立即执行函数，避免作用域污染</span></div><div class="line"><span class="meta">    'use strict'</span>;               <span class="comment">// 严格模式，使代码更规范</span></div><div class="line">                                <span class="comment">// 空一行</span></div><div class="line">    angular                     <span class="comment">// Angular控制器定义，控制器函数使用命名行数</span></div><div class="line">        .module(<span class="string">'index'</span>)</div><div class="line">        .controller(<span class="string">'IndexCtrl'</span>, IndexCtrl);</div><div class="line"></div><div class="line">    IndexCtrl.$inject = [<span class="string">'bookservice'</span>, <span class="string">'booklistservice'</span>, <span class="string">'slideservice'</span>];     <span class="comment">// 手动依赖注入</span></div><div class="line">                                                                                <span class="comment">// 再空一行</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">IndexCtrl</span>(<span class="params">bookservice, booklistservice, slideservice</span>) </span>&#123;            <span class="comment">// 控制器函数</span></div><div class="line">        <span class="keyword">var</span> vm = <span class="keyword">this</span>;                                                          <span class="comment">// 不使用$scope</span></div><div class="line">        vm.myInterval = <span class="number">5000</span>;</div><div class="line"></div><div class="line">        vm.getHotBooklists = getHotBooklists;                                   <span class="comment">// 置顶绑定成员，函数声明隐藏实现细节</span></div><div class="line">        </div><div class="line">        getPopularBooks();                                                      <span class="comment">// 即时只使用一次，也推荐封装成函数</span></div><div class="line">        getSlides();</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getPopularBooks</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> bookservice.getPopularBooks().then(response =&gt; &#123;</div><div class="line">                vm.books = response;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getHotBooklists</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> booklistservice.getHotBooklists().then(response =&gt; &#123;</div><div class="line">                vm.booklists = response;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getSlides</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> slideservice.getSlides().then(response =&gt; &#123;</div><div class="line">                vm.slides = response;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>然后是 Factory 文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** SlideService.js */</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta">    'use strict'</span>;</div><div class="line"></div><div class="line">    angular</div><div class="line">        .module(<span class="string">'index'</span>)</div><div class="line">        .factory(<span class="string">'slideservice'</span>, slideservice);</div><div class="line"></div><div class="line">    slideservice.$inject = [<span class="string">'$http'</span>, <span class="string">'$q'</span>];</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">slideservice</span>(<span class="params">$http, $q</span>) </span>&#123;</div><div class="line">        <span class="keyword">let</span> slides = <span class="literal">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            getSlides: getSlides</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getSlides</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span>(slides === <span class="literal">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> $http.get(host + <span class="string">'/slides'</span>)</div><div class="line">                    .then(response =&gt; &#123;</div><div class="line">                        slides = response.data;         <span class="comment">// 第一次获取后存入内存</span></div><div class="line">                        <span class="keyword">return</span> slides;</div><div class="line">                    &#125;);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">let</span> deferred = $q.defer();</div><div class="line">                deferred.resolve(slides);</div><div class="line">                <span class="keyword">return</span> deferred.promise;                <span class="comment">// 将数据封装入promise返回，保证透明性</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>directive 就不给示例了，上面主要参考了这个<a href="https://github.com/johnpapa/angular-styleguide/blob/master/a1/i18n/zh-CN.md" target="_blank" rel="external">Angular规范</a>。这样写真的比我之前写的好了几百倍，controller 和 factory 和 directive 都按这个规范来，代码会很好维护。</p>
<p>这次重构让我知道我以前写的根本不叫 Angular，写的是一坨翔，MLGB 害我改了四天。</p>
<h2 id="HTML-重构"><a href="#HTML-重构" class="headerlink" title="HTML 重构"></a>HTML 重构</h2><p>其实说白了也是 Angular 重构，在上面的 Angular 重构已经提到了一些了，但是上面主要是说 controller 和 factory，这里说下 directive 和视图。</p>
<h3 id="部分页面复用"><a href="#部分页面复用" class="headerlink" title="部分页面复用"></a>部分页面复用</h3><p>在 Angular 中，HTML 部分复用有两种方案，一种是使用 ng-include，还有一种是使用 directive，其实区别很简单，ng-include 只是很简单的 HTML 复用，而 directive 你可以传递参数，directive 可以有自己的控制器，可以操纵 DOM，其实就是 HTML 和 JavaScript 文件的区别。不过这只是 directive 在页面复用这一块的作用，其实 directive 强大的很。</p>
<h3 id="使用-ng-repeat-都带上-track-by"><a href="#使用-ng-repeat-都带上-track-by" class="headerlink" title="使用 ng-repeat 都带上 track by"></a>使用 ng-repeat 都带上 track by</h3><p>对于 ng-repeat 使用 track by 可以提升性能，对于任何 ng-repeat 都加上 track by 是一个好习惯。比如<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">ng-repeat</span>=<span class="string">"book in vm.books track by book.isbn"</span>&gt;</span>&#123;&#123;book.title&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>也可以直接使用 track by $index。</p>
<h3 id="使用-controllerAs"><a href="#使用-controllerAs" class="headerlink" title="使用 controllerAs"></a>使用 controllerAs</h3><p>直接在路由使用 controllerAs<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">.state(<span class="string">'index'</span>, &#123;</div><div class="line">    url: <span class="string">'/'</span>,</div><div class="line">    views: &#123;</div><div class="line">        <span class="string">'main'</span>: &#123;</div><div class="line">            templateUrl: <span class="string">'index/index_tpl.html'</span>,</div><div class="line">            controller: <span class="string">'IndexCtrl'</span>,</div><div class="line">            controllerAs: <span class="string">'vm'</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>然后在视图中就像上面的例子，在访问控制器的变量和方法的时候都要带上 vm，虽然这样会稍微麻烦了一点，但是可以避免很多坑，而且这种写法更接近 JavaScript 原生的写法。</p>
<h2 id="CSS-重构"><a href="#CSS-重构" class="headerlink" title="CSS 重构"></a>CSS 重构</h2><p>恩，CSS 重构才是真正的大坑，先说下我之前是怎么写 CSS 代码的</p>
<ul>
<li>使用了 Sass 预处理器</li>
<li>多层嵌套</li>
<li>命名混乱</li>
<li>过多复用</li>
<li>全部挤在一个文件</li>
</ul>
<p>恩，挤在一个文件里面是最要命的，而且很任性的进行嵌套，导致多了或者少了一层都可能出问题，而且是2000多行的代码…所以我其实并没有做什么重构，我把它从一个文件分成了很多个文件，每个视图一个专属 scss 文件，对于复用的部分页面，用 directive 替代，并给该 directive 专属的 scss 文件。<br>怎么做到专属呢，就是每个视图和每个 scss 都包装在一个类名里面，这样就保证了 scss 代码互不干扰。<br>所以，其实我做的只是便于后期书写而已，总不能继续在这个文件书写下去，大坑啊。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上学期由于期末停工的项目又要继续开展了，然而停了一个多月的时间，我已经看不下去他的代码了，简直惨不忍睹，花了我将近40个小时的时间去做了重构。虽然重构说明有进步了，但是一改就要改几十个页面啊…累觉不爱..说一说这次将近40小时的重构吧。&lt;br&gt;&lt;img src=&quot;/2016/07/26/一次项目重构/git-diff.jpg&quot; alt=&quot;git-diff&quot; title=&quot;git-diff&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Angular-重构&quot;&gt;&lt;a href=&quot;#Angular-重构&quot; class=&quot;headerlink&quot; title=&quot;Angular 重构&quot;&gt;&lt;/a&gt;Angular 重构&lt;/h2&gt;&lt;p&gt;项目是基于 Angular 的 SPA，项目参考&lt;a href=&quot;https://github.com/johnpapa/angular-styleguide/blob/master/a1/i18n/zh-CN.md&quot;&gt;Angular规范&lt;/a&gt;进行重构，主要是以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把控制器的业务逻辑(主要是 HTTP 请求)分离到 Factory&lt;/li&gt;
&lt;li&gt;Controller 和 Directive 以及 Factory 全部用立即函数包装&lt;/li&gt;
&lt;li&gt;Controller 和 Directive 以及 Factory 内部书写格式&lt;/li&gt;
&lt;li&gt;使用 controllerAs 代替 $scope &lt;/li&gt;
&lt;li&gt;全部 JavaScript 文件使用 use strict 严格模式&lt;/li&gt;
&lt;li&gt;利用单体做部分数据的缓存&lt;/li&gt;
&lt;li&gt;提取大部分可复用模块到 directive&lt;/li&gt;
&lt;li&gt;全部 ng-repeat 加上 track by&lt;/li&gt;
&lt;li&gt;过大的试图使用 ng-include 进行分离&lt;/li&gt;
&lt;li&gt;去掉全部辅助变量，用 angular-promise-buttons 来达到按钮状态变化&lt;/li&gt;
&lt;li&gt;去掉全部页面切换动画&lt;/li&gt;
&lt;li&gt;手动进行依赖注入&lt;/li&gt;
&lt;li&gt;使用 ES6 语法，用 babel 转为 ES5&lt;/li&gt;
&lt;li&gt;使用 eslint 来做代码格式检查&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之前我几乎没有使用 Factory 这一层，全部业务逻辑都在 Controller 里面做，随着项目越来越大(有26个页面)，页面之间函数重复的情况很多，而且控制器太厚，可读性差，给维护带来了巨大的困难。在这次重构之中，我把全部的 HTTP 请求全部放在 Factory 实现，从而做到了以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数复用，多个控制器用一个 Factory，避免同个函数多次书写&lt;/li&gt;
&lt;li&gt;HTTP 请求返回 promise，结合 angular-promise-buttons 做到了按钮状态的自动变化以及过渡效果，去掉了先前实现同样目的的全部辅助变量&lt;/li&gt;
&lt;li&gt;对部分相对不变的数据，在第一次缓存后直接在该 Factory 进行缓存，第二次获取的时候直接返回内存中的数据，加快了部分页面的二次加载速度，对跨页面你的同个请求同样有效&lt;/li&gt;
&lt;li&gt;容易做单元测试和更改逻辑，因为全部 HTTP 请求都放在 Factory 实现，对后期修改以及代码测试都带来了很大的方便&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Angular" scheme="https://ruiming.github.io/categories/Angular/"/>
    
    
      <category term="Angular" scheme="https://ruiming.github.io/tags/Angular/"/>
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 闭包，继承与原型链</title>
    <link href="https://ruiming.github.io/2016/07/22/JavaScript%E9%97%AD%E5%8C%85%EF%BC%8C%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://ruiming.github.io/2016/07/22/JavaScript闭包，继承与原型链/</id>
    <published>2016-07-22T07:03:23.000Z</published>
    <updated>2016-08-04T09:04:04.000Z</updated>
    
    <content type="html"><![CDATA[<p> JavaScript 闭包和原型链学习心得，如果有不对的地方望指出。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>什么是闭包，有很多说法，我的理解是一个函数可以记住和使用外部变量，保存这个变量的引用在自己的一个环境之中。<br>例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x + y;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> add5 = makeAdder(<span class="number">5</span>);</div><div class="line"><span class="keyword">var</span> add10 = makeAdder(<span class="number">10</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(add5(<span class="number">2</span>));  <span class="comment">// 7</span></div><div class="line"><span class="built_in">console</span>.log(add10(<span class="number">2</span>)); <span class="comment">// 12</span></div></pre></td></tr></table></figure></p>
<p>这个例子中， makeAdder 是一个函数工厂，add5 和 add10 就是闭包，他们记住了外部变量 x。通常一个函数执行完毕后其运行期上下文会被释放，但由于闭包的属性包含了与运行期上下文作用域链相同的对象引用，导致这个激活对象无法销毁，这就会导致内存消耗，另外，闭包内部的作用域链并不处在闭包作用域链的前端，并且闭包经常使用外部变量的话，导致对象属性的遍历经常到其原型上面去（一个解决方法是把他赋值到闭包自身的作用域上面），从而增加性能消耗。<br>既然闭包会导致内存增加和性能消耗，那为什么那么多人还使用它呢？上面的例子可能不太能说明问题，我们看下其他例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Counter = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeBy</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">    privateCounter += val;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      changeBy(<span class="number">1</span>);</div><div class="line">    &#125;,</div><div class="line">    decrement: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      changeBy(<span class="number">-1</span>);</div><div class="line">    &#125;,</div><div class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> privateCounter;</div><div class="line">    &#125;</div><div class="line">  &#125;   </div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(Counter.value()); <span class="comment">/* logs 0 */</span></div><div class="line">Counter.increment();</div><div class="line">Counter.increment();</div><div class="line"><span class="built_in">console</span>.log(Counter.value()); <span class="comment">/* logs 2 */</span></div><div class="line">Counter.decrement();</div><div class="line"><span class="built_in">console</span>.log(Counter.value()); <span class="comment">/* logs 1 */</span></div></pre></td></tr></table></figure></p>
<p>这个例子中外部只能通过 value 方法获取 privateCounter 的值，只能通过 increment 和 decrement 方法来改变 privateCounter 的值，无法直接获取到 priavateCounter 和调用 changeBy 函数。这种模式叫 module模式，因为大部分模块都是这样写的，包括 Underscore 也是这样。上篇中就说道了 Underscore 使用了立即执行函数，其用途其一是为了不污染外部变量，因为 JavaScript 是函数作用域，其次它利用了闭包的特性又可以保持函数内部闭包的可调用和被闭包所引用变量在闭包环境中的存在，同时函数内部可以定义一些私有变量和私有方法。我们无需担心这些变量和函数在外部函数执行完毕结束后的失效。<br>当你看到函数里面又 return 函数时，同时该函数又使用了外部变量，则该函数就是一个闭包。<br>关于闭包还有一个很容易犯错的地方，比如你想实现第一秒输出1,第二秒输出2,以此类推。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(i);</div><div class="line">    &#125;, i*<span class="number">1000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是实际运行结果是第一秒输出6,第二秒输出6…<br>闭包是记住了外部变量的引用，每次循环都建立了一个 timer 函数，但 console 并还没有被执行，当循环结束后确实是建立了5个计时器或者说5个闭包，但当开始执行 console 的时候，由于这些闭包所引用的 i 此时结果为6，所以会输出5次 6。<br>更能说明问题些，我们稍作修改下：<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(i);</div><div class="line">        i++;</div><div class="line">    &#125;, i*<span class="number">1000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果是第一秒输出1，第二秒输出2…<br>我们也可以这么做<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">    <span class="keyword">let</span> j = i;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(j);</div><div class="line">    &#125;, j*<span class="number">1000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果和上面一样，第一秒输出1，第二秒输出2…<br>这是为什么呢？第二个例子说明了闭包使用的是外部变量的引用，他们都使用了同一个引用，所以最终输出取决与此时这个引用的值。第三个例子，每次循环都会新建一个变量 j，分别被每个闭包所引用，这些引用互不干扰，我们可以在 console.log(j) 后面加上 j++，结果是不会有变化的。</p>
<h2 id="继承与原型链"><a href="#继承与原型链" class="headerlink" title="继承与原型链"></a>继承与原型链</h2><blockquote>
<p>在 javaScript 中，每个对象都有一个指向它的原型（prototype）对象的内部链接。这个原型对象又有自己的原型，直到某个对象的原型为 null 为止（也就是不再有原型指向），组成这条链的最后一环。这种一级一级的链结构就称为原型链（prototype chain）。</p>
</blockquote>
<p>第一次接触 JavaScript 的原型链是在使用 Angular 的时候，如果有看到前面我的一篇写 Angular 的就会看到。在使用 Angular 的 ngIf 和 textarea 时，会创建新的子作用域，子作用域的原型是父级作用域一般就是 scope，以 textarea 为例子，假设一个用户修改评论的 textarea 框，我们首先把原先的评论写了回去，假设我们这样使用<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">ng-model</span>=<span class="string">"content"</span>, <span class="attr">name</span>=<span class="string">"content"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">row</span>=<span class="string">"3"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>我们把用户的评论内容放到 $scope.content 里面去。<br>结果是我们可以看到 textarea 确实一开始就被填入了用户原先的评论，可是如果此时我们更改 textarea 内部的内容，然后提交修改。你会发现 $scope.content 没有发生变化。<br>这是因为 Angular 默认在 textarea 创建了一个新的子作用域，这个作用域本身一开始并不存在 content 这个值，即没有 hasOwnProperty(‘content’)，但他并不会因此就不做显示了，他会去找其原型，一般是 scope (如果在 ng-if 使用了 textarea，则其原型的原型才是 scope )，如果原型存在 content 则继承原型。所以你会看到初始状态是没问题的，当你修改评论内容时候，此时 textarea 自身的作用与就会新建了一个 content，内容就为你的评论内容，而其原型的 scope 将不再被使用，也不会被修改，所以你会发现 $scope.content 并没有发生变化。<br>如果 textarea 的原型也不存在 content，它会再往上找，直到原型链最顶端为止，处在原型链最顶端的对象的原型是 null。<br>以 Angular 的这个例子，我们就介绍完了 JavaScript 的原型链和继承，我们再举个例子说明下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stu = &#123;name: <span class="string">"stu"</span>, age: <span class="number">18</span>, school: <span class="string">"SCNU"</span>&#125;;</div><div class="line"><span class="keyword">var</span> father = &#123;name: <span class="string">"parent"</span>, age: <span class="number">40</span>, job: <span class="string">"engineer"</span>, company: <span class="string">"Google"</span>&#125;;</div><div class="line">stu.__proto__ = father;</div><div class="line"><span class="built_in">console</span>.log(stu.job)    <span class="comment">/* logs "engineer" */</span></div><div class="line">stu.job = <span class="string">"student"</span></div><div class="line"><span class="built_in">console</span>.log(stu.job)    <span class="comment">/* logs "student" */</span></div><div class="line"><span class="built_in">console</span>.log(father.job) <span class="comment">/* logs "engineer" */</span></div><div class="line"><span class="keyword">for</span>( prop <span class="keyword">in</span> stu ) &#123;</div><div class="line">    <span class="built_in">console</span>.log(stu.prop);  <span class="comment">/* logs stu, 18, SCNU, student, Google */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用for…in…会遍历对象的所有属性，一个解决方法是使用 hasOwnProperty 判断是否是该层的属性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; JavaScript 闭包和原型链学习心得，如果有不对的地方望指出。&lt;/p&gt;
&lt;h2 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;闭包&lt;/h2&gt;&lt;p&gt;什么是闭包，有很多说法，我的理解是一个函数可以记住和使用外部变量，保存这个变量的引用在自己的一个环境之中。&lt;br&gt;例如：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;makeAdder&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;y&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x + y;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; add5 = makeAdder(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; add10 = makeAdder(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(add5(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));  &lt;span class=&quot;comment&quot;&gt;// 7&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(add10(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)); &lt;span class=&quot;comment&quot;&gt;// 12&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个例子中， makeAdder 是一个函数工厂，add5 和 add10 就是闭包，他们记住了外部变量 x。通常一个函数执行完毕后其运行期上下文会被释放，但由于闭包的属性包含了与运行期上下文作用域链相同的对象引用，导致这个激活对象无法销毁，这就会导致内存消耗，另外，闭包内部的作用域链并不处在闭包作用域链的前端，并且闭包经常使用外部变量的话，导致对象属性的遍历经常到其原型上面去（一个解决方法是把他赋值到闭包自身的作用域上面），从而增加性能消耗。&lt;br&gt;既然闭包会导致内存增加和性能消耗，那为什么那么多人还使用它呢？上面的例子可能不太能说明问题，我们看下其他例子。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; Counter = (&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; privateCounter = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;changeBy&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;val&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    privateCounter += val;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    increment: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      changeBy(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    decrement: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      changeBy(&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    value: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; privateCounter;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;   &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(Counter.value()); &lt;span class=&quot;comment&quot;&gt;/* logs 0 */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Counter.increment();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Counter.increment();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(Counter.value()); &lt;span class=&quot;comment&quot;&gt;/* logs 2 */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Counter.decrement();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(Counter.value()); &lt;span class=&quot;comment&quot;&gt;/* logs 1 */&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个例子中外部只能通过 value 方法获取 privateCounter 的值，只能通过 increment 和 decrement 方法来改变 privateCounter 的值，无法直接获取到 priavateCounter 和调用 changeBy 函数。这种模式叫 module模式，因为大部分模块都是这样写的，包括 Underscore 也是这样。上篇中就说道了 Underscore 使用了立即执行函数，其用途其一是为了不污染外部变量，因为 JavaScript 是函数作用域，其次它利用了闭包的特性又可以保持函数内部闭包的可调用和被闭包所引用变量在闭包环境中的存在，同时函数内部可以定义一些私有变量和私有方法。我们无需担心这些变量和函数在外部函数执行完毕结束后的失效。&lt;br&gt;当你看到函数里面又 return 函数时，同时该函数又使用了外部变量，则该函数就是一个闭包。&lt;br&gt;关于闭包还有一个很容易犯错的地方，比如你想实现第一秒输出1,第二秒输出2,以此类推。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt;= &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;timer&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(i);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;, i*&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但是实际运行结果是第一秒输出6,第二秒输出6…&lt;br&gt;闭包是记住了外部变量的引用，每次循环都建立了一个 timer 函数，但 console 并还没有被执行，当循环结束后确实是建立了5个计时器或者说5个闭包，但当开始执行 console 的时候，由于这些闭包所引用的 i 此时结果为6，所以会输出5次 6。&lt;br&gt;更能说明问题些，我们稍作修改下：&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://ruiming.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Underscore 源码学习(一)</title>
    <link href="https://ruiming.github.io/2016/07/20/Underscore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"/>
    <id>https://ruiming.github.io/2016/07/20/Underscore源码学习(一)/</id>
    <published>2016-07-20T07:52:11.000Z</published>
    <updated>2016-08-04T09:12:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>暑假打算研究一下 Underscore 源码，我会对一些我觉得比较有意思的点拿出来讨论下，不过我不会过多介绍，也不会去分析 Underscore 的各个方法，但我会附上一些相关的不错的参考资料。由于我也是初学阶段，所以如果有说的不正确的地方望指出。</p>
<h2 id="要点1：立即执行函数"><a href="#要点1：立即执行函数" class="headerlink" title="要点1：立即执行函数"></a>要点1：立即执行函数</h2><p>Underscore 的内容都用这么一个东西包装起来了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;..&#125;());</div></pre></td></tr></table></figure></p>
<p>其实也可以这样写<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)();</div></pre></td></tr></table></figure></p>
<p>Underscore 把全部内容封装在立即执行函数里面，就形成了一个独立的作用域，与外部隔离，并且这样做还形成了闭包，可以模拟私有方法。<br>推荐阅读：</p>
<ul>
<li><a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/" target="_blank" rel="external">immediately-invoked-function-expression(英)</a></li>
<li><a href="http://www.cnblogs.com/tomxu/archive/2011/12/31/2289423.html" target="_blank" rel="external">immediately-invoked-function-expression(中)</a></li>
<li><a href="https://segmentfault.com/a/1190000003902899" target="_blank" rel="external">JavaScript中的立即执行函数</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" target="_blank" rel="external">Closures</a></li>
</ul>
<h2 id="要点2：兼容浏览器和-Node-环境"><a href="#要点2：兼容浏览器和-Node-环境" class="headerlink" title="要点2：兼容浏览器和 Node 环境"></a>要点2：兼容浏览器和 Node 环境</h2><p>浏览器和服务端的一个主要区别是全局对象命名的不同，在浏览器全局变量是 window，在服务端即 Node 环境则是 global。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> root = <span class="keyword">typeof</span> self == <span class="string">'object'</span> &amp;&amp; self.self === self &amp;&amp; self ||</div><div class="line">           <span class="keyword">typeof</span> global == <span class="string">'object'</span> &amp;&amp; global.global === global &amp;&amp; global ||</div><div class="line">           <span class="keyword">this</span>;</div></pre></td></tr></table></figure></p>
<p>这个地方之前的写法是这样的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> root = <span class="keyword">this</span>;</div></pre></td></tr></table></figure></p>
<p>我认为之所以改成前面那种写法，可能是为了确保 root 指向 global 或者 window(self) 。大部分框架和库都采用这种做法，这种做法更加安全。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这一步确保self是一个object，这样self.self才不会出错</span></div><div class="line"><span class="keyword">typeof</span> self == <span class="string">'object'</span></div><div class="line"><span class="comment">// 这一步确保self.self严格等于自身，貌似只有window具备这个特性</span></div><div class="line"><span class="comment">// 即window === window.window.window</span></div><div class="line">self.self === self</div><div class="line"><span class="comment">// 为什么还要进行这一步？</span></div><div class="line">self</div></pre></td></tr></table></figure></p>
<p>推荐阅读：</p>
<ul>
<li><a href="https://zzz.buzz/2016/06/30/the-global-object-in-various-javascript-environments/" target="_blank" rel="external">The Global Object in Various JavaScript Environments</a></li>
</ul>
<h2 id="要点3：提供命名冲突解决方法"><a href="#要点3：提供命名冲突解决方法" class="headerlink" title="要点3：提供命名冲突解决方法"></a>要点3：提供命名冲突解决方法</h2><p>Underscore 在给 root 赋值前，先保存了原先 root 的 <code>_</code> 对象。之所以这样做，是因为可能我们用的其他库也使用了 <code>_</code> 这个作为命名空间。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> previousUnderscore = root._;</div></pre></td></tr></table></figure></p>
<p>我们结合 Underscore 最下面的这个方法来看。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_.noConflict = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    root._ = previousUnderscore;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>如果 <code>_</code> 出现了冲突，可以使用下面方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _new = _.noConflict();</div></pre></td></tr></table></figure></p>
<p>这样一来应该很明显了，<code>noConflict</code> 将 <code>previousUnderscore</code> 即原先的 <code>root._</code> 重新放回去，然后重新定义 Underscore 命名给 <code>_new</code>，这样就解决了 <code>_</code> 冲突问题。</p>
<a id="more"></a>
<h2 id="要点4：考虑压缩问题"><a href="#要点4：考虑压缩问题" class="headerlink" title="要点4：考虑压缩问题"></a>要点4：考虑压缩问题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ArrayProto = <span class="built_in">Array</span>.prototype, ObjProto = <span class="built_in">Object</span>.prototype;</div><div class="line"><span class="keyword">var</span> SymbolProto = <span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">'undefined'</span> ? <span class="built_in">Symbol</span>.prototype : <span class="literal">null</span>;</div><div class="line"><span class="keyword">var</span> push = ArrayProto.push,</div><div class="line">    slice = ArrayProto.slice,</div><div class="line">    toString = ObjProto.toString,</div><div class="line">    hasOwnProperty = ObjProto.hasOwnProperty;</div></pre></td></tr></table></figure>
<p>这里首先说一下<code>Symbol</code>，ES5 规定了六种语言类型即 Null, Undefined, Number, Boolean, String, Object，而新出台的 ES6 则新增了 Symbol。关于 Symbol 查看推荐阅读。<br>这里把 Array 和 Object 和 Symbol 的原型都用变量来引用的原因是变量可以进行压缩，如果有使用过代码压缩工具的话，一个常见的压缩技巧就是用短变量名代替长变量名，而对于一些出现频率高的方法我们可以用变量来进行引用来便于压缩。<br>而 push, slice, toString, hasOwnProperty 这些引用不仅便于压缩，还可以减少在原型链中的查找次数，提高速度。即直接在原型上操作，避免原型链查找。关于原型链是个大问题了，这里不打算过多讲解（其实是我也不怎么懂），下一篇再进行介绍。<br>还有一个地方顺便提一下的是，Underscore 的源码不使用 undefined 而是使用 <code>void  0</code>。这个也是代码压缩的时候会做的事情。虽然从 ES5 开始 undefined 是全局对象的只读属性不能重写，但是在局部作用域中仍然可以被重写，而 <code>void</code> 运算符能对给定的表达式进行求值，然后返回 undefined，可以保证返回的是 undefined，<code>void</code>不能重写。再者，之所以跟的是0，只是因为0短并且习惯问题而已。<br>推荐阅读：</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/void" target="_blank" rel="external">operators-void</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank" rel="external">Symbol</a></li>
</ul>
<h2 id="要点5：区别apply-call和bind"><a href="#要点5：区别apply-call和bind" class="headerlink" title="要点5：区别apply, call和bind"></a>要点5：区别apply, call和bind</h2><p>在 Underscore 源码中我们会经常看到 apply 和 call 的应用。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (startIndex) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> func.call(<span class="keyword">this</span>, rest);</div><div class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> func.call(<span class="keyword">this</span>, <span class="built_in">arguments</span>[<span class="number">0</span>], rest);</div><div class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> func.call(<span class="keyword">this</span>, <span class="built_in">arguments</span>[<span class="number">0</span>], <span class="built_in">arguments</span>[<span class="number">1</span>], rest);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> args = <span class="built_in">Array</span>(startIndex + <span class="number">1</span>);</div><div class="line"><span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; startIndex; index++) &#123;</div><div class="line">    args[index] = <span class="built_in">arguments</span>[index];</div><div class="line">&#125;</div><div class="line">args[startIndex] = rest;</div><div class="line"><span class="keyword">return</span> func.apply(<span class="keyword">this</span>, args);</div></pre></td></tr></table></figure></p>
<p>apply 和 call 都是为了改变某个函数运行时的 context 即上下文而存在的，即改变函数提内部 this 的指向，他们的功能是相同的，只是用法稍有不同。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func1 = <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123;&#125;;</div><div class="line"><span class="comment">// 可以通过下面两个方法来调用</span></div><div class="line">func1.call(<span class="keyword">this</span>, arg1, arg2);</div><div class="line">func1.apply(<span class="keyword">this</span>, [arg1, arg2]);</div></pre></td></tr></table></figure></p>
<p>即 call 传递的是参数列表，而 apply 传递的是数组，当我们知道参数的数量时使用 call 方法，不知道参数数量时可以把参数放到一个数组然后使用 apply 方法调用。bind 也可以更改函数执行的上下文但是不同的是，bind 只进行绑定不会立即调用。<br>再看看上面 Underscore 源码中的一部分，对于<code>startIndex</code>小于3的情况，他分别使用了 call 方法调用，而当<code>startIndex</code>大于3的时候，则将参数转为数组形式使用 apply 方式调用。为什么不直接用 apply 方法呢？<br>简而言之，apply 比 call 慢。<br>对于 apply 方法，Function 会检查传入的参数的类型是否符合要求，还要进行解构操作等等。所以应该尽量使用 call 方法。<br>Underscore 源码关于这段代码还有个地方值得注意<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">startIndex = startIndex == <span class="literal">null</span> ? func.length - <span class="number">1</span> : +startIndex;</div></pre></td></tr></table></figure></p>
<p>为什么使用 <code>+startIndex</code>？<br><code>+</code>运算符尝试将后面的数转为数字，例如将字符串(“123”)转为数(123)，对数字不会产生影响，如果传入(“123NASD”)，会得到 NaN 。<br>推荐阅读：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/23769556/why-is-call-so-much-faster-than-apply/23770316#23770316" target="_blank" rel="external">why-is-call-so-much-faster-than-apply</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;暑假打算研究一下 Underscore 源码，我会对一些我觉得比较有意思的点拿出来讨论下，不过我不会过多介绍，也不会去分析 Underscore 的各个方法，但我会附上一些相关的不错的参考资料。由于我也是初学阶段，所以如果有说的不正确的地方望指出。&lt;/p&gt;
&lt;h2 id=&quot;要点1：立即执行函数&quot;&gt;&lt;a href=&quot;#要点1：立即执行函数&quot; class=&quot;headerlink&quot; title=&quot;要点1：立即执行函数&quot;&gt;&lt;/a&gt;要点1：立即执行函数&lt;/h2&gt;&lt;p&gt;Underscore 的内容都用这么一个东西包装起来了。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;..&amp;#125;());&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其实也可以这样写&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&amp;#125;)();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Underscore 把全部内容封装在立即执行函数里面，就形成了一个独立的作用域，与外部隔离，并且这样做还形成了闭包，可以模拟私有方法。&lt;br&gt;推荐阅读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://benalman.com/news/2010/11/immediately-invoked-function-expression/&quot;&gt;immediately-invoked-function-expression(英)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/tomxu/archive/2011/12/31/2289423.html&quot;&gt;immediately-invoked-function-expression(中)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000003902899&quot;&gt;JavaScript中的立即执行函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures&quot;&gt;Closures&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;要点2：兼容浏览器和-Node-环境&quot;&gt;&lt;a href=&quot;#要点2：兼容浏览器和-Node-环境&quot; class=&quot;headerlink&quot; title=&quot;要点2：兼容浏览器和 Node 环境&quot;&gt;&lt;/a&gt;要点2：兼容浏览器和 Node 环境&lt;/h2&gt;&lt;p&gt;浏览器和服务端的一个主要区别是全局对象命名的不同，在浏览器全局变量是 window，在服务端即 Node 环境则是 global。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; root = &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; self == &lt;span class=&quot;string&quot;&gt;&#39;object&#39;&lt;/span&gt; &amp;amp;&amp;amp; self.self === self &amp;amp;&amp;amp; self ||&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; global == &lt;span class=&quot;string&quot;&gt;&#39;object&#39;&lt;/span&gt; &amp;amp;&amp;amp; global.global === global &amp;amp;&amp;amp; global ||&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个地方之前的写法是这样的&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; root = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我认为之所以改成前面那种写法，可能是为了确保 root 指向 global 或者 window(self) 。大部分框架和库都采用这种做法，这种做法更加安全。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 这一步确保self是一个object，这样self.self才不会出错&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; self == &lt;span class=&quot;string&quot;&gt;&#39;object&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 这一步确保self.self严格等于自身，貌似只有window具备这个特性&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 即window === window.window.window&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;self.self === self&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 为什么还要进行这一步？&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;self&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zzz.buzz/2016/06/30/the-global-object-in-various-javascript-environments/&quot;&gt;The Global Object in Various JavaScript Environments&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;要点3：提供命名冲突解决方法&quot;&gt;&lt;a href=&quot;#要点3：提供命名冲突解决方法&quot; class=&quot;headerlink&quot; title=&quot;要点3：提供命名冲突解决方法&quot;&gt;&lt;/a&gt;要点3：提供命名冲突解决方法&lt;/h2&gt;&lt;p&gt;Underscore 在给 root 赋值前，先保存了原先 root 的 &lt;code&gt;_&lt;/code&gt; 对象。之所以这样做，是因为可能我们用的其他库也使用了 &lt;code&gt;_&lt;/code&gt; 这个作为命名空间。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; previousUnderscore = root._;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们结合 Underscore 最下面的这个方法来看。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;_.noConflict = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    root._ = previousUnderscore;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;_&lt;/code&gt; 出现了冲突，可以使用下面方法&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; _new = _.noConflict();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这样一来应该很明显了，&lt;code&gt;noConflict&lt;/code&gt; 将 &lt;code&gt;previousUnderscore&lt;/code&gt; 即原先的 &lt;code&gt;root._&lt;/code&gt; 重新放回去，然后重新定义 Underscore 命名给 &lt;code&gt;_new&lt;/code&gt;，这样就解决了 &lt;code&gt;_&lt;/code&gt; 冲突问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Underscore" scheme="https://ruiming.github.io/categories/Underscore/"/>
    
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="Underscore" scheme="https://ruiming.github.io/tags/Underscore/"/>
    
  </entry>
  
  <entry>
    <title>ARP 攻击和无线网卡混杂模式</title>
    <link href="https://ruiming.github.io/2016/07/14/ARP%E6%94%BB%E5%87%BB%E5%92%8C%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://ruiming.github.io/2016/07/14/ARP攻击和无线网卡混杂模式/</id>
    <published>2016-07-14T04:32:41.000Z</published>
    <updated>2016-08-04T09:05:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>一次小小的 Hack 尝试…<br>前段时间换上了 Arch，就开始想这捣鼓一些黑科技。脑海中立即浮现出两个词， monitor 和 ARP 。</p>
<h2 id="ARP-攻击"><a href="#ARP-攻击" class="headerlink" title="ARP 攻击"></a>ARP 攻击</h2><p>学过计算机网络了，大概了解ARP攻击这么一回事，但是当我真正去试的时候，才发现局域网原来真的这么脆弱，因为进行ARP攻击实在太容易了。实际上就是几条命令的事情。</p>
<h3 id="主机发现和端口扫描"><a href="#主机发现和端口扫描" class="headerlink" title="主机发现和端口扫描"></a>主机发现和端口扫描</h3><p>进行攻击第一步当然就是找目标了。可以使用 nmap 这个工具来进行，这东西简直渗透利器。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nmap -sP <span class="number">192.168</span><span class="number">.1</span><span class="number">.0</span>/<span class="number">24</span></div></pre></td></tr></table></figure></p>
<p> 这样就可以扫描192.168.1.0这个网段里面的所有主机了，以 ping 方式扫描，当然他有很多参数很多用法，网上很多这方面的资料我就不叙述了。<br><img src="/2016/07/14/ARP攻击和无线网卡混杂模式/nmap.png" alt="Nmap扫描" title="Nmap扫描"></p>
<h3 id="发起攻击"><a href="#发起攻击" class="headerlink" title="发起攻击"></a>发起攻击</h3><p>如果是进行ARP攻击，那也是加多三条命令就搞定的事情。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> 1 &gt;&gt; /proc/sys/net/ipv4/ip_forward</div><div class="line">arpspoof -i wlp3s0 -t 192.168.1.110 192.168.1.1</div><div class="line">arpspoof -i wlp3s0 -t 192.168.1.1   192.168.1.110</div></pre></td></tr></table></figure></p>
<p>第一条是开启转发，不然会受害者流量到我们这里出不去就断网了。<br>第二条是告诉受害者说我是网管。<br>第三条是告诉网管我是受害者。<br>这样就完成了 ARP 欺骗，图片以后再补。这之后对方的网络就完全在你的监控之下了。这告诉我们使用 https 和不连接免费 wifi 的重要性!</p>
<h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><p>抓包推荐使用 wireshark 。具体就不介绍了=.=。你还可以使用 Driftnet 这东西来将对方访问的图片在你这边显示出来～</p>
<h2 id="监听空气包"><a href="#监听空气包" class="headerlink" title="监听空气包"></a>监听空气包</h2><p>大部分无线网卡都可以设置 monitor 模式，即无线网卡默认接受下全部经过他的以太网帧而不丢弃，这种方式可以抓到附近范围里面的所以以太网帧。在 Arch 下也是三条命令搞定的事情。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ifconfig wlp3s0 down</div><div class="line">iwconfig wlp3s0 mode monitor</div><div class="line">ifconfig wlp3s0 up</div></pre></td></tr></table></figure></p>
<p>接着同样开启 wireshark 抓包，你会发现很多802.11帧，不过这个并没有什么卵用，理论上应该对于没有加密的帧应该可以直接得到应用层报文才对，但是很奇怪我一直抓不到，即使是对于有加密的 Wifi，我填入 WAPKEY 解密也不行。这个有待继续研究。。。<br><a id="more"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一次小小的 Hack 尝试…&lt;br&gt;前段时间换上了 Arch，就开始想这捣鼓一些黑科技。脑海中立即浮现出两个词， monitor 和 ARP 。&lt;/p&gt;
&lt;h2 id=&quot;ARP-攻击&quot;&gt;&lt;a href=&quot;#ARP-攻击&quot; class=&quot;headerlink&quot; title=&quot;ARP 攻击&quot;&gt;&lt;/a&gt;ARP 攻击&lt;/h2&gt;&lt;p&gt;学过计算机网络了，大概了解ARP攻击这么一回事，但是当我真正去试的时候，才发现局域网原来真的这么脆弱，因为进行ARP攻击实在太容易了。实际上就是几条命令的事情。&lt;/p&gt;
&lt;h3 id=&quot;主机发现和端口扫描&quot;&gt;&lt;a href=&quot;#主机发现和端口扫描&quot; class=&quot;headerlink&quot; title=&quot;主机发现和端口扫描&quot;&gt;&lt;/a&gt;主机发现和端口扫描&lt;/h3&gt;&lt;p&gt;进行攻击第一步当然就是找目标了。可以使用 nmap 这个工具来进行，这东西简直渗透利器。&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;nmap -sP &lt;span class=&quot;number&quot;&gt;192.168&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.0&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt; 这样就可以扫描192.168.1.0这个网段里面的所有主机了，以 ping 方式扫描，当然他有很多参数很多用法，网上很多这方面的资料我就不叙述了。&lt;br&gt;&lt;img src=&quot;/2016/07/14/ARP攻击和无线网卡混杂模式/nmap.png&quot; alt=&quot;Nmap扫描&quot; title=&quot;Nmap扫描&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;发起攻击&quot;&gt;&lt;a href=&quot;#发起攻击&quot; class=&quot;headerlink&quot; title=&quot;发起攻击&quot;&gt;&lt;/a&gt;发起攻击&lt;/h3&gt;&lt;p&gt;如果是进行ARP攻击，那也是加多三条命令就搞定的事情。&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; 1 &amp;gt;&amp;gt; /proc/sys/net/ipv4/ip_forward&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;arpspoof -i wlp3s0 -t 192.168.1.110 192.168.1.1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;arpspoof -i wlp3s0 -t 192.168.1.1   192.168.1.110&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;第一条是开启转发，不然会受害者流量到我们这里出不去就断网了。&lt;br&gt;第二条是告诉受害者说我是网管。&lt;br&gt;第三条是告诉网管我是受害者。&lt;br&gt;这样就完成了 ARP 欺骗，图片以后再补。这之后对方的网络就完全在你的监控之下了。这告诉我们使用 https 和不连接免费 wifi 的重要性!&lt;/p&gt;
&lt;h3 id=&quot;抓包&quot;&gt;&lt;a href=&quot;#抓包&quot; class=&quot;headerlink&quot; title=&quot;抓包&quot;&gt;&lt;/a&gt;抓包&lt;/h3&gt;&lt;p&gt;抓包推荐使用 wireshark 。具体就不介绍了=.=。你还可以使用 Driftnet 这东西来将对方访问的图片在你这边显示出来～&lt;/p&gt;
&lt;h2 id=&quot;监听空气包&quot;&gt;&lt;a href=&quot;#监听空气包&quot; class=&quot;headerlink&quot; title=&quot;监听空气包&quot;&gt;&lt;/a&gt;监听空气包&lt;/h2&gt;&lt;p&gt;大部分无线网卡都可以设置 monitor 模式，即无线网卡默认接受下全部经过他的以太网帧而不丢弃，这种方式可以抓到附近范围里面的所以以太网帧。在 Arch 下也是三条命令搞定的事情。&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ifconfig wlp3s0 down&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iwconfig wlp3s0 mode monitor&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ifconfig wlp3s0 up&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;接着同样开启 wireshark 抓包，你会发现很多802.11帧，不过这个并没有什么卵用，理论上应该对于没有加密的帧应该可以直接得到应用层报文才对，但是很奇怪我一直抓不到，即使是对于有加密的 Wifi，我填入 WAPKEY 解密也不行。这个有待继续研究。。。&lt;br&gt;
    
    </summary>
    
      <category term="网络安全" scheme="https://ruiming.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Hack" scheme="https://ruiming.github.io/tags/Hack/"/>
    
  </entry>
  
  <entry>
    <title>从输入 URL 到页面展示</title>
    <link href="https://ruiming.github.io/2016/06/24/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA/"/>
    <id>https://ruiming.github.io/2016/06/24/从输入URL到页面展示/</id>
    <published>2016-06-24T07:43:38.000Z</published>
    <updated>2016-08-04T09:20:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文从网络层以上讨论从浏览器输入 HTTPS 协议的 URL 到页面展现的全过程。由于不同浏览器之间也存在差异，这里以 Chrome 浏览器为例。</p>
<h2 id="1-DNS查询"><a href="#1-DNS查询" class="headerlink" title="1. DNS查询"></a>1. <a name="DNS-0"></a>DNS查询</h2><p>DNS 缓存有好几个环节，浏览器缓存，系统缓存，路由器缓存，ISP 缓存。</p>
<ul>
<li><p>浏览器首先会查看自身是否已经有进行 DNS 缓存。Chrome 可以通过 <code>chrome://net-internals/#dns</code> 查看缓存的 DNS，浏览器的 DNS 缓存可以加快 DNS 解析速度，但缓存时间不会太长。</p>
<img src="/2016/06/24/从输入URL到页面展示/chrome-dns-cache.png" alt="Chrome 的 DNS 缓存" title="Chrome 的 DNS 缓存">
</li>
<li><p>如果浏览器没有相应的缓存，则查找系统缓存，浏览器会向系统发送一个查询请求，如果系统存在缓存或者设置了 host ，则返回相应的 ip 地址给浏览器。</p>
</li>
<li><p>如果系统没有缓存，那么它会发出一个 DNS 查询请求给路由器。</p>
<p>如果路由器有 DNS 缓存，他会提取出 IP 地址返回。否则，他会向本地域名服务器发出查询，从请求主机到本地域名服务器的请求一般是递归查询，而其他的查询一般是迭代查询。</p>
<img src="/2016/06/24/从输入URL到页面展示/client-to-server-query.gif" alt="DNS 请求主机到本地域名服务器的查询" title="DNS 请求主机到本地域名服务器的查询">
<img src="/2016/06/24/从输入URL到页面展示/server-to-server-query.gif" alt="DNS 域名服务器之间的查询" title="DNS 域名服务器之间的查询">
<p>请求报文如下</p>
<img src="/2016/06/24/从输入URL到页面展示/dns-request-1.png" alt="DNS 请求报文" title="DNS 请求报文">
<p>我们先简单分析下请求报文。</p>
<ol>
<li>DNS 使用 UDP 协议，端口号53。</li>
<li>在 DNS 报文的 Flags 中的 RD=1。表示它建议域名服务器以递归方式查询。</li>
<li>Question section format 需要给出 <code>QNAME</code>, <code>QTYPE</code>, <code>QCLASS</code>。即查询的域名，查询的类型以及查询的类。</li>
</ol>
<p>有关<code>DNS</code>报文的更多信息可以参考<a href="https://www.ietf.org/rfc/rfc1035" target="_blank" rel="external">RFC1035</a></p>
<p>响应报文如下</p>
<img src="/2016/06/24/从输入URL到页面展示/dns-response-1.png" alt="DNS 响应报文" title="DNS 响应报文">
<p>我们也简单分析下，如果想详细了解，可以查看上面的 <code>RFC1035</code> 标准。</p>
<ol>
<li>与请求报文相比，对比 Flags 可以发现，QR=1 表示这是一个响应报文。RA=1 表示递归查询可用。</li>
<li>ARecord 记录了DNS请求获得的一个或多个IP地址。一般还会得到 CNAME 记录和存活时间等信息。</li>
<li>这里对 Rcode 也稍加说明下，Rcode=0 表示成功，他还有好几种状态码，比如1表示 <code>Format error</code>，2表示 <code>Server failure</code>，3表示 <code>Name error</code>，4表示 <code>Not lmplemented</code>，5表示 <code>Refused</code>，具体信息可以参考 <code>RFC1035</code>。</li>
</ol>
</li>
</ul>
<a id="more"></a>
<h2 id="2-三次握手建立连接"><a href="#2-三次握手建立连接" class="headerlink" title="2. 三次握手建立连接"></a>2. <a name="-1"></a>三次握手建立连接</h2><p>经过上述过程，此时浏览器得到了要访问的域名的 IP 地址。由于 DNS 查询需要一定时间，所以有些网站会使用 DNS Prefetching 进行 DNS 预解析，结合浏览器的 DNS 缓存，以加快网站速度。这里不做详细叙述。</p>
<p>首先贴出 TCP 三次握手的建立图。</p>
<img src="/2016/06/24/从输入URL到页面展示/tcp-shake-hands.jpg" alt="三次握手" title="三次握手">
<p>我们抓包依次进行分析。</p>
<ol>
<li><p>第一个握手包</p>
<img src="/2016/06/24/从输入URL到页面展示/tcp-shake-hands-1.png" alt="第一个握手包" title="第一个握手包">
<p>从这个包我们可以得到以下信息:</p>
<ul>
<li>Seq = 2988862522 这个是本报文段所发送的数据的第一个字节的序号</li>
<li><p>DataOffset = 32（字节） 指明 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远</p>
</li>
<li><p>SYN = 1 SYN=1 而 ACK=0 时表示这是一个连接请求报文。</p>
</li>
<li>Window = 8192（字节） 客户端滑动窗口8192字节，滑动窗口协议是设计来提高报文段的传输效率，这里不详细叙述，可以自己查资料。</li>
<li>Checksum = 0x5818 校验和，校验和字段校验的范围包括首部和数据这两个部分，在计算校验和时，要在 TCP 报文段的前面加上12字节的伪首部。接收方接收到此报文段后，加上这个伪首部来计算校验和。校验和是用来保证数据的无差错。</li>
<li>MaxSegmentSize = 1460（字节） 即 MSS，表示 TCP 报文段中数据字段的最大长度。注意它加上 TCP 首部才等于整个的 TCP 报文。有关 MSS 的信息自己查资料。</li>
</ul>
<p>比较重要的就是上述信息，客户端需要在第一次发包时要告知自身的一些信息。</p>
</li>
<li><p>第二个握手包</p>
<img src="/2016/06/24/从输入URL到页面展示/tcp-shake-hands-2.png" alt="第二个握手包" title="第二个握手包">
<p>在接收到客户端发来的握手包后，服务端进行应答，我们对这个包进行分析：</p>
<ul>
<li>Seq = 1648068786</li>
<li>Ack = 2988862523 表示服务端期望收到对方的下一个报文段的第一个数据字节的序号。</li>
<li>ACK = 1 当 ACK=1 时确认号字段有效。</li>
<li>SYN = 1 ACK=1 且 SYN=1 表示这是一个同意建立连接的响应报文。</li>
<li>Window = 63343（字节） 服务端的滑动窗口为63343字节。</li>
<li>MaxSegmentSize = 1448（字节） 服务端的 TCP 报文中数据字段的最大长度为1448字节。</li>
</ul>
<p>在前两次握手时，双方交换一些信息如 Window 和 MSS，确定 seq 和 ack 起始号。</p>
</li>
<li><p>第三个握手包</p>
<img src="/2016/06/24/从输入URL到页面展示/tcp-shake-hands-3.png" alt="第三个握手包" title="第三个握手包">
<p>服务端接受请求后，客户端还需要在发送一个握手包。这个握手包明显信息更少了，同样我们查看一些关键值：</p>
<ul>
<li>Seq = 2988862523 由于上一个握手包没有携带正文信息，不占用字节空间，所以 Seq 与上一个握手包的 Ack 值相同。</li>
<li>Ack = 1648068787 同上，双方建立通信之后是会进行数据交换，同样的，这个地方表示客户端期望收到对方的下一个报文段的第一个数据字节的序号。</li>
<li>ACK = 1 表示对上一个握手包的确认</li>
<li>Window = 260（字节） TCP 的发送窗口时会不断变化的，TCP 的流量控制和拥塞控制会根据情况动态地调整发送窗口上限值，从而控制发送数据的平均速率。</li>
</ul>
</li>
</ol>
<p>自此三次握手完成，连接建立，可以开始传输数据。</p>
<h2 id="3-建立HTTPS连接"><a href="#3-建立HTTPS连接" class="headerlink" title="3. 建立HTTPS连接"></a>3. <a name="HTTPS-2"></a>建立HTTPS连接</h2><p>以上完成握手，只能建立 HTTP 连接。但如果网站使用了 HTTPS 协议，那么还需要进行 SSL/TLS 握手。</p>
<p>在这之前，我们先介绍下 SSL/TLS。</p>
<p>SSL/TLS 是一种互联网安全加密技术。HTTP 报文是进行明文传输的，这意味着用户的 cookie 或者其提交的信息比如账号和密码都是在互联网上裸奔，如果这个报文被其他人抓取到，会带来很大的不安全性。使用 HTTPS 协议是非常有必要的，并且目前最新的 HTTP2 规范也仅支持 HTTPS。而 SSL/TLS 协议位于 TCP/IP 协议与各个应用层协议之间，为数据通信提供安全支持。他们可以分为记录协议和握手协议。</p>
<p>那么 SSL 和 TLS 又有什么区别呢？</p>
<p>简单的说，TLS 的建立在 SSL 3.0 协议规范之上的，是 SSL v3 的强化版，在整个协议格式上和 SSL 类似。TLS 增强了加密算法，并带来了更严格的警报，在安全性方面有很多改进。</p>
<p>关于 HTTP 与 HTTPS 和 SSL 与 TLS 的具体差别自行搜索。</p>
<img src="/2016/06/24/从输入URL到页面展示/ssl-tls-protocol.png" alt="SSL/TLS Protocol" title="SSL/TLS Protocol">
<p>关于 SSL/TLS 协议这里不做详解，此处主要讲述 TLS 握手的建立过程和 HTTPS 安全的原因。</p>
<p>我们来看看 TLS 握手的大致过程，这里不再详细叙述每个握手包</p>
<img src="/2016/06/24/从输入URL到页面展示/tls-handshake.jpg" alt="TLS-handshake" title="TLS-handshake">
<ul>
<li><p>Client Hello</p>
  <img src="/2016/06/24/从输入URL到页面展示/tls-handshake-1.png" alt="TLS-handshake-1" title="TLS-handshake-1">
<p>  可以看到 TCP 报文的 Push 为1，表示接收方尽快对该报文要尽快交付而不是积累到足够多的数据。</p>
<p>  这是一个 TLS 握手包，我们可以看到 HandShakeType 为 ClientHello ，对应 TLS 握手图的第一步。</p>
<p>   同时，该过程浏览器还发送了自己支持的一套加密规则。</p>
</li>
<li><p>Server Hello</p>
<p>  服务端接受到上述报文后，会发送 TCP 报文进行确认。报文如下</p>
  <img src="/2016/06/24/从输入URL到页面展示/tls-handshake-2.png" alt="TLS-handshake-2" title="TLS-handshake-2">
<p>  服务端发出 ACK 包的同时，发送 TLS 报文，此时 HandShakeType 为 ServerHello，对应 TLS 握手图的第二步。</p>
  <img src="/2016/06/24/从输入URL到页面展示/tls-handshake-3.png" alt="TLS-handshake-3" title="TLS-handshake-3">
<p>  接着上述的报文，服务端从客户端发来的加密规则中选出一组加密算法和 HASH 算法，并把自己的身份信息以证书形式发给客户端。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。如图，发送公钥使用了两个报文，最后客户端发送 ACK 确认报文进行确认，注意这个报文和上面的 ACK 报文一样不占用空间，只是进行确认而已。</p>
  <img src="/2016/06/24/从输入URL到页面展示/tls-handshake-4.png" alt="TLS-handshake-4" title="TLS-handshake-4">
</li>
<li><p>Client Key Exchange</p>
<p>  浏览器获得证书后，会首先验证证书的合法性，如果证书受信任，则浏览器栏里面会显示一个小绿锁。同时浏览器会生成一串随机数的密码，并用证书中提供的公钥进行加密，然后使用约定好的 HASH 算法计算握手信息，并使用未加密的随机数对消息进行加密。然后将消息重新发给服务端。这一步是加密握手包的开始。</p>
</li>
<li><p>Cipher Change Spec</p>
<p>  服务端使用自己的私钥对信息进行解密取出密码（密码被用公钥加密，只有用私钥才能加开，非对称加密），然后用该密码来解密握手消息，然后验证 HASH 是否与浏览器发来的一致。</p>
<p>  接着使用这个密码来加密一段握手信息，发给客户端即浏览器。</p>
</li>
<li><p>Finish</p>
<p>  客户端用密码对加密握手包进行解密（注意此时已经变为对称加密），同时计算 HASH 值，若 HASH 值一致，则握手过程结束。之后双方通信都使用之前浏览器生成的密码来进行加密。</p>
</li>
</ul>
<p>至此， HTTPS 连接已成功建立。由于浏览器会对证书进行校验，由证书授权机构保证其有效性，可以保证证书不被篡改。同时浏览器方面生成的随机数密码，一开始只有浏览器知道，而这个密码用公钥加密之后，只有私钥能解开，公钥也无法解开，这是非对称加密。服务器接收到该数据包后解开得到该密码，双方就可以使用该密码通过对称加密传输数据了。</p>
<p>现给出 TCP 三次握手和 TLS 握手的列表信息。</p>
<img src="/2016/06/24/从输入URL到页面展示/handshake.png" alt="HandsShake" title="HandsShake">
<p>这之后双方都是用 TLS 来传输数据，但不带数据的 ACK 确认包不进行加密，仍然使用 TCP 协议来传输。</p>
<p>需要明确的是，TLS 协议还是建立在 TCP 协议之上的，此处为便于说明将两者区分对待。即 TCP 协议是不进行加密的，TLS 是进行加密的 TCP 协议。</p>
<p>这个过程其实是先进行 HTTP 连接建立的三次握手，然后服务器进行 3xx 重定向，然后再进行 HTTPS 的三次握手。这样既增加了连接建立的开销，而且也可能在 HTTP 连接建立的过程被劫持。所以有出现了 HSTS。</p>
<blockquote>
<p>HTTP 严格传输安全(HTTP Strict Transport Security)是一套由互联网工程任务组发布的互联网安全策略机制。网站可以选择使用 HSTS 策略，来让浏览器强制使用 HTTPS 与网站进行通信，以减少会话劫持风险。</p>
</blockquote>
<p>我们有时候会看到出现证警告的提醒，使用了 HSTS 之后用户将不再允许忽略警告。但是用户首次访问某个网站是不受 HSTS 保护的，因为首次访问时浏览器还未收到 HSTS ，目前比较流行的方案是浏览器预置 HTST 域名列表，Google Chrome, Firefox, IE, Edge 都实现了这一方案，我们可以在服务器配置相关信息后去进行登记。HSTS 可以抵御 SSL 剥离攻击，它利用用户通过 HTTP 建立连接再重定向到 HTTPS 连接，阻止浏览器与服务器建立 HTTPS 连接，攻击者可以在用户访问 HTTP 页面时替换所有 HTTPS 链接为 HTTP，达到阻止 HTTPS 的目的。</p>
<h2 id="4-客户端请求网站信息"><a href="#4-客户端请求网站信息" class="headerlink" title="4. 客户端请求网站信息"></a>4. <a name="-3"></a>客户端请求网站信息</h2><ol>
<li><p>如果访问的是网站的主页，那么此时会发送一个请求给服务器，如下：</p>
<img src="/2016/06/24/从输入URL到页面展示/request-1.png" alt="request-package" title="request-package">
<p>HTTP 里面附带了 URI, ProtocolVersion, Host, Connection 以及 Cookie 等很多信息。</p>
<p>这里只讨论正常访问的情况。</p>
</li>
<li><p>服务端接收到该请求后，验证无误后，首先发送 ACK 报文进行确认。接着对该请求进行处理，如果是静态页面则直接返回。但大多数时候服务端都需要动态生成一个新的页面再返回该页面。这里讨论下 php 的处理。</p>
<p>假设我们这时候访问的是<code>index.php</code>这个页面，服务器例如 Nginx 知道这个不是静态文件，它回去寻找 PHP 解析器去做处理，这依靠的就是 CGI 来实现。</p>
<p>下面介绍几个概念，即 CGI, PHP-CGI, FastCGI, PHP-FPM。</p>
<ul>
<li><p>CGI</p>
<p>CGI 全称是“公共网关接口”（Common Gateway Interface），HTTP 服务器与服务器上其他程序进行通讯的一种协议。</p>
</li>
<li><p>PHP-CGI</p>
<p>简单的说 PHP-CGI 就是HTTP服务器与 PHP 进行通讯的工具，当浏览器发出一个类似 <code>/index.php</code> 的请求时，HTTP 服务器请求 PHP-CGI 去处理这个请求，PHP-CGI 处理完成后再把处理结果发回给 HTTP 服务器，然后由 HTTP 服务器发给浏览器。</p>
<p>PHP-CGI 在处理请求之前，需要解析<code>php.ini</code>文件，初始化执行环境，然后才开始处理请求。</p>
</li>
<li><p>FastCGI</p>
<p>FastCGI 全称是“快速通用网关接口”（Fast Common Gateway Interface / FastCGI）是一种让交互程序与 Web 服务器通信的协议。它是 CGI 的增强版本。</p>
<p>CGI 程序运行在独立的进程中，并对每一个请求建立一个进程，每个建立都要经过解析配置文件和初始化执行环境。这种方法易于实现，但效率很差，难以面对大量请求。</p>
<p>FastCGI 使用持续的进程来处理一连串的请求。这些进程由 FastCGI 服务器管理，而不是 Web 服务器。它是一个常驻型的 CGI(master)，只要激活后就不需要重新去解析 <code>php.ini</code> 和初始化，提高了效率。他在自身初始化后会启动多个 CGI 解析器(worker)，当有请求过来时，他会交给其中一个 worker 去处理。同时，它还可以动态调整 worker 的数量。</p>
</li>
<li><p>PHP-FPM</p>
<p>PHP-FPM 是一个 PHP FastCGI 管理器，从 PHP 5.3.3 开始已经集成了 PHP-FPM，在编译安装时可以通过 <code>-enable-fpm</code> 参数开启。</p>
<img src="/2016/06/24/从输入URL到页面展示/php-fpm.jpg" alt="php-fpm" title="php-fpm">
</li>
</ul>
<p>所以浏览器如果请求 <code>/index.html</code> 那么 Web 服务器会直接把这个静态页面返回，如果是请求 <code>/index.php</code>，则交由 PHP-FPM 进行处理，PHP-FPM 处理后再把结果返回给 Web 服务器，由 Web 服务器发给浏览器。</p>
<p>我们来看看响应报文</p>
<img src="/2016/06/24/从输入URL到页面展示/response-1.png" alt="response-1" title="response-1">
<p>可以看到除了对浏览器请求的 ACK 确认包之外，服务端发回了10个包。第一个报文里面有StatusCode, Etag, ContentEncoding 等信息。这里面涉及到不少网站优化的技巧，我们将在下一篇中再讨论。这里大概了解下就可以了。</p>
<p>接下来的9个报文都是跟着第1个报文一起过来的。最后一个报文设置了 PUSH 标志，因为报文已经传输完毕，所以它请求浏览器客户端尽快交付。</p>
<p>接着客户端会发送 ACK 确认报文，之所以这里客户端对最后一个报文进行了确认，是因为 TCP Delayed Ack 的原因，它是为了避免多次发送 ACK 确认报文而设置的延时，一般为 40ms，也就是说如果接收到一个报文 40ms 后没有接收到第二个报文，他就会对这个报文进行确认。</p>
<p>服务器发送完全部数据后，最后再发送一个报文，即图中的 #191 报文，表示我已经发完。客户端相应的发出 ACK 确认报文。主页请求结束。</p>
</li>
</ol>
<h2 id="5-浏览器渲染"><a href="#5-浏览器渲染" class="headerlink" title="5. 浏览器渲染"></a>5. <a name="-4"></a>浏览器渲染</h2><p>浏览器接收到 <code>index.html</code> 后，开始浏览器渲染，这里讨论 webkit 内核，其他内核不讨论。主要分为四步进行。如下图:</p>
<img src="/2016/06/24/从输入URL到页面展示/html-parse.png" alt="html-parse" title="html-parse">
<p>浏览器渲染不是本文的重点，所以只做简单说明。</p>
<ul>
<li><p>Parsing HTML to construct the DOM tree</p>
<p>数据会交给 HTMLDocumentParser，然后 HTMLDocumentParser 将文本字符的解析交给 HTMLDocumentTokenizer 来负责，HTMLDocumentTokenizer 解析出一个一个的标签，然后 HTMLDocumentParser 将标签交给 HTMLTreeBuilder 来构建 DOM 树。</p>
<p>有些节点需要加载其他资源，比如加载外链 CSS 和图片等。会调用资源加载器进行异步加载，不会阻碍当前 DOM 树的构造。但是如果是非 defer 非 async 的 script 标签，则需要停止当前 DOM 树的构造，直到脚本被加载并被 JavaScript 执行后才继续 DOM 树的构造。</p>
<p>因此我们有时候会要求 &lt;script&gt; 标签放到最后面，目的是为了不影响前面 DOM 树的构建。</p>
<p>对于 css 文件，会解析 css 生成 CSS Rule Tree。</p>
<p>对于 JavaScript` 文件，主要是通过 DOM API 和 CSSOM API 来操作 DOM TREE 和 CSS Rule Tree，从而改变渲染的效果。</p>
</li>
<li><p>Render tree construction</p>
<p>接着浏览器会开始构建渲染树(Rendering Tree)。Renderint Tree 只包括渲染页面需要的节点。</p>
<p>CSS Rule Tree 会匹配的把 CSS Rule 附加到相应的 Rendering Tree 的元素上面。</p>
<img src="/2016/06/24/从输入URL到页面展示/render-tree-construction.png" alt="render-tree-construction" title="render-tree-construction">
</li>
<li><p>Layout of the render tree</p>
<p>到目前为止，我们已经计算了哪些节点是可见的，以及它们的计算样式，但还没有计算它们在设备视窗中的准确位置与尺寸。这就是布局阶段做的事情。</p>
<p>渲染树的构建、布局与绘制所需的时间取决于文档大小、应用的样式，当然，还有运行文档的设备：文档越大，浏览器要完成的工作就越多；样式越复杂，绘制需要的时间就越长（例如，绘制单色成本较低，而计算、呈现阴影的成本就非常高了）。</p>
</li>
<li><p>Painting the render tree</p>
<p>一旦布局完成，浏览器便会发出 Paint Setup 与 Paint 事件，将渲染树转化为屏幕上的实际像素。</p>
</li>
</ul>
<p>大概可以用下图来表示整个过程。</p>
<img src="/2016/06/24/从输入URL到页面展示/webkitflow.png" alt="webkitflow" title="webkitflow">
<hr>
<p>参考资料</p>
<ul>
<li><a href="https://technet.microsoft.com/en-us/library/cc775637.aspx" target="_blank" rel="external">How DNS query works</a></li>
<li><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction" target="_blank" rel="external">Render Tree Construction</a></li>
<li><a href="http://taligarsiel.com/Projects/howbrowserswork1.htm#Render_tree_construction" target="_blank" rel="external">How browsers work</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文从网络层以上讨论从浏览器输入 HTTPS 协议的 URL 到页面展现的全过程。由于不同浏览器之间也存在差异，这里以 Chrome 浏览器为例。&lt;/p&gt;
&lt;h2 id=&quot;1-DNS查询&quot;&gt;&lt;a href=&quot;#1-DNS查询&quot; class=&quot;headerlink&quot; title=&quot;1. DNS查询&quot;&gt;&lt;/a&gt;1. &lt;a name=&#39;DNS-0&#39;&gt;&lt;/a&gt;DNS查询&lt;/h2&gt;&lt;p&gt;DNS 缓存有好几个环节，浏览器缓存，系统缓存，路由器缓存，ISP 缓存。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;浏览器首先会查看自身是否已经有进行 DNS 缓存。Chrome 可以通过 &lt;code&gt;chrome://net-internals/#dns&lt;/code&gt; 查看缓存的 DNS，浏览器的 DNS 缓存可以加快 DNS 解析速度，但缓存时间不会太长。&lt;/p&gt;
&lt;img src=&quot;/2016/06/24/从输入URL到页面展示/chrome-dns-cache.png&quot; alt=&quot;Chrome 的 DNS 缓存&quot; title=&quot;Chrome 的 DNS 缓存&quot;&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果浏览器没有相应的缓存，则查找系统缓存，浏览器会向系统发送一个查询请求，如果系统存在缓存或者设置了 host ，则返回相应的 ip 地址给浏览器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果系统没有缓存，那么它会发出一个 DNS 查询请求给路由器。&lt;/p&gt;
&lt;p&gt;如果路由器有 DNS 缓存，他会提取出 IP 地址返回。否则，他会向本地域名服务器发出查询，从请求主机到本地域名服务器的请求一般是递归查询，而其他的查询一般是迭代查询。&lt;/p&gt;
&lt;img src=&quot;/2016/06/24/从输入URL到页面展示/client-to-server-query.gif&quot; alt=&quot;DNS 请求主机到本地域名服务器的查询&quot; title=&quot;DNS 请求主机到本地域名服务器的查询&quot;&gt;
&lt;img src=&quot;/2016/06/24/从输入URL到页面展示/server-to-server-query.gif&quot; alt=&quot;DNS 域名服务器之间的查询&quot; title=&quot;DNS 域名服务器之间的查询&quot;&gt;
&lt;p&gt;请求报文如下&lt;/p&gt;
&lt;img src=&quot;/2016/06/24/从输入URL到页面展示/dns-request-1.png&quot; alt=&quot;DNS 请求报文&quot; title=&quot;DNS 请求报文&quot;&gt;
&lt;p&gt;我们先简单分析下请求报文。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DNS 使用 UDP 协议，端口号53。&lt;/li&gt;
&lt;li&gt;在 DNS 报文的 Flags 中的 RD=1。表示它建议域名服务器以递归方式查询。&lt;/li&gt;
&lt;li&gt;Question section format 需要给出 &lt;code&gt;QNAME&lt;/code&gt;, &lt;code&gt;QTYPE&lt;/code&gt;, &lt;code&gt;QCLASS&lt;/code&gt;。即查询的域名，查询的类型以及查询的类。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有关&lt;code&gt;DNS&lt;/code&gt;报文的更多信息可以参考&lt;a href=&quot;https://www.ietf.org/rfc/rfc1035&quot;&gt;RFC1035&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;响应报文如下&lt;/p&gt;
&lt;img src=&quot;/2016/06/24/从输入URL到页面展示/dns-response-1.png&quot; alt=&quot;DNS 响应报文&quot; title=&quot;DNS 响应报文&quot;&gt;
&lt;p&gt;我们也简单分析下，如果想详细了解，可以查看上面的 &lt;code&gt;RFC1035&lt;/code&gt; 标准。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;与请求报文相比，对比 Flags 可以发现，QR=1 表示这是一个响应报文。RA=1 表示递归查询可用。&lt;/li&gt;
&lt;li&gt;ARecord 记录了DNS请求获得的一个或多个IP地址。一般还会得到 CNAME 记录和存活时间等信息。&lt;/li&gt;
&lt;li&gt;这里对 Rcode 也稍加说明下，Rcode=0 表示成功，他还有好几种状态码，比如1表示 &lt;code&gt;Format error&lt;/code&gt;，2表示 &lt;code&gt;Server failure&lt;/code&gt;，3表示 &lt;code&gt;Name error&lt;/code&gt;，4表示 &lt;code&gt;Not lmplemented&lt;/code&gt;，5表示 &lt;code&gt;Refused&lt;/code&gt;，具体信息可以参考 &lt;code&gt;RFC1035&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="HTTP" scheme="https://ruiming.github.io/categories/HTTP/"/>
    
    
      <category term="DNS" scheme="https://ruiming.github.io/tags/DNS/"/>
    
      <category term="HTTPS" scheme="https://ruiming.github.io/tags/HTTPS/"/>
    
      <category term="HTTP" scheme="https://ruiming.github.io/tags/HTTP/"/>
    
      <category term="TCP/IP" scheme="https://ruiming.github.io/tags/TCP-IP/"/>
    
      <category term="Webkit" scheme="https://ruiming.github.io/tags/Webkit/"/>
    
  </entry>
  
  <entry>
    <title>Angular 学习总结</title>
    <link href="https://ruiming.github.io/2016/06/18/Angular%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://ruiming.github.io/2016/06/18/Angular学习总结/</id>
    <published>2016-06-18T12:20:38.000Z</published>
    <updated>2016-08-04T09:24:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>这学期基本都是在学习和使用 Angular ，这篇文章主要是想介绍几个 Angular 需要注意或者了解的地方。</p>
<h2 id="Angular作用域"><a href="#Angular作用域" class="headerlink" title="Angular作用域"></a>Angular作用域</h2><p>​    也许你知道 ng-if 和 ng-show 的区别是一个只有条件满足的时候才会创建 DOM ，一个是只有在条件满足的时候才会显示 DOM 也就是一开始也会跟着创建。但是你可能不知道， ng-if 会产生新的作用域， ng-repeat 和 ng-switch 和 ng-include 也是如此。这时候内部如果使用外部的变量，第一次的时候会正常显示，因为 Angular 的继承是原型链继承，如果子类没有这个属性就会去尝试继承父类的属性， Angular 会拿父类的属性来创建新的属于这个子类的属性，而这个属性将不再和外层的父类的属性挂钩，如果不注意很可能就会在这里踩坑。</p>
<blockquote>
<p>读子类的属性时，子类有这个属性（hasOwnProperty）的时候则读子类自己的，子类没有的时候读父类的，不管子类有没有这个属性，在子类上都不会有新属性被创建。    </p>
<p>写子类的属性时，如果子类有这个属性（hasOwnProperty）则写子类的，子类没有的话就会在子类上新建一个同名的新属性，而父类继承过来的属性被隐藏。</p>
</blockquote>
<p>​    关于原型链继承这个可以参考此处<a href="http://stackoverflow.com/questions/14049480/what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs/14049482#14049482" target="_blank" rel="external">JavaScript Prototypal Inheritance</a>，或者<a href="https://www.zybuluo.com/lxjwlt/note/107324" target="_blank" rel="external">[译文] 深入浅出 AngularJS 作用域</a></p>
<p>​    使用上述的 ng-if ,  ng-repeat ,  ng-switch ,  ng-include 都会自己创建一级作用域，这点一定要注意。如果想要和父类的属性挂钩，可以使用 $parent 。</p>
<p>​    但是，还没玩，也许这些你都知道。但是除了这些指令之外， textarea 也会自己创建一级作用域。所以你可能会发现你在 textarea 写的内容获取不到，但是却发现 textarea 总能取到第一次分配的初值。比如</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">ng-model</span>=<span class="string">"content"</span>, <span class="attr">name</span>=<span class="string">"content"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">row</span>=<span class="string">"3"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></div></pre></td></tr></table></figure>
<p>​    我们在控制器里面定义</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$scope.content = <span class="string">"测试"</span></div></pre></td></tr></table></figure>
<p>​    然后我们就会看到 textarea 的初值为”测试”，但是当我们更改其中的内容之后， $scope.content 却一直保持不变。</p>
<p>​    同样，我们可以使用 $parent 的方式来解决这个问题。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">ng-model</span>=<span class="string">"$parent.content"</span>, <span class="attr">name</span>=<span class="string">"content"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">row</span>=<span class="string">"3"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></div></pre></td></tr></table></figure>
<p>​    那如果不想使用 $parent 的话，可以给 content 分配一个类名，比如</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">ng-model</span>=<span class="string">"comment.content"</span>, <span class="attr">name</span>=<span class="string">"content"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">row</span>=<span class="string">"3"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></div></pre></td></tr></table></figure>
<p>​    这样我们就可以通过 $scope.comment.content 来取值。</p>
<h2 id="Angular-track-by"><a href="#Angular-track-by" class="headerlink" title="Angular track by"></a>Angular track by</h2><p>​    在使用 Angular 的 ng-repeat 迭代数组时，有时候会出现 Duplicates in a repeater are not allowed 的提示。</p>
<p>​     track by 是用来建立 $watchCollection 和 DOM 之间的联系。建议自己加上 track by 后面带的值可以自己写，但要确保每个 ngRepeat 的值唯一，比如可以写 track by $index 。</p>
<p>​    之所以要这么做，是因为，如果不使用 track by ，那么每个 ng-repeat 都会添加一个 $$hashkey 来对的 DOM 进行跟踪，这样会导致不能存在相同的 DOM ，使用 track by 的意义是避免不必要的渲染。</p>
<p>​    官网API有进行详细的说明，不过我看了之后还是感觉不太明白，等我了解清楚了再来补充下。<a href="https://docs.angularjs.org/api/ng/directive/ngRepeat" target="_blank" rel="external">AngularJS: API: ngRepeat</a></p>
<blockquote>
<p>If you are working with objects that have an identifier property, you should track by the identifier instead of the whole object. Should you reload your data later,  ngRepeat  will not have to rebuild the DOM elements for items it has already rendered, even if the JavaScript objects in the collection have been substituted for new ones. For large collections, this significantly improves rendering performance. If you don’t have a unique identifier,  track by $index  can also provide a performance boost.</p>
</blockquote>
<h2 id="Angular拦截器"><a href="#Angular拦截器" class="headerlink" title="Angular拦截器"></a>Angular拦截器</h2><p>​     Angular 拦截器是 Angular 的一个强大功能，不过暂时没有怎么去研究，简单说下我的一些使用。</p>
<a id="more"></a>
<ul>
<li><p>判断请求是否成功</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$httpProvider.defaults.transformResponse.push((response) =&gt; &#123;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span>(response.data) != <span class="literal">undefined</span> &amp;&amp; response.status == <span class="string">'success'</span>) &#123;</div><div class="line">  	response = response.data;</div><div class="line">    <span class="keyword">return</span> response;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(response.status == <span class="string">'error'</span>) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Err: "</span> + response.message);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> response;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>应该都能看懂，就不过多解释了。需要说明你的是，我们只需要一次配置，即可在整个项目中适用，特别方便。<br>​</p>
</li>
<li><p>timestampMarker</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">app.factory(<span class="string">'timestampMarker'</span>, [() =&gt; &#123;</div><div class="line">  <span class="keyword">let</span> timestampMarker = &#123;</div><div class="line">    request: (config) = &gt; &#123;</div><div class="line">      config.requestTimestamp = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</div><div class="line">      <span class="keyword">return</span> config;</div><div class="line">    &#125;,</div><div class="line">    response: (response) = &gt; &#123;</div><div class="line">      response.config.responseTimestamp = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</div><div class="line">      <span class="keyword">return</span> response;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;]);</div></pre></td></tr></table></figure>
<p>这是给每个请求加上时间戳来防止浏览器缓存。</p>
</li>
<li><p>tokenInjector</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">app.factory(<span class="string">'tokenInjector'</span>, [<span class="string">'$injector'</span>, <span class="string">'$q'</span>, ($injector, $q) =&gt; &#123;</div><div class="line">    <span class="keyword">let</span> tokenInjector = &#123;</div><div class="line">      	request: (config) =&gt; &#123;</div><div class="line">        <span class="keyword">let</span> url = host + <span class="string">'/auth_verify'</span>;</div><div class="line">        <span class="keyword">let</span> deferred = $q.defer();</div><div class="line">        <span class="keyword">let</span> http = $injector.get(<span class="string">'$http'</span>);</div><div class="line">        <span class="keyword">if</span>(config.url === url) &#123;</div><div class="line">          <span class="keyword">return</span> config;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(sessionStorage.verify === <span class="string">'true'</span>) &#123;</div><div class="line">          <span class="keyword">let</span> timestamp = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() / <span class="number">1000</span>;</div><div class="line">           <span class="keyword">if</span>(timestamp - sessionStorage.createdtime &gt;= <span class="number">7000</span>) &#123;</div><div class="line">              sessionStorage.verify = <span class="literal">false</span>;  </div><div class="line">          &#125;</div><div class="line">           config.headers[<span class="string">'token'</span>] = sessionStorage.token;</div><div class="line">           config.headers[<span class="string">'userid'</span>] = sessionStorage.user_id;</div><div class="line">           deferred.resolve(config);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;])</div></pre></td></tr></table></figure>
<p>​上面是我从我的项目中截取的代码，作用是每次请求时，如果已经验证过，判断 token 创建时间和当前时间以判断 token 是否过期，如未过期，将 token 和 userid 加到请求的 headers 中。如果没有验证或者已经超时，则要去获取新的 token ，这里没有把代码写上。</p>
</li>
</ul>
<p>​通过这三个例子，我想已经很明显的展示了 Angular 拦截器的强大之处。一次使用，终身受益，爽。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这学期基本都是在学习和使用 Angular ，这篇文章主要是想介绍几个 Angular 需要注意或者了解的地方。&lt;/p&gt;
&lt;h2 id=&quot;Angular作用域&quot;&gt;&lt;a href=&quot;#Angular作用域&quot; class=&quot;headerlink&quot; title=&quot;Angular作用域&quot;&gt;&lt;/a&gt;Angular作用域&lt;/h2&gt;&lt;p&gt;​    也许你知道 ng-if 和 ng-show 的区别是一个只有条件满足的时候才会创建 DOM ，一个是只有在条件满足的时候才会显示 DOM 也就是一开始也会跟着创建。但是你可能不知道， ng-if 会产生新的作用域， ng-repeat 和 ng-switch 和 ng-include 也是如此。这时候内部如果使用外部的变量，第一次的时候会正常显示，因为 Angular 的继承是原型链继承，如果子类没有这个属性就会去尝试继承父类的属性， Angular 会拿父类的属性来创建新的属于这个子类的属性，而这个属性将不再和外层的父类的属性挂钩，如果不注意很可能就会在这里踩坑。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;读子类的属性时，子类有这个属性（hasOwnProperty）的时候则读子类自己的，子类没有的时候读父类的，不管子类有没有这个属性，在子类上都不会有新属性被创建。    &lt;/p&gt;
&lt;p&gt;写子类的属性时，如果子类有这个属性（hasOwnProperty）则写子类的，子类没有的话就会在子类上新建一个同名的新属性，而父类继承过来的属性被隐藏。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​    关于原型链继承这个可以参考此处&lt;a href=&quot;http://stackoverflow.com/questions/14049480/what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs/14049482#14049482&quot;&gt;JavaScript Prototypal Inheritance&lt;/a&gt;，或者&lt;a href=&quot;https://www.zybuluo.com/lxjwlt/note/107324&quot;&gt;[译文] 深入浅出 AngularJS 作用域&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​    使用上述的 ng-if ,  ng-repeat ,  ng-switch ,  ng-include 都会自己创建一级作用域，这点一定要注意。如果想要和父类的属性挂钩，可以使用 $parent 。&lt;/p&gt;
&lt;p&gt;​    但是，还没玩，也许这些你都知道。但是除了这些指令之外， textarea 也会自己创建一级作用域。所以你可能会发现你在 textarea 写的内容获取不到，但是却发现 textarea 总能取到第一次分配的初值。比如&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;textarea&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ng-model&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;content&quot;&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;content&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;form-control&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;row&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;3&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;textarea&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;​    我们在控制器里面定义&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$scope.content = &lt;span class=&quot;string&quot;&gt;&quot;测试&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;​    然后我们就会看到 textarea 的初值为”测试”，但是当我们更改其中的内容之后， $scope.content 却一直保持不变。&lt;/p&gt;
&lt;p&gt;​    同样，我们可以使用 $parent 的方式来解决这个问题。&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;textarea&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ng-model&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;$parent.content&quot;&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;content&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;form-control&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;row&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;3&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;textarea&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;​    那如果不想使用 $parent 的话，可以给 content 分配一个类名，比如&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;textarea&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ng-model&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;comment.content&quot;&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;content&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;form-control&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;row&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;3&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;textarea&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;​    这样我们就可以通过 $scope.comment.content 来取值。&lt;/p&gt;
&lt;h2 id=&quot;Angular-track-by&quot;&gt;&lt;a href=&quot;#Angular-track-by&quot; class=&quot;headerlink&quot; title=&quot;Angular track by&quot;&gt;&lt;/a&gt;Angular track by&lt;/h2&gt;&lt;p&gt;​    在使用 Angular 的 ng-repeat 迭代数组时，有时候会出现 Duplicates in a repeater are not allowed 的提示。&lt;/p&gt;
&lt;p&gt;​     track by 是用来建立 $watchCollection 和 DOM 之间的联系。建议自己加上 track by 后面带的值可以自己写，但要确保每个 ngRepeat 的值唯一，比如可以写 track by $index 。&lt;/p&gt;
&lt;p&gt;​    之所以要这么做，是因为，如果不使用 track by ，那么每个 ng-repeat 都会添加一个 $$hashkey 来对的 DOM 进行跟踪，这样会导致不能存在相同的 DOM ，使用 track by 的意义是避免不必要的渲染。&lt;/p&gt;
&lt;p&gt;​    官网API有进行详细的说明，不过我看了之后还是感觉不太明白，等我了解清楚了再来补充下。&lt;a href=&quot;https://docs.angularjs.org/api/ng/directive/ngRepeat&quot;&gt;AngularJS: API: ngRepeat&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If you are working with objects that have an identifier property, you should track by the identifier instead of the whole object. Should you reload your data later,  ngRepeat  will not have to rebuild the DOM elements for items it has already rendered, even if the JavaScript objects in the collection have been substituted for new ones. For large collections, this significantly improves rendering performance. If you don’t have a unique identifier,  track by $index  can also provide a performance boost.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Angular拦截器&quot;&gt;&lt;a href=&quot;#Angular拦截器&quot; class=&quot;headerlink&quot; title=&quot;Angular拦截器&quot;&gt;&lt;/a&gt;Angular拦截器&lt;/h2&gt;&lt;p&gt;​     Angular 拦截器是 Angular 的一个强大功能，不过暂时没有怎么去研究，简单说下我的一些使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Angular" scheme="https://ruiming.github.io/categories/Angular/"/>
    
    
      <category term="Angular" scheme="https://ruiming.github.io/tags/Angular/"/>
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="Front end" scheme="https://ruiming.github.io/tags/Front-end/"/>
    
  </entry>
  
  <entry>
    <title>谈谈前端自动构建工具 Gulp</title>
    <link href="https://ruiming.github.io/2016/06/18/%E8%B0%88%E8%B0%88%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7gulp/"/>
    <id>https://ruiming.github.io/2016/06/18/谈谈前端自动构建工具gulp/</id>
    <published>2016-06-18T12:18:17.000Z</published>
    <updated>2016-08-04T08:33:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>​类似 Gulp 这样的工具可以说是前端利器，基本前端开发都离不开他，类似的解决方案还有 Grunt 和 Webpack 等，不过我用 Gulp 比较多一些，所以我只能谈谈 Gulp 了。</p>
<p>​Gulp 上面优秀的插件特别多，我使用的有这些： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> gulp <span class="keyword">from</span> <span class="string">'gulp'</span></div><div class="line"><span class="keyword">import</span> babel <span class="keyword">from</span> <span class="string">'gulp-babel'</span></div><div class="line"><span class="keyword">import</span> uglify <span class="keyword">from</span> <span class="string">'gulp-uglify'</span></div><div class="line"><span class="keyword">import</span> ngAnnotate <span class="keyword">from</span> <span class="string">'gulp-ng-annotate'</span></div><div class="line"><span class="keyword">import</span> concat <span class="keyword">from</span> <span class="string">'gulp-concat'</span></div><div class="line"><span class="keyword">import</span> cleanCSS <span class="keyword">from</span> <span class="string">'gulp-clean-css'</span></div><div class="line"><span class="keyword">import</span> imagemin <span class="keyword">from</span> <span class="string">'gulp-imagemin'</span></div><div class="line"><span class="keyword">import</span> minifyHtml <span class="keyword">from</span> <span class="string">'gulp-minify-html'</span></div><div class="line"><span class="keyword">import</span> ngTemplate <span class="keyword">from</span> <span class="string">'gulp-ng-template'</span></div><div class="line"><span class="keyword">import</span> plumber <span class="keyword">from</span> <span class="string">'gulp-plumber'</span></div><div class="line"><span class="keyword">import</span> sass <span class="keyword">from</span> <span class="string">'gulp-sass'</span></div><div class="line"><span class="keyword">import</span> usemin <span class="keyword">from</span> <span class="string">'gulp-usemin'</span></div><div class="line"><span class="keyword">import</span> runSequence <span class="keyword">from</span> <span class="string">'gulp-run-sequence'</span></div><div class="line"><span class="keyword">import</span> eslint <span class="keyword">from</span> <span class="string">'gulp-eslint'</span></div></pre></td></tr></table></figure>
<ul>
<li><p>gulp-uglify</p>
<p>对 JavaScript 进行压缩的插件，可以有效减少 JavaScript 的文件大小。</p>
</li>
<li><p>gulp-ng-annotate</p>
<p>对 Angular 的代码进行转换，因为使用上面的 <code>gulp-uglify</code> 对 Angular 的代码进行压缩时会破坏 Angular 文件的依赖注入功能，导致无法正常工作，这个基本上是 Angular 开发必备的了。</p>
</li>
<li><p>gulp-concat</p>
<p>文件合并，前端合并文件以减少请求是非常重要的优化技巧。</p>
</li>
<li><p>gulp-clean-css</p>
<p>字如其名，对css 进行合并压缩。</p>
</li>
<li><p>gulp-imagemin</p>
<p>对图片进行压缩。</p>
</li>
<li><p>gulp-minify-html</p>
<p>对html文件进行压缩。</p>
</li>
<li><p>gulp-ng-template</p>
<p>这个也是 Angular 里面比较响当当的一个插件了，他的作用是将 Angular 模板存到 templateCache ，可以提升模板加载速度。</p>
</li>
<li><p>gulp-plumber</p>
<p>这个貌似也是 Gulp 必不可少的插件之一了，可以避免 Gulp 出错导致整个进程崩掉。</p>
</li>
<li><p>gulp-sass</p>
<p>编译 sass 代码为 css，非常方便。</p>
</li>
<li><p>gulp-run-sequence</p>
<p>可以让 Gulp 的任务顺序执行，有些时候我们希望 Gulp 执行了一些任务完成之后才来执行下一个任务，这时候这个插件就派上用场了。</p>
</li>
<li><p>gulp-usemin</p>
<p>这个是用来从工作环境到生产环境进行部署的工具。</p>
</li>
<li><p>gulp-eslint</p>
<p>eslint 代码检查。</p>
</li>
</ul>
<a id="more"></a>
<p>​    上面的这些插件都是我在一个项目中使用到的，通过这些工具实现了前端的自动化开发，我在项目中有开发环境和生产环境之分。</p>
<p>​    在 Gulp 中，我有一段在开发环境下执行的任务</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'css'</span>, <span class="string">'js'</span>, <span class="string">'angular'</span>, <span class="string">'img'</span>, <span class="string">'templates:dist'</span>, <span class="string">'sass'</span>, <span class="string">'fonts'</span>])</div></pre></td></tr></table></figure>
<p>​    这段代码帮我做了</p>
<ul>
<li><code>css</code>：进行 css 文件(这些文件是第三方 css 文件如 bootstrap)的合并。</li>
<li><code>javascript</code>：进行 JavaScript 文件的合并，这是将所有我写的 Angular 文件进行合并，但不进行压缩以方便我调试。</li>
<li><code>angular</code>：将项目所有的 JavaScript 依赖如 Angular, ui-router, jQuery 等文件进行压缩合并。</li>
<li><code>img</code>：将图片进行压缩和迁移，这些图片压缩后放入生产环境对应的文件夹中。</li>
<li><code>templates:dist</code>：对 Angular 的视图进行合并，使用了上述的 <code>gulp-ng-template</code> 插件，合并后为一个新的 JavaScript 文件。</li>
<li><code>sass</code>：将我写的 scss 代码进行编译。</li>
<li><p><code>fonts</code>：移动相应的字体文件到生产环境中。</p>
<p>​开发环境下我们需要自动构建，也需要便于调试，所以我用上面这样的方式来处理，并且开启了 watch 监视变化，在有更改发生时自动构建。当我处理完全部工作后需要 push 到服务器上面时，会执行 <code>gulp product</code> 即下面的 task。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'product'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</div><div class="line">  runSequence(<span class="string">'together'</span>, <span class="string">'move'</span>, cb)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">gulp.task(<span class="string">'together'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</div><div class="line">    gulp.src(<span class="string">'index.html'</span>)</div><div class="line">        .pipe(plumber())</div><div class="line">        .pipe(usemin(&#123;</div><div class="line">            cssProduct: [<span class="string">'concat'</span>],</div><div class="line">            jsProduct: [ngAnnotate(),<span class="string">'concat'</span>,uglify()]</div><div class="line">        &#125;))</div><div class="line">        .pipe(gulp.dest(<span class="string">'backend/app/'</span>))</div><div class="line">        .on(<span class="string">'end'</span>,cb);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">gulp.task(<span class="string">'move'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'backend/app/index.html'</span>)</div><div class="line">                .pipe(gulp.dest(<span class="string">'backend/app/templates/'</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>​    这里使用了上述说的 <code>ng-run-sequence</code> 插件，这里会在执行完 <code>together</code> 的任务后才开始执行 <code>move</code> 的任务。这里主要使用的插件是 <code>gulp-usemin</code>，我用它来做了这些事情，为了方便说明，我贴下代码。需要先说明的是，我在项目中一共有3个 <code>index.html</code> 文件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span> <span class="attr">ng-app</span>=<span class="string">"index"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- build:cssProduct /static/css/app.min.css --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"src/css/app.min.css"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"src/css/bookist.css"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- endbuild --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    ...</div><div class="line">    <span class="comment">&lt;!-- build:jsProduct /static/js/app.min.js --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"src/js/dependence.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"src/js/app.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"src/js/templates.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- endbuild --&gt;</span></div><div class="line">    <span class="comment">&lt;!-- build:remove --&gt;</span></div><div class="line">    <span class="comment">&lt;!--</span></div><div class="line">        这段注释会被移除</div><div class="line">    --&gt;</div><div class="line">    <span class="comment">&lt;!-- endbuild--&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div></pre></td></tr></table></figure>
<p>​    省去了没有用的代码，这里需要你对 <code>ng-usemin</code> 有一定的了解。这个 <code>index.html</code> 是我在开发环境下使用的，使用了我开发环境的 task 生成文件，我在上面有补充说明了。</p>
<p>​    所以，在部署生产环境时执行这段 task 的意义是，将开发环境下的代码再做进一步的合并和压缩。<code>ng-usemin</code> 这个插件会帮我们处理这个 <code>index.html</code> 文件，最后会在我们指定的目录下部署好这些东西。但是因为后端处理 <code>index.html</code> 的路径原因，我还要对 <code>index.html</code> 做一次移动，所以有了第三个 <code>index.html</code>。</p>
<p>​    最终生成的 index 和相应的资源位置如下</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span> <span class="attr">ng-app</span>=<span class="string">"index"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/static/css/app.min.css"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/static/js/app.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​类似 Gulp 这样的工具可以说是前端利器，基本前端开发都离不开他，类似的解决方案还有 Grunt 和 Webpack 等，不过我用 Gulp 比较多一些，所以我只能谈谈 Gulp 了。&lt;/p&gt;
&lt;p&gt;​Gulp 上面优秀的插件特别多，我使用的有这些： &lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; gulp &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;gulp&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; babel &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;gulp-babel&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; uglify &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;gulp-uglify&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; ngAnnotate &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;gulp-ng-annotate&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; concat &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;gulp-concat&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; cleanCSS &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;gulp-clean-css&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; imagemin &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;gulp-imagemin&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; minifyHtml &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;gulp-minify-html&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; ngTemplate &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;gulp-ng-template&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; plumber &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;gulp-plumber&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; sass &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;gulp-sass&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; usemin &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;gulp-usemin&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; runSequence &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;gulp-run-sequence&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; eslint &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;gulp-eslint&#39;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;gulp-uglify&lt;/p&gt;
&lt;p&gt;对 JavaScript 进行压缩的插件，可以有效减少 JavaScript 的文件大小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;gulp-ng-annotate&lt;/p&gt;
&lt;p&gt;对 Angular 的代码进行转换，因为使用上面的 &lt;code&gt;gulp-uglify&lt;/code&gt; 对 Angular 的代码进行压缩时会破坏 Angular 文件的依赖注入功能，导致无法正常工作，这个基本上是 Angular 开发必备的了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;gulp-concat&lt;/p&gt;
&lt;p&gt;文件合并，前端合并文件以减少请求是非常重要的优化技巧。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;gulp-clean-css&lt;/p&gt;
&lt;p&gt;字如其名，对css 进行合并压缩。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;gulp-imagemin&lt;/p&gt;
&lt;p&gt;对图片进行压缩。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;gulp-minify-html&lt;/p&gt;
&lt;p&gt;对html文件进行压缩。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;gulp-ng-template&lt;/p&gt;
&lt;p&gt;这个也是 Angular 里面比较响当当的一个插件了，他的作用是将 Angular 模板存到 templateCache ，可以提升模板加载速度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;gulp-plumber&lt;/p&gt;
&lt;p&gt;这个貌似也是 Gulp 必不可少的插件之一了，可以避免 Gulp 出错导致整个进程崩掉。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;gulp-sass&lt;/p&gt;
&lt;p&gt;编译 sass 代码为 css，非常方便。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;gulp-run-sequence&lt;/p&gt;
&lt;p&gt;可以让 Gulp 的任务顺序执行，有些时候我们希望 Gulp 执行了一些任务完成之后才来执行下一个任务，这时候这个插件就派上用场了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;gulp-usemin&lt;/p&gt;
&lt;p&gt;这个是用来从工作环境到生产环境进行部署的工具。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;gulp-eslint&lt;/p&gt;
&lt;p&gt;eslint 代码检查。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://ruiming.github.io/categories/JavaScript/"/>
    
    
      <category term="Angular" scheme="https://ruiming.github.io/tags/Angular/"/>
    
      <category term="JavaScript" scheme="https://ruiming.github.io/tags/JavaScript/"/>
    
      <category term="Front end" scheme="https://ruiming.github.io/tags/Front-end/"/>
    
      <category term="Gulp" scheme="https://ruiming.github.io/tags/Gulp/"/>
    
  </entry>
  
</feed>
