{"meta":{"title":"Ruiming's Blog","subtitle":null,"description":"Blog","author":"Ruiming","url":"https://ruiming.github.io"},"pages":[{"title":"关于我","date":"2016-06-25T03:27:37.000Z","updated":"2016-11-08T01:54:18.000Z","comments":true,"path":"about/index.html","permalink":"https://ruiming.github.io/about/index.html","excerpt":"","text":"1234567891011121314151617(function() &#123; const me = &#123; name: \"ruiming\", location: \"广州\", email: \"ruiming.zhuang@gmail.com\", keyword: [\"ArchLinux\", \"JavaScript\", \"Angular1\", \"Koa2\", \"Vue2\"] &#125; console.log(me)&#125;)()"},{"title":"uploads","date":"2016-06-25T02:55:49.000Z","updated":"2016-06-25T02:55:49.000Z","comments":true,"path":"uploads/index.html","permalink":"https://ruiming.github.io/uploads/index.html","excerpt":"","text":""}],"posts":[{"title":"2016 总结","slug":"2016-总结","date":"2016-12-28T07:56:44.000Z","updated":"2016-12-28T08:02:53.249Z","comments":true,"path":"2016/12/28/2016-总结/","link":"","permalink":"https://ruiming.github.io/2016/12/28/2016-总结/","excerpt":"2016 年, 要用一个词来形容我的话, 那可能是”技术宅”. 终日沉迷代码不能自拔, 不过正因如此, 技术上成长特别快. 马上要 2017 年, 稍微总结下自己即将过去的 2016 年吧~ 技术篇2016 年, 学习使用了非常多的东西, 包括但不限于: AngularJS, React, Redux, Vue2, Vuex, Underscore, Electron, Koa2, PEG.js, D3, jQuery, ESLint, Swig, Mongoose, Sass, PostCSS, Gulp, Bower, Webpack, NPM, Git, PHP, Laravel, Vagrant, Bootstrap, Python, BeautifulSoap. 有的技术是花了很多时间, 例如 AngularJS 几乎做了一整年项目, Vue2 则是目前主要使用的前端框架, Koa2 是目前主要使用的后端框架. 而有些则是做一下小应用, 例如 React 和 Redux 结合这做了一个问卷设计页面, PEG.js 写了一个 XML 解析器, Python 和 BeautifulSoap 撸爬虫. 另有一些其实都快忘了, PHP 和 Laravel 主要是去年年底和年初在搞, 自从把精力放在前端之后就再也没用, 大概已经忘光了. 项目篇2016年, 做了很多项目 使用 PHP 和 laravel 自己搭建了一个博客框架 使用 Python 写了豆瓣爬虫 使用 AngularJS 写了一个书籍推荐和购买平台 使用 jQuery 写了一个飞机大战游戏 使用 AngularJS 和 ELectron 写了一个类似 Windows 资源管理器的软件 使用 AngularJS 和 Electron 写了一个磁盘分析软件 使用 React 和 Redux 写了一个问卷设计小应用 发布了 node-wmic 模块 使用 PEG.js 写了一个 XML 解析器 使用 Vue2, AngularJS, Koa2 写了一个 RSS 订阅器 使用 Node 写了一个静态博客框架 使用 JAVA 写了一个 YACC","text":"2016 年, 要用一个词来形容我的话, 那可能是”技术宅”. 终日沉迷代码不能自拔, 不过正因如此, 技术上成长特别快. 马上要 2017 年, 稍微总结下自己即将过去的 2016 年吧~ 技术篇2016 年, 学习使用了非常多的东西, 包括但不限于: AngularJS, React, Redux, Vue2, Vuex, Underscore, Electron, Koa2, PEG.js, D3, jQuery, ESLint, Swig, Mongoose, Sass, PostCSS, Gulp, Bower, Webpack, NPM, Git, PHP, Laravel, Vagrant, Bootstrap, Python, BeautifulSoap. 有的技术是花了很多时间, 例如 AngularJS 几乎做了一整年项目, Vue2 则是目前主要使用的前端框架, Koa2 是目前主要使用的后端框架. 而有些则是做一下小应用, 例如 React 和 Redux 结合这做了一个问卷设计页面, PEG.js 写了一个 XML 解析器, Python 和 BeautifulSoap 撸爬虫. 另有一些其实都快忘了, PHP 和 Laravel 主要是去年年底和年初在搞, 自从把精力放在前端之后就再也没用, 大概已经忘光了. 项目篇2016年, 做了很多项目 使用 PHP 和 laravel 自己搭建了一个博客框架 使用 Python 写了豆瓣爬虫 使用 AngularJS 写了一个书籍推荐和购买平台 使用 jQuery 写了一个飞机大战游戏 使用 AngularJS 和 ELectron 写了一个类似 Windows 资源管理器的软件 使用 AngularJS 和 Electron 写了一个磁盘分析软件 使用 React 和 Redux 写了一个问卷设计小应用 发布了 node-wmic 模块 使用 PEG.js 写了一个 XML 解析器 使用 Vue2, AngularJS, Koa2 写了一个 RSS 订阅器 使用 Node 写了一个静态博客框架 使用 JAVA 写了一个 YACC Github 篇2016 年泡了很久的 Github. 目前在 Github 有 20 个 Repo (含私人), 提价了 1145 次 Commit. 参与了三个开源项目. 参与了多个项目 issue 的讨论. 获得两次 Pull Request. 得到 13 个关注. 项目一共获得 32 个 star. 不得不说看到之前绿了一大屏, 都不想停下来. 不过最近由于考试缘故真的不得不停下来. 博客篇2016 年 6 月 18 日, 开始使用 Hexo. 至今写了 27 篇原创博客, 一篇翻译. 前期博客主要还是重在 AngularJS 以及 Underscore 上面. 最近的则比较分散, 有 Vue2, 有 Webpack, 有 JS 源码也有 co 源码等等. 自认为有几篇写的还是挺不错的. 虽然博客至今没有任何评论, 这也没办法, 自己也没有去宣传过. 在写博客的过程中我总担心写错了, 被别人看到了误人子弟, 这些博客大多数都是个人在项目中遇到的一些坑或者是一些经验的总结. 在使用 Hexo 之前我也是偶尔写博客, 只不过那些博客质量太低被我丢掉了. 资讯篇2016 年开始关注前端和 Node. 在知乎和 Github 关注了很多前端或 Node 的大神, 知乎成了我技术资讯获取的一大重要地盘. 另外, 也从很多网站如淘宝 FED, 百度 FEX, 掘金, 奇舞团等获取前端和 Node 的信息, 为此使用了 RSS 订阅了很多订阅源, 后来甚至自己写了一个订阅器. 此外, 在 StackOverflow 上面解决了很多我在项目中遇到的问题, StackOverflow 有些回答真的是不能不赞了. 同时, 也关注了 Reddit 上面的 JS 等专栏. 前端和 Node 技术迭代快, 变化快, 落后就要滚粗啊, 各方面消息都得跟上才行. 工具篇2016 年也搞了很多其他新的东西. 从 5 月开始就使用 ArchLinux 至今, 用了半年 XFCE 现在用 GNOME. 4月也捣鼓了下黑苹果. 另外也学习了下 VIM 的使用, 用 VIM 写了一阵子项目, 不过感觉 VIM 还是不太适合写前端. 在编辑器/IDE方面, 从最开始的 Sublime 到 PHPStorm/PyStorm/WebStorm 到现在的 VSCode. 几乎不再使用 M$ OFFICE, 转而使用 Google Docs. 梯子从香港绕到美国又到日本最后又回来香港折腾了一大遍. 手机从安卓阵营调到了苹果阵营, 再也不关心那些安卓破事. 实习篇2016 年 11 月的时候参加了一个 Node 地下铁沙龙. 后来有个人主动加我, 发现他是华工今年毕业的师兄, 现在是一家初创公司的技术总监. 聊得挺好并且刚好我想找下学期的实习, 实习顺利的通过了并且拿到了日薪 300 元的待遇. 这应该是今年一整年我得到的最大的肯定了. 生活篇2016 年上半年, 有不少时间花在创行上面, 但下半年退队了之后, 就一直宅宿舍写代码了, 沉迷代码不能自拔. 上个月一个人去红砖厂走了走放松了下, 最近又去做一件很早之前就想做的事情 – 矫牙, 苦逼的我要拔四颗牙… 现在已经戴上牙套了. 医生说要两年左右. 55555… 好像也没什么好说的, 2016 年都变成技术宅了, 生活方面希望明年这时候可以写的很丰富0.0 进行时2016 年即将结束, 看似我学习了很多东西, 但是学的越多不会的越多. 前段时间正在看 Angular2, Angular2 这一套绑定了 RxJS 和 TypeScript. 本来学了 Vue2 不想搞 NG2 的, 但后来发现 TS 以及 RxJS 这两套东西真心不错, 于是决定上手 Angular2. 毕竟有 Angular1 的老本 Angular2 入门也会相对容易些吧. 另外, 最近也在实现一个 OJ, 使用了 Docker 技术, 目前已经搞定外部 C++ 代码在 Docker 内的执行. 还有就是, 最近在写科技文献阅读的作业, 了解了深度学习的一些分类算法, 感觉也挺有意思的, 也许下年我会在深度学习上面花不少时间也说不定? 未来时2017 年, 计划时间主要花在实习上面, 业余刷一下 LeetCode 以及学一下 Angular2. 有时间的话再看看深度学习的一些分类算法. 然后多花点时间去吃喝玩乐(实习有钱了嘛). 还有贯彻整个上半年的准备暑期 Google 的实习. 17 年上半年的计划大概就是这样. 下半年的话, 到时候再看吧, 现在还说不准哈哈.","categories":[],"tags":[]},{"title":"浅谈 co 库","slug":"浅谈-co-库","date":"2016-11-29T16:28:08.000Z","updated":"2016-11-30T06:14:05.000Z","comments":true,"path":"2016/11/30/浅谈-co-库/","link":"","permalink":"https://ruiming.github.io/2016/11/30/浅谈-co-库/","excerpt":"最近在写一个静态博客框架. 但不同于 hexo 之类的, 框架本身提供了博客书写和管理功能. 后端同样使用了 Koa2 来做, 归功于 Arch, 我已经在使用 Node 7.2 了, 不过好像默认还是不能支持 async 和 await , 经查发现是要输入参数开启的=.=. 不过当时第一时间并没有想说去加参数解决, 而是使用了 co 这个库… 虽然也可以用 babel , 但是通过 babel 运行代码很难调试. co 用起来其实和 async 差不多, 甚至一些地方更简洁, 比如他可以 yield 一个 Promise 数组. 而 async 则只能 await 一个 Promise.all. 其实归根就是 co 进行了一个隐性的转换. co 内可以直接 yeild 一个数组或对象, co 会自动把数组或对象里面的所有值尝试转为 Promise 并包装在 Promise.all 中返回. 1yield [promise1, promise2, ..., promisen] 而 async 要处理多个异步的并行操作, 只能把这些操作手动放入 Promise.all 返回. 即: 1await Promise.all([promise1, promise2, ..., promisen]) 草案还有一个 await* , 这个也是最近才注意到的, 使用 await* 就可以这样写了: 1await* [promise1, promise2, ..., promisen] 然而草案并不推荐 await* , 目前 Node 7.2 也不支持 await* , 不过 babel 支持 ~","text":"最近在写一个静态博客框架. 但不同于 hexo 之类的, 框架本身提供了博客书写和管理功能. 后端同样使用了 Koa2 来做, 归功于 Arch, 我已经在使用 Node 7.2 了, 不过好像默认还是不能支持 async 和 await , 经查发现是要输入参数开启的=.=. 不过当时第一时间并没有想说去加参数解决, 而是使用了 co 这个库… 虽然也可以用 babel , 但是通过 babel 运行代码很难调试. co 用起来其实和 async 差不多, 甚至一些地方更简洁, 比如他可以 yield 一个 Promise 数组. 而 async 则只能 await 一个 Promise.all. 其实归根就是 co 进行了一个隐性的转换. co 内可以直接 yeild 一个数组或对象, co 会自动把数组或对象里面的所有值尝试转为 Promise 并包装在 Promise.all 中返回. 1yield [promise1, promise2, ..., promisen] 而 async 要处理多个异步的并行操作, 只能把这些操作手动放入 Promise.all 返回. 即: 1await Promise.all([promise1, promise2, ..., promisen]) 草案还有一个 await* , 这个也是最近才注意到的, 使用 await* 就可以这样写了: 1await* [promise1, promise2, ..., promisen] 然而草案并不推荐 await* , 目前 Node 7.2 也不支持 await* , 不过 babel 支持 ~ co 的代码其实刚接触异步的时候我就去看了下, 当然当时肯定看不懂. 不过现在回过来看感觉很明了. 其实 co 的实现思路也很简单. co 接收一个 generator, 然后他就可以自动的运行这个 generator 而不需要手动的 yield . co 的实现简要过程: 接受一个 generator generator 封装进 promise 调用该 generator 判断是否可以 next, 如果不可以直接 resolve, 否则下一步 执行 next 操作并取得 next 后的 generator 判断是否已经 done, 如果是则直接 resolve, 否则下一步 递归调用第 2 步 参考以上自己可以结合 co 源码看下. 看看是不是就这么回事. co 内部有一个方法来对 yield 后面的东西进行处理: 123456789function toPromise(obj) &#123; if (!obj) return obj; if (isPromise(obj)) return obj; if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj); if ('function' == typeof obj) return thunkToPromise.call(this, obj); if (Array.isArray(obj)) return arrayToPromise.call(this, obj); if (isObject(obj)) return objectToPromise.call(this, obj); return obj;&#125; 我觉得 yield 可以接一个数组这点很好, 相比起来 async 则要接一个 Promise.all 来处理多个异步的同时运行处理. 123function arrayToPromise(obj) &#123; return Promise.all(obj.map(toPromise, this));&#125; 另外, 它也可以接收对象, 这个不是普通的对象, 这个对象里面的值也会执行上面的 toPromise 方法, 然后用 Promise.all 包装后返回. 这样来看其实 co 除了语义没有 async-await 好其实很多方面都更胜一筹. 最后还有一个 co.wrap 方法, 它用来封装一个 generator. 1234567co.wrap = function (fn) &#123; createPromise.__generatorFunction__ = fn; return createPromise; function createPromise() &#123; return co.call(this, fn.apply(this, arguments)); &#125;&#125; 其实就是把 generator 放在一个方法里面, 当这个方法调用时立即通过 co 自动启动该 generator 而已. 把这个方法返回了用于导出或者其他用途都可以咯. 真的短小精悍… 膜拜 TJ 大神… 但, async-await 势不可挡, 该用还是得用 0.0, 打算把 co 全部替换为 async 去了. 不过 co 这个库的思想和实现还是可以好好看一看滴.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/tags/JavaScript/"},{"name":"co","slug":"co","permalink":"https://ruiming.github.io/tags/co/"}]},{"title":"正确使用 JS 的 sort 方法","slug":"正确使用-JS-的-sort-方法","date":"2016-11-21T08:52:15.000Z","updated":"2016-11-21T09:24:01.000Z","comments":true,"path":"2016/11/21/正确使用-JS-的-sort-方法/","link":"","permalink":"https://ruiming.github.io/2016/11/21/正确使用-JS-的-sort-方法/","excerpt":"sort() 方法对数组的元素做原地的排序, 并返回这个数组. 默认按照字符串的 Unicode 编码排序. sort 排序可能是不稳定的. 但其实 sort 方法可能并没有你想象的那么简单, 不信的话你耐心往下看看. 默认排序sort 方法支持传入一个比较函数, 如果不传入则默认按照其字符串的 Unicode 编码排序, 因此默认情况下会出现以下情况. 12[5, 1, 4, 11, 42].sort()// [1, 11, 4, 42, 5] 解决方法就是: 12[5, 1, 4, 11, 42].sort((pre, curr) =&gt; pre - curr)// [1, 4, 5, 11, 42] pre - curr 的值有三种情况 小于 0 时, curr 排在 pre 后面 大于 0 时, curr 排在 pre 前面 等于 0 时, curr 和 pre 的位置不变 另外, 我们也可以对字符串进行排序: 12['d', 'c', 'b', 'a'].sort()// [a, b, c, d] 可能?是不稳定?因为 ECMAScript 只是制定了 sort 这个方法, 但并没有给出具体的实现方式以及是否需要稳定的要求, sort 的实现就和其他大多数的方法一样由浏览器自行制定. 不同的浏览器或者同个浏览器不同版本上 sort 方法可能是稳定的, 也可能是不稳定的. 这里结合 V8 源码分析下这个 sort 方法的内部调优过程. 在 V8 中, 会通过以下函数方法进入 innerArraySort 中 1234567function ArraySort(comparefn) &#123; CHECK_OBJECT_COERCIBLE(this, \"Array.prototype.sort\"); var array = TO_OBJECT(this); var length = TO_LENGTH(array.length); return InnerArraySort(array, length, comparefn);&#125; 源码有点长, 可以自己看下 这里 注释已经点明了:","text":"sort() 方法对数组的元素做原地的排序, 并返回这个数组. 默认按照字符串的 Unicode 编码排序. sort 排序可能是不稳定的. 但其实 sort 方法可能并没有你想象的那么简单, 不信的话你耐心往下看看. 默认排序sort 方法支持传入一个比较函数, 如果不传入则默认按照其字符串的 Unicode 编码排序, 因此默认情况下会出现以下情况. 12[5, 1, 4, 11, 42].sort()// [1, 11, 4, 42, 5] 解决方法就是: 12[5, 1, 4, 11, 42].sort((pre, curr) =&gt; pre - curr)// [1, 4, 5, 11, 42] pre - curr 的值有三种情况 小于 0 时, curr 排在 pre 后面 大于 0 时, curr 排在 pre 前面 等于 0 时, curr 和 pre 的位置不变 另外, 我们也可以对字符串进行排序: 12['d', 'c', 'b', 'a'].sort()// [a, b, c, d] 可能?是不稳定?因为 ECMAScript 只是制定了 sort 这个方法, 但并没有给出具体的实现方式以及是否需要稳定的要求, sort 的实现就和其他大多数的方法一样由浏览器自行制定. 不同的浏览器或者同个浏览器不同版本上 sort 方法可能是稳定的, 也可能是不稳定的. 这里结合 V8 源码分析下这个 sort 方法的内部调优过程. 在 V8 中, 会通过以下函数方法进入 innerArraySort 中 1234567function ArraySort(comparefn) &#123; CHECK_OBJECT_COERCIBLE(this, \"Array.prototype.sort\"); var array = TO_OBJECT(this); var length = TO_LENGTH(array.length); return InnerArraySort(array, length, comparefn);&#125; 源码有点长, 可以自己看下 这里 注释已经点明了: 123456789101112131415161718function InnerArraySort(array, length, comparefn) &#123; // In-place QuickSort algorithm. // For short (length &lt;= 22) arrays, insertion sort is used for efficiency. if (!IS_CALLABLE(comparefn)) &#123; comparefn = function (x, y) &#123; if (x === y) return 0; if (%_IsSmi(x) &amp;&amp; %_IsSmi(y)) &#123; return %SmiLexicographicCompare(x, y); &#125; x = TO_STRING(x); y = TO_STRING(y); if (x == y) return 0; else return x &lt; y ? -1 : 1; &#125;; &#125; ...&#125; 第一行注释表明这是一个原地排序, 第二行注释说明当数组长度小于 22 时(其实应该是 10 ?), 使用插入排序. 再看上面给出的条件语句, 则是判断有没有传入 comparefn , 如果未传入, 则这里会去获取每两个数的字符串的 Unicode 码进行比较, 按照其字符串的 Unicode 编码实现排序. 12345678910111213141516var QuickSort = function QuickSort(a, from, to) &#123; var third_index = 0; while (true) &#123; // Insertion sort is faster for short arrays. if (to - from &lt;= 10) &#123; InsertionSort(a, from, to); return; &#125; if (to - from &gt; 1000) &#123; third_index = GetThirdIndex(a, from, to); &#125; else &#123; third_index = from + ((to - from) &gt;&gt; 1); &#125; ... &#125;&#125; 当数组长度小于等于 10 时, 直接使用插入排序, 该算法算法复杂度为 O(n2) , 明显是不稳定的 当数组长度大于 10 小于等于 1000 时, 获取 third_index 即中位数. 这里的方法有点屌 1third_index = from + ((to - from) &gt;&gt; 1); 其实就是 from + ( to - from ) / 2 , 以后别用 /2 了, 用 &gt;&gt;1 逼格才高 当数组长度大于 1000 时, 通过 GetThirdIndex 方法获取 third_index 1234567891011121314151617var GetThirdIndex = function(a, from, to) &#123; var t_array = new InternalArray(); // Use both 'from' and 'to' to determine the pivot candidates. var increment = 200 + ((to - from) &amp; 15); var j = 0; from += 1; to -= 1; for (var i = from; i &lt; to; i += increment) &#123; t_array[j] = [i, a[i]]; j++; &#125; t_array.sort(function(a, b) &#123; return comparefn(a[1], b[1]); &#125;); var third_index = t_array[t_array.length &gt;&gt; 1][0]; return third_index;&#125; 这个方法就要好好琢磨琢磨了. 关于 var increment = 200 + ((to - from) &amp; 15) , 这里拿 to 与 from 之差与 15 (2^4 -1) 相与, 为什么是这样写, 我也不太明白 ╮(╯▽╰)╭ , 但这个很明显就是得到一个划分范围. 然后进行划分, t_array 是一个二维数组, 第一维是下标, 第二维是下标对应的数组 a 的值. 这里根据划分值 increment 得到 t_array 这个数组, 其实这个数组就是 a 的划分, 记录了每个划分的第一个数的下标值和数值. 接着这个 t_array 根据第二维即数值来对划分做排序, 然后取中间的划分的下标值 接着的部分到 partition 前的代码, 其实就是做下图的处理 以上其实是一个快速排序的优化算法 – 三数取中( median-of-three ) 正如已知的，快速排序的阿克琉斯之踵在于，最差数组组合情况下会算法退化。 快速排序的算法核心在于选择一个基准 (pivot)，将经过比较交换的数组按基准分解为两个数区进行后续递归。试想如果对一个已经有序的数组，每次选择基准元素时总是选择第一个或者最后一个元素，那么每次都会有一个数区是空的，递归的层数将达到 n，最后导致算法的时间复杂度退化为 O(n²)。因此 pivot 的选择非常重要。 v8采用的是 三数取中(median-of-three) 的优化：除了头尾两个元素再额外选择一个元素参与基准元素的竞争。 第三个元素的选取策略大致为： 当数组长度小于等于1000时，选择折半位置的元素作为目标元素。 当数组长度超过1000时，每隔200-215个(非固定，跟着数组长度而变化)左右选择一个元素来先确定一批候选元素。接着在这批候选元素中进行一次排序，将所得的中位值作为目标元素 最后取三个元素的中位值作为 pivot。 其实 Chrome 的快速排序也是饱受争议, 因为在此之前 JavaScript 的 sort 实现都是稳定的, Firefox 中使用的是归并排序, 归并排序是稳定的. 但至今 Chrome 还是坚持不稳定的快速排序算法 O__O “… 后面就是快速排序的算法了. 快速排序大概的步骤就是遍历数组, 将基准值插入到正确的位置中去, 然后以该位置左右划分, 以此递归进行下去. 常见误用虽然 Chrome 和 Firefox 的 sort 方法实现不同, 但其实并没有什么影响. 但仍然有不少人会发现在 Chrome 的排序结果是错的, Firefox 则是正常的. 我没有去看 Firefox 的实现, 但是我大概知道为什么他们会出错． 其实大部分人都错在了 Chrome 下的 compareFn 要求返回值有三种情况, 正, 负和0. 而不少人则是返回 true 或 false. 看看下面这段代码, 这里是快速排序才需要进入的. 1234567891011121314151617var c02 = comparefn(v0, v2);if (c02 &gt;= 0) &#123; // v2 &lt;= v0 &lt;= v1. var tmp = v0; v0 = v2; v2 = v1; v1 = tmp;&#125; else &#123; // v0 &lt;= v1 &amp;&amp; v0 &lt; v2 var c12 = comparefn(v1, v2); if (c12 &gt; 0) &#123; // v0 &lt;= v2 &lt; v1 var tmp = v1; v1 = v2; v2 = tmp; &#125;&#125; 在 JavaScript 中, false &gt;=0 和 true &gt;=0 都是成立的. 既然如此, 那么 c02 这里就永远取第一条了. sort 方法返回值分为三种, 大于0, 小于0, 等于0. 不要再返回 true 或返回 false 了. 之所以你返回 true 或 false 也可以运行起来那只是因为 JavaScript 隐性的类型转换以及运气好, 没碰到快排而已=.= 比如以下代码在 Chrome 中的执行结果, 由于 Node 也是使用 V8, 所以 Node 也会有同样的问题 1234567var a = [15, 51, 24, 95, 26, 88, 6, 14, 18, 11]a.sort((pre, curr) =&gt; pre &gt; curr)// [6, 11, 14, 15, 18, 24, 26, 51, 88, 95]var a = [15, 51, 24, 95, 26, 88, 6, 14, 18, 11, 17]a.sort((pre, curr) =&gt; pre &gt; curr)// [88, 15, 11, 14, 6, 17, 18, 24, 26, 51, 95] 现在就可以解释了, 在 Chrome 中, 小于等于 10 的时候是插入排序, 排序正常, 但大于 10 的时候, 是快速排序, 如果函数返回值只有 true 或 false 那么就不正常了. 由于 Firefox 使用归并排序, 所以 Firefox 没有这个问题. sort 方法还有常见的一个误用就是用于随机排序. 1[...].sort(() =&gt; Math.round(Math.random())-0.5) 这并不能做到完全随机, 首先各个浏览器的 sort 方法实现就不同, 并且也不能证明其能进行随机的排序. 真的要进行完全随机的排序的话, 还是得使用洗牌算法, 它是一种等概率随机的 In-place 排列算法. 具体的实现可以自己去网上搜下~ 参考资料: 聊聊前端排序的那些事 array.js Array.sort Sorting Stability in Different Browsers","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/tags/JavaScript/"},{"name":"Node","slug":"Node","permalink":"https://ruiming.github.io/tags/Node/"},{"name":"V8","slug":"V8","permalink":"https://ruiming.github.io/tags/V8/"},{"name":"Sort","slug":"Sort","permalink":"https://ruiming.github.io/tags/Sort/"}]},{"title":"聊聊 Webpack 使用","slug":"聊聊-Webpack-使用","date":"2016-11-17T05:24:47.000Z","updated":"2017-01-05T09:24:25.233Z","comments":true,"path":"2016/11/17/聊聊-Webpack-使用/","link":"","permalink":"https://ruiming.github.io/2016/11/17/聊聊-Webpack-使用/","excerpt":"老早的时候就听说了 Webpack 这个工具, 当时大概的印象就是类似 Gulp 这样的东西, 并且看起来好像挺复杂的. 直到学习 React 的时候才开始接触 Webpack, 才知道 Webpack 更多的是做模块化的工作. 不过当时也是乱配置一通能用就行=.=. 现在 Vue 标配也是用 Webpack 了. Webpack 其实并没有想象中的那么复杂, 其实最核心的还是 loader 那一块. 这次就主要聊一聊 Webpack. 我用的是 Webpack 最新版本 2.1.0-beta.27. LoaderLoader 是 Webpack 的核心, 它会自动查找项目中的我们指定的文件类型, 然后使用我们指定的 Loader 进行处理. 例如: 1234567891011121314151617181920212223242526272829module: &#123; rules: [&#123; test: /\\.vue$/, loader: 'vue-loader', options: &#123; loaders: &#123; css: ExtractTextPlugin.extract(&#123; loader: ['css-loader?minimize', 'postcss-loader'], fallbackLoader: 'vue-style-loader' &#125;) &#125; &#125; &#125;, &#123; test: /\\.js$/, loader: 'babel-loader', exclude: /node_modules/ &#125;, &#123; test: /\\.css$/, loader: ExtractTextPlugin.extract(&#123; loader: ['css-loader?minimize', 'postcss-loader'] &#125;) &#125;, &#123; test: /\\.(eot|woff|woff2|ttf)([\\?]?.*)$/, loader: 'file-loader' &#125;, &#123; test: /\\.(png|jpg|gif|svg|ico)$/, loader: 'url-loader?limit=8192', &#125;]&#125;, 对于 Vue 文件, 我们要让 vue-loader 来处理, 这里可以先忽略 ExtractTextPlugin 部分, 它作用是提取 CSS 这个在后面会提. 对于 .js 文件, 我们使用 babel-loader 来处理, 我们可以在项目配置一个 .babelrc 文件来指定我们使用的 presets 和 plugins.","text":"老早的时候就听说了 Webpack 这个工具, 当时大概的印象就是类似 Gulp 这样的东西, 并且看起来好像挺复杂的. 直到学习 React 的时候才开始接触 Webpack, 才知道 Webpack 更多的是做模块化的工作. 不过当时也是乱配置一通能用就行=.=. 现在 Vue 标配也是用 Webpack 了. Webpack 其实并没有想象中的那么复杂, 其实最核心的还是 loader 那一块. 这次就主要聊一聊 Webpack. 我用的是 Webpack 最新版本 2.1.0-beta.27. LoaderLoader 是 Webpack 的核心, 它会自动查找项目中的我们指定的文件类型, 然后使用我们指定的 Loader 进行处理. 例如: 1234567891011121314151617181920212223242526272829module: &#123; rules: [&#123; test: /\\.vue$/, loader: 'vue-loader', options: &#123; loaders: &#123; css: ExtractTextPlugin.extract(&#123; loader: ['css-loader?minimize', 'postcss-loader'], fallbackLoader: 'vue-style-loader' &#125;) &#125; &#125; &#125;, &#123; test: /\\.js$/, loader: 'babel-loader', exclude: /node_modules/ &#125;, &#123; test: /\\.css$/, loader: ExtractTextPlugin.extract(&#123; loader: ['css-loader?minimize', 'postcss-loader'] &#125;) &#125;, &#123; test: /\\.(eot|woff|woff2|ttf)([\\?]?.*)$/, loader: 'file-loader' &#125;, &#123; test: /\\.(png|jpg|gif|svg|ico)$/, loader: 'url-loader?limit=8192', &#125;]&#125;, 对于 Vue 文件, 我们要让 vue-loader 来处理, 这里可以先忽略 ExtractTextPlugin 部分, 它作用是提取 CSS 这个在后面会提. 对于 .js 文件, 我们使用 babel-loader 来处理, 我们可以在项目配置一个 .babelrc 文件来指定我们使用的 presets 和 plugins. Webpack 我觉得一个不太好的地方就是写法很多, 而且那么多种写法大体是一样的, 但是在一些场景下它们可能又会有区别, 就不能统一一下吗? 例如, 如果我们使用了 Sass, 那常用的两种写法如下: 12345678910111213// 写法1&#123; test: /\\.scss$/, loader: 'css-loader!sass-loader'&#125;// 写法2&#123; test: /\\.scss$/, loader: [ 'css-loader', 'sass-loader' ]&#125; 我们可以使用 ! 来连接多个 loader, 它们会自右向左执行. 另外, -loader 可以省略不写, 但在 Webpack2 中推荐写上. 如果不加 -loader 的话在一些场景下它会出错. devServer这个是 webpack 另一个强大的地方了. Webpack-dev-server 是一个小型的 node.js Express 服务器, 通过 websocket 可以实现浏览器的模块热替换. 即前端代码变动的时候无需刷新整个页面, 而只是把变化的部分替换掉. 关于这个热替换, 其实也有好几种配置方法, 这里我只说我用的情况. 1234567891011121314151617181920212223242526272829devServer: &#123; hot: true, // 热替换 historyApiFallback: true, // HTML5 Mode port: 7000, // 端口 proxy: &#123; // 代理 '/api/*': &#123; target: 'http://127.0.0.1:3000' &#125;, '/auth/*': &#123; target: 'http://127.0.0.1:3000' &#125;, '/img/*': &#123; target: 'http://127.0.0.1:3000' &#125;, '/css/*': &#123; target: 'http://127.0.0.1:3000' &#125;, '/fonts/*': &#123; target: 'http://127.0.0.1:3000' &#125;, '/js/*': &#123; target: 'http://127.0.0.1:3000' &#125;, '/favicon/*': &#123; target: 'http://127.0.0.1:3000' &#125; &#125;, &#125;&#125; 这里的 proxy 也是 webpack-dev-server 一个强大的地方之一, 我们可以配置一些代理来避免跨域问题和端口不一致的问题. 接着运行即可 1webpack-dev-server --hot --open --inline --progress 减少打包体积Webpack 在开发环境打包的体积非常大, 因为其包含了 source-map 等. 我们在生产环境并不需要它, 可以如下配置: 123&#123; devtool: isProduction() ? false : '#eval-source-map'&#125; 除了这点, 有时候我们还想生产环境使用 CDN, 开发环境使用本地的资源. CDN 可以通过 externals 配置 123456789&#123; externals = &#123; 'vue': 'Vue', 'underscore': '_', 'vue-resource': 'VueResource', 'vue-router': 'VueRouter', 'vuex': 'Vuex' &#125;&#125; 同时不要忘记了在 index.html 中把各文件的 CDN 链接导入. 区分两个环境我们可以建立两个配置文件, 或者简单的通过条件语句判断. 这样处理后生产环境和开发环境的 index.html 就有了比较大的区别, 我处理方式是建立了两个 index.html 一个用于开发环境一个用于生产环境, 再者他们刚好也位于不同的位置, 开发环境从根目录加载 index.html , 而生产环境则有后端根据 UA 指向 public 下的 index.html 再有的优化就是进行 JavaScript 代码的压缩混淆, 当然这个也只推荐在生产环境中使用: 123456789plugins.push( // 生产环境压缩 JavaScript 代码 new webpack.optimize.UglifyJsPlugin(&#123; test: /(\\.vue|\\.js)$/, compress: &#123; warnings: false &#125;, &#125;)) 导入这个插件即可 另外还有 CSS 的压缩: 123456&#123; test: /\\.css$/, loader: ExtractTextPlugin.extract(&#123; loader: ['css-loader?minimize', 'postcss-loader'] &#125;)&#125; 只要在 css-loader 后面加上 ?minimize 就好了. 提取 CSS就上面那段代码, 用到了 ExtractTextPlugin 这个插件, 它就是用来分离 CSS 代码的, 我们需要安装这个插件, 然后在 Webpack 中导入. 使用方法就上面这样, 但还要做一个配置: 123456plugins.push( new ExtractTextPlugin(&#123; filename: isProduction() ? 'style.[contenthash:4].css' : 'style.css', allChunks: true, &#125;)) 导入这个插件, 并配置文件名. 之后他就会在我们的 output 处输出这个 CSS 文件. 我这里不仅仅是要处理 CSS 文件, 还要处理 .vue 中的 CSS 样式. 123456789101112&#123; test: /\\.vue$/, loader: 'vue-loader', options: &#123; loaders: &#123; css: ExtractTextPlugin.extract(&#123; loader: ['css-loader?minimize', 'postcss-loader'], fallbackLoader: 'vue-style-loader' &#125;) &#125; &#125;&#125; 注意 Webpack2 最新版本 API 想比 Webpack1 有较大变化. Webpack2 不支持在配置文件中插入其他东西, 如果你想对这个 loader 进行进一步配置, 需要在 options 中配置. 这里对 vue-loader 进行了进一步配置, 加入了 postcss-loader 和 css-loader . postcss-loader 也是一个比较坑的地方, 在 Webpack2 最新版本已经不支持使用 postcss.config.js 文件的配置, 你需要自己在 Webpack 中配置这个插件. 123456789plugins.push( new webpack.LoaderOptionsPlugin(&#123; options: &#123; postcss: [ require('postcss-nested'), require('postcss-cssnext') ] &#125;&#125;)) 插入这个插件后后面才可以正常使用 postcss-loader 我们同时处理了 .css 和 .vue 中的 css 并最终生成了一个 CSS 文件. 这里在生产环境会生成 style.[contenthash:4].css , contenthash 是根据文件内容生成的, 在文件名加入其哈希值后, 我们就可以大胆的最样式表进行长期缓存, 因为样式表内容一变化文件名也变了. 文件名嵌入哈希值除了 CSS 处理外, 我们还要对 JavaScript 进行处理, 这个是在 output 中配置的: 1234567&#123; output = &#123; path: path.resolve(__dirname, './public/static/'), publicPath: '/static/', filename: 'build.[chunkhash:4].js' &#125;&#125; 注意这里用的是 chunkhash , 我们在 CSS 中用的则是 contenthash 最后我们就会生成如下的文件名: 12style.dd51.cssbuild.84e5.js 但这样做是不够的, 我们不能每次都自己手动修改 index.html , 我们要让 index.html 中的文件哈希值也自动变化. 这个可以通过自定义插件来做, 我是直接参考了别人写的, 并没有深入去了解(仅供参考, 下面有说更好的方法) 1234567891011121314151617181920212223plugins.push( function () &#123; this.plugin('done', function (statsData) &#123; var stats = statsData.toJson() if (!stats.errors.length) &#123; var html = fs.readFileSync('./public/index.html', 'utf8') var htmlOutput = html.replace( /static\\/(.+?)\"&gt;/g, function (word) &#123; let filename = word.split('/')[1].split('.')[0] for (let i = 0; i &lt; stats.assetsByChunkName.main.length; i++) &#123; if (stats.assetsByChunkName.main[i].indexOf(filename) !== -1) &#123; return 'static/' + stats.assetsByChunkName.main[i] + '\"&gt;' &#125; &#125; &#125;) fs.writeFileSync( './public/index.html', htmlOutput) &#125; &#125;) &#125;) 这里的正则和路径都是根据自己项目的情况做出来的. 大致的意思就是监听插件的 done 事件, 然后传入 statsData 到这个插件的回调函数里, 如果没有出错, 那么获取得到 webpack 生成的文件名即上面说的文件名如 style.dd51.css, 即 stats.assetsByChunkName.main 这个数组. 这个数组保存着 webpack 生成的文件名, 接着我们获取 index.html 并用正则获取所有的 script 和 style , 我这里的处理措施是得到文件名如 style , 然后在 stats.assetsByChunkName 中查找包含这个串的输出文件名, 将这个文件名替换原来的即可. // 2017.1.5 更新 其实还有更简便的方法, 使用 HtmlWebpackPlugin 插件, 然后进行下面的配置: 12345new HtmlWebpackPlugin(&#123; template: 'public/index.html', filename: '../index.html', inject: 'head'&#125;) Webpack 在运行过程提取出的 chunk, 自动输出到 public/index.html 的 head 中. 然后存储到 output 设置的 publicPath 中, 因为 index.html 通常存放在资源外面, 所以这里文件名进行了相对路劲的处理. 到这一步不得不感慨 Webpack 的强大, 上面我说的有点乱, 可以在这里(最新的配置文件已经发生了改变)查看我的详细 webpack 配置. 这里没有细说每个配置的每个选项, 这些选项有些我自己也还搞不太明白, 最近还要再好好看下里面一些选项的细微区别. 总结下, 上面的 Webpack 帮我们做了这些事情: 模块化 一切皆模块, 只要有 loader. 我们可以在我们的 JS 文件中导入 CSS, 图片等资源. Webpack 会自动帮我们做处理. 只要你想的话, 你还可以用 CSS in JS. 如果你单独分离 CSS, 那么最终生成的就是一个 JavaScript 文件. 使用 Babel 和 PostCSS 在 Webpack 中使用 babel-loader 处理 .js 和 .vue 文件, 我们就可以任性的写 ES6 和 ES7 了. 给 .css 和 vue-loader 加入 post-loader 后我们就可以任性的使用 cssnext 等特性了. 原本我是用 sass-loader 的, 但是我主要用的嵌套功能其实 postcss-loader 也可以处理, 并且我挺喜欢 postcss-loader 的丰富插件这个特性. 从此抛开 CSS 预处理器. 压缩合并 JS 和 CSS 不需要使用 Gulp 了. Webpack 对 JS 和 CSS 的压缩合并处理不能再简单了. 代理服务器 反向代理了我们的 API, 避免了端口修改和跨域的问题. 文件哈希名 给 CSS 和 JS 嵌入了哈希值, 并且自动替换 index.html 中的路径文件. 恩, 不愧是前端模块化和自动化利器.","categories":[{"name":"Webpack","slug":"Webpack","permalink":"https://ruiming.github.io/categories/Webpack/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"https://ruiming.github.io/tags/Vue/"},{"name":"Webpack","slug":"Webpack","permalink":"https://ruiming.github.io/tags/Webpack/"}]},{"title":"使用 Koa2 开发小结","slug":"使用-Koa2-开发小结","date":"2016-11-14T16:00:16.000Z","updated":"2016-11-17T05:30:58.000Z","comments":true,"path":"2016/11/15/使用-Koa2-开发小结/","link":"","permalink":"https://ruiming.github.io/2016/11/15/使用-Koa2-开发小结/","excerpt":"RSS 订阅器项目是我最近花时间比较多的一个项目了. 在这个项目中我使用了大量的新技术, 很多技术都是我第一次使用. 后端是基于 Koa2 和 Mongoose 的 RESTful API. 在这个项目开展前, 我已经有半年多没接触后端了. 上一次后端还是用 PHP 以及 Laravel 框架开发的 LNMP 架构. 在动工前, 我也没有正式的使用过 Node 以及其部署, 对于 Koa2 的 async await 的异步书写方式也只是久仰大名而已. 这篇博客主要想说一说自己在使用 Node.js 和 Koa2 开发后端过程中的一些总结和收获. 中间件Koa2 本身是一个非常轻的框架, 我们需要使用大量的中间件去完善它, 例如 koa-bodyparser , koa-etag, koa-router, koa-sslify 等等. 同时, 肯定免不了自己写中间件, 例如我自己就写了 7 个中间件, 分别是处理缓存, 处理 cookies, 强制 www, 配合前端 HTML5Mode, 错误处理, UA 判断, JWT 和 XSRF 处理. 12345678910111213module.exports = function () &#123; return async(ctx, next) =&gt; &#123; if (/^\\/(mark|square|feed|feeds|post|posts|me|search)/.test(ctx.request.url)) &#123; if (ctx.mobile) &#123; await send(ctx, './public/index.html') &#125; else &#123; await send(ctx, './public/pc.html') &#125; &#125; await next() &#125;&#125; 上述就是配合前端 HTML5Mode 以及根据 UA 指向不同入口文件的中间件.","text":"RSS 订阅器项目是我最近花时间比较多的一个项目了. 在这个项目中我使用了大量的新技术, 很多技术都是我第一次使用. 后端是基于 Koa2 和 Mongoose 的 RESTful API. 在这个项目开展前, 我已经有半年多没接触后端了. 上一次后端还是用 PHP 以及 Laravel 框架开发的 LNMP 架构. 在动工前, 我也没有正式的使用过 Node 以及其部署, 对于 Koa2 的 async await 的异步书写方式也只是久仰大名而已. 这篇博客主要想说一说自己在使用 Node.js 和 Koa2 开发后端过程中的一些总结和收获. 中间件Koa2 本身是一个非常轻的框架, 我们需要使用大量的中间件去完善它, 例如 koa-bodyparser , koa-etag, koa-router, koa-sslify 等等. 同时, 肯定免不了自己写中间件, 例如我自己就写了 7 个中间件, 分别是处理缓存, 处理 cookies, 强制 www, 配合前端 HTML5Mode, 错误处理, UA 判断, JWT 和 XSRF 处理. 12345678910111213module.exports = function () &#123; return async(ctx, next) =&gt; &#123; if (/^\\/(mark|square|feed|feeds|post|posts|me|search)/.test(ctx.request.url)) &#123; if (ctx.mobile) &#123; await send(ctx, './public/index.html') &#125; else &#123; await send(ctx, './public/pc.html') &#125; &#125; await next() &#125;&#125; 上述就是配合前端 HTML5Mode 以及根据 UA 指向不同入口文件的中间件. Koa2 的错误处理非常友好, 可以通过以下这样一个中间件来统一处理错误, 我们可以在这里捕捉到代码运行的大部分错误, 包括异步过程中的错误, 以及自己在代码中抛出的错误, 然后在这里统一的进行处理. 123456789module.exports = function () &#123; return async(ctx, next) =&gt; &#123; try &#123; await next() &#125; catch (err) &#123; &#125; &#125;&#125; 其实中间件听起来高大上其实并没什么, 你也可以直接写到 Koa 的入口文件, 但是比较好的风格是把他们都提取出来, 然后入口文件导入这些中间件进行 use 即可. HTTP2Koa2 使用 HTTP2 也非常简单. 1234567891011http.createServer(app.callback()).listen(config.PORT)// Production Onlyif (config.ENV === 'production') &#123; const options = &#123; key: config.APP.SSL_KEY, cert: config.APP.SSL_CERT, ca: config.APP.CA &#125; http2.createServer(options, app.callback()).listen(443)&#125; 我们可以配置两个配置文件分别作用于生产环境和开发环境, 然后在入口文件根据不同的环境使用即可. 另外也可以很方便的通过使用 koa-helmet 来配置 HSTS Promise虽然, Node 的主流版本都支持 Promise 了, 但是似乎原生的 Promise 仍然比 Bluebird 慢并且更消耗内存. 所以推荐使用 Bluebird 替代原生 Promise. 具体原因可以查看 [Why are native ES6 promises slower and more memory-intensive than bluebird? 可以把 mongoose 和全局的 promise 都换成 bluebird. 与此同时我们还获得了更加丰富的 Promise 方法如 promisify, 不用白不用. 12mongoose.Promise = require('bluebird')global.Promise = require('bluebird') JWTJWT 已经在前面的博客中提到过了, 我认为 JWT 保存 cookie 并设置 httpOnly, 同时传输非 httpOnly 的 XSRF-TOKEN 这种认证方式是比较妥当的. 如果使用了 HTTPS, 还可以同时设置 secure. NPM scriptsnpm scripts 非常好用, 我们可以自定义很多命令在里面. 例如我在项目中常用的: 1234567891011\"start\": \"pm2 start production.json\",\"dev\": \"pm2 start development.json\",\"angular\": \"pm2 start development.json\",\"vue\": \"webpack-dev-server --hot --open --inline --progress\",\"angular-dist\": \"gulp build\",\"vue-dist\": \"NODE_ENV=production webpack --progress\",\"build\": \"npm run angular-dist &amp; npm run vue-dist\",\"db\": \"mongod --dbpath='/root/db' --rest\",\"generatessl\": \"./certbot-auto certonly --webroot -w /root/rss -d enjoyrss.com -d www.enjoyrss.com\",\"updatessl\": \"./certbot-auto renew --quiet\",\"cron\": \"crontab ./utils/cron\" 在部署生成环境时运行 npm run build 构建最新版本, 运行 npm run updatessl 更新 SSL 证书, 运行npm start 来启动项目, 运行 npm run db 开启数据库. Babel用了 Babel 之后, 就可以随心所欲的书写 ES6 甚至 ES7 了. 我用的比较多的是 import , for...of... , async 以及解构赋值, 属性名表达式, 数组扩展符, 对象扩展符等等. 解构赋值和属性名表达式可以大大减少代码量, 写起来特别爽. 123456789101112131415161718192021exports.list = async (ctx, next) =&gt; &#123; let &#123; order, limit, page, per_page, desc &#125; = ctx.request.query let result = await FeedModel.find() .sort(&#123; [order]: desc === 'true' ? '1' : '-1' &#125;) .skip(+page * +per_page) .limit(+per_page || +limit) ctx.body = &#123; success: true, data: result &#125;&#125; 数组扩展符和对象扩展符也很方便, 不用再使用 Array.concat 和 Object.assign 方法了. 1234567891011121314151617// 数组扩展符var a = [1, 2, 3]var b = [4, 5, 6]var c = [...a, 4, 5] // [1, 2, 3, 4, 5]var d = [...a, ...b] // [1, 2, 3, 4, 5, 6]// 对象扩展符var feed = &#123; _id: 123456, title: 'kkkk', unread: 6&#125;var result = &#123; ...feed, feed_id: 111111, unread: 10&#125;// result: &#123; _id: 123456, title: 'kkkk', unread: 10, feed_id: 11111 &#125; Async 异步函数也不是万能的, 它无法处理多个异步函数的同步处理问题. 这时候就要借助 Promise.all 了. 1234567await Promise.all([ Promise.resolve().then(async () =&gt; state = await UserPostModel.findOne(&#123; user_id, post_id: item &#125;)), Promise.resolve().then(async () =&gt; res = await PostModel.findById(item))]) 缓存缓存在 Web 中非常重要 1234567891011121314import &#123; SHA256 &#125; from 'crypto-js'module.exports = function () &#123; return async (ctx, next) =&gt; &#123; if (ctx.request.method === 'GET') &#123; if (/js|css|favicon|image/.test(ctx.path)) &#123; ctx.cacheControl = &#123; maxAge: 60 * 60 * 24 * 180 &#125; &#125; &#125; await next() &#125;&#125; 这个中间件给图片和文件设置了长达 180 天的缓存时间, 其实这里永久存储都 OK 了. 因为我的 JS 和 CSS 文件变化的话文件名和路径都变了, 图片是稳定不变的即使变了它的文件名也会变化. 因此我可以大胆的这样使用. 大部分工作我是交给了 koa-etag 和 koa-cache-control 这两个中间件来处理了. 现在项目我除了后端做好缓存之外, 前端也是进行了 JavaScript 的内存缓存和自动更新从而减少了请求数. 这样就大大减少了服务器的压力以及提升了用户的访问速度和体验. PM2PM2 是一个带有负载均衡功能的应用进程管理器. 我们可以用它来管理我们的 Node 进程, 它的用法也很简单. 使用 PM2 可以充分发挥服务器多核的特性(如果有的话), 并且实现0秒重载以及进程信息监控等. PM2 是比较通用的 Node 部署方式. 代码共用由于前后端都是使用 JavaScript 这门语言, 不仅包管理统一, 大量的包如 Underscore 也可以前后端共用, 最方便的是大部分的工具函数也可以前后端一起使用, 例如检测邮箱和密码格式我们在前端做检测的同时, 后端也可以直接调用过来. 例如下面这个文件就可以同时在前端 Vue, Angular 以及后端中同时使用. 12345678910111213141516171819202122232425262728(function () &#123; var help = &#123; // 检测 URL 是否合法 checkUrl(url) &#123; let re = /https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]&#123;2,256&#125;\\.[a-z]&#123;2,6&#125;\\b([-a-zA-Z0-9@:%_\\+.~#?&amp;//=]*)/ return re.test(url) &#125;, // 检测邮箱是否合法 validateEmail(email) &#123; let re = /\\S+@\\S+\\.\\S+/ return re.test(email) &#125;, // 检验密码是否合法 validatePassword(password) &#123; let re = /\\w&#123;6,18&#125;/ return re.test(password) &#125; &#125; // In angular, the module name is app.tools, and the factory name is tools. if (typeof module !== 'undefined' &amp;&amp; module.exports) &#123; module.exports = help &#125; else &#123; angular.module('app.tools', []).factory('tools', function () &#123; return help &#125;) &#125;&#125;()) 其实写 Node 相比起写前端要简单好多好多, 没有什么 Gulp, Webpack, 不用考虑文件体积和大小, 不用考虑模块化组件化之类的问题, 不用考虑客户端浏览器类型和浏览器版本, 不用追求各种极限速度(现在的自动雪碧图处理, 文件懒加载和前端框架的服务端渲染真的是没谁了…). 在 LNMP 架构中, 我们要使用 Nginx 来帮我们处理静态文件, 配置 PHP-FPM 来处理 PHP 请求. Gzip 和 HTTPS 等等都是在 Nginx 中配置. 其实这些事情 Node 都可以做了. 但并不意味着 Node 可以取代 Nginx, Nginx 不仅是一个 Web 服务器也是一个反向代理服务器. 必要的时候我们还是要使用 Nginx 来做一个反向代理. 以上.","categories":[{"name":"Node","slug":"Node","permalink":"https://ruiming.github.io/categories/Node/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/tags/JavaScript/"},{"name":"Koa","slug":"Koa","permalink":"https://ruiming.github.io/tags/Koa/"},{"name":"Node","slug":"Node","permalink":"https://ruiming.github.io/tags/Node/"}]},{"title":"使用 ESLint 规范你的代码","slug":"使用-ESLint-规范你的代码","date":"2016-11-08T04:57:39.000Z","updated":"2016-11-09T04:22:05.000Z","comments":true,"path":"2016/11/08/使用-ESLint-规范你的代码/","link":"","permalink":"https://ruiming.github.io/2016/11/08/使用-ESLint-规范你的代码/","excerpt":"在一些多人参与的项目开发中, 每个人代码习惯不同, 对于缩进, 有人习惯 TAB, 有人习惯两个空格, 有人习惯四个空格. 对于分号, 有人不加, 有人习惯加, 而习惯加分号的人又会经常漏加分号. 试想一个项目代码如果由各种群魔乱舞的风格组成, 这必然会带来一定的视觉障碍(强迫症的人看了受不了=.=), 并且显得代码质量低下. 即使是个人, 偶尔也会写出一些不太规范的代码, 比如变量声明了未使用, 比如使用了 == 等等, 更不要说各种代码格式如操作符左右空格, if ... else 的格式, 末行换行等等. 特别是像有强迫症的我, 有时候写的过程可能会不小心遗漏或写错, 但发现的时候又会去改过来. 如果能在书写过程中检查出不规范的地方提示岂不是最好? ESLint 是一个插件化的 JavaScript 代码检查工具, 可以用于检查常见的 JavaScript 代码错误, 规范 JavaScript 代码的书写, 可以有效控制代码的质量. ESLint 规则ESLint 使用非常简单, 安装好 ESLint 后, 可以自定义一套规则文件或者使用开源的代码风格规范, 像 Google, Airbnb 都有开源的 JavaScript 代码书写规范. 可以直接使用它们的, 也可以自己配置. 具体的用法可以参考官方文档, 其实蛮简单的. 这里列出了 ESLint 的各种规则, 可以参考下这里的说明. 以下是我个人配置的规则","text":"在一些多人参与的项目开发中, 每个人代码习惯不同, 对于缩进, 有人习惯 TAB, 有人习惯两个空格, 有人习惯四个空格. 对于分号, 有人不加, 有人习惯加, 而习惯加分号的人又会经常漏加分号. 试想一个项目代码如果由各种群魔乱舞的风格组成, 这必然会带来一定的视觉障碍(强迫症的人看了受不了=.=), 并且显得代码质量低下. 即使是个人, 偶尔也会写出一些不太规范的代码, 比如变量声明了未使用, 比如使用了 == 等等, 更不要说各种代码格式如操作符左右空格, if ... else 的格式, 末行换行等等. 特别是像有强迫症的我, 有时候写的过程可能会不小心遗漏或写错, 但发现的时候又会去改过来. 如果能在书写过程中检查出不规范的地方提示岂不是最好? ESLint 是一个插件化的 JavaScript 代码检查工具, 可以用于检查常见的 JavaScript 代码错误, 规范 JavaScript 代码的书写, 可以有效控制代码的质量. ESLint 规则ESLint 使用非常简单, 安装好 ESLint 后, 可以自定义一套规则文件或者使用开源的代码风格规范, 像 Google, Airbnb 都有开源的 JavaScript 代码书写规范. 可以直接使用它们的, 也可以自己配置. 具体的用法可以参考官方文档, 其实蛮简单的. 这里列出了 ESLint 的各种规则, 可以参考下这里的说明. 以下是我个人配置的规则 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129&#123; \"env\": &#123; \"browser\": true, \"commonjs\": true, \"es6\": true, \"node\": true &#125;, \"parser\": \"babel-eslint\", \"extends\": \"eslint:recommended\", \"plugins\": [ \"babel\" ], \"parserOptions\": &#123; \"sourceType\": \"module\" &#125;, \"globals\": &#123; \"angular\": true, \"d3\": true, \"ga\": true &#125;, \"rules\": &#123; // 4空格缩进 auto \"indent\": [ \"error\", 4 ], // unix 换行风格 auto \"linebreak-style\": [ \"error\", \"unix\" ], // 强制单引号 auto \"quotes\": [ \"error\", \"single\" ], // 禁止分号 auto \"semi\": [ \"error\", \"never\" ], // 变量定义或参数声明未使用 \"no-cond-assign\": [ \"warn\" ], // 强制 !== 和 ===, 和 null 或 undefined 比较例外 \"eqeqeq\": [ \"error\", \"allow-null\" ], // 强制大括号风格 auto \"curly\": [ \"error\", \"all\" ], // 强制末尾换行 auto \"eol-last\": [ \"error\" ], // 关键字空格 auto \"keyword-spacing\": [ \"error\", &#123; \"before\": true, \"after\": true &#125; ], // 强制单行代码块中使用空格 auto \"block-spacing\": [ \"error\", \"always\" ], // 逗号前面不能由空格, 后面要空格 auto \"comma-spacing\": [ \"error\", &#123; \"before\": false, \"after\": true &#125; ], // 冒号前面不能有空格, 后面必须有空格, 键值需水平对齐 auto \"key-spacing\": [ \"error\", &#123; \"beforeColon\": false, \"afterColon\": true, \"align\": \"value\" &#125; ], // 参数未使用提示 \"no-unused-vars\": [ \"warn\", &#123; \"var\": \"all\", \"all\": \"all\" &#125; ], // 禁用行尾空格 auto \"no-trailing-spaces\": [ \"error\", &#123; \"skipBlankLines\": true &#125; ], // 函数左括号左边不能有空格 auto \"space-before-function-paren\": [ \"error\", &#123; \"anonymous\": \"always\", \"named\": \"never\" &#125; ], // 操作符周围有空格 auto \"space-infix-ops\": [ \"error\", &#123; \"int32Hint\": false &#125; ], \"babel/generator-star-spacing\": 1, \"babel/new-cap\": 1, \"babel/array-bracket-spacing\": 1, \"babel/object-shorthand\": 1, \"babel/no-await-in-loop\": 1, \"babel/flow-object-type\": 1, \"babel/func-params-comma-dangle\": 1, \"no-console\": \"off\" &#125;&#125; 建议 parser 换成 babel-eslint, 并加入了 babel 这个插件, 为的是可以解析 ES6 和 ES7 的一些语法. 这里使用的是默认的规则文件 eslint:recommended. 这样对代码的约束比较少, 有更多的灵活性. 默认的规则是禁止代码内出现 console.log 的, 需要用的可以通过 &quot;no-console&quot;: &quot;off&quot; 关闭. 举几个例子说明下: qutoes 我习惯在 JavaScript 的字符串中使用单引号, 这个也看个人了, 单引号比双引号容易打 semi JavaScript 中分号是没必要的, 因为经常会漏加分号, 并且好像不用分号看起来更简洁好看些, 所以干脆就都不加了 no-cond-assign 变量定义或参数声明后未使用, 这是不太规范的, 但我这里使用的 warn 而不是 error eqeqeq 强制 !== 和 == , 除了和 null 与 undefined 比较外, 因为 null == undefined, 对于判断一个变量是否为 null 或 undefined 时 == 比较好用 curly 强制大括号风格, 即要求控制语句不能省略大括号, 我喜欢统一的大括号, 不喜欢一会写一会不写的样子 eol-last 强制末尾换行, 习惯了, 但有时候也会忘记或者空了好几行, 加这个约束一下 keyword-spacing 我设置了关键字前后都要有空格, 按我设置的使用规则后, 就会有以下约束 12345678910111213141516// trueif (foo) &#123; //...&#125; else if (bar) &#123; //...&#125; else &#123; //...&#125;// falseif(foo) &#123; //...&#125;else if(bar) &#123; //...&#125;else&#123; //...&#125; comma-spacing 逗号前面不能有空格, 逗号后面要接空格 1234// trueconst a, b, c = 1, 2, 3// falseconst a,b,c = 1,2,3 key-spacing 冒号前面不能有空格, 后面必须有空格, 键值水平对齐 12345678910// trueconst obj = &#123; name: 'kkk', id: 2014210&#125;// falseconst obj = &#123; name:'kkk', id : 'uuu'&#125; 结合 VSCodeVSCode 内置了 ESLint 的支持 1234567891011121314151617181920// Controls whether eslint is enabled for JavaScript files or not.\"eslint.enable\": true,// A path added to NODE_PATH when resolving the eslint module.\"eslint.nodePath\": null,// Uses the legacy module resolving.\"eslint._legacyModuleResolve\": false,// The eslint options object to provide args normally passed to eslint when executed from a command line.\"eslint.options\": &#123;&#125;,// Traces the communication between VSCode and the eslint linter service.\"eslint.trace.server\": \"off\",// Run the linter on save (onSave) or on type (onType)\"eslint.run\": \"onType\",// Turns auto fix on save on or off.\"eslint.autoFixOnSave\": false, 可以开启 ESLint 检查, 同时在项目目录创建配置文件即可, 之后 ESLint 会自动运行进行检查. 你还可以设置保存时自动修复, 我前面那段配置中注释写明 auto 的表示可以自动修复. 怎么样, 是不是很强大. 不过美中不足的是 VSCode 的 ESLint 貌似还不能检查 HTML 文件中的 JavaScript 代码, 导致我的 vue 文件不能被检查到, 希望后续更新的版本可以解决这个问题吧. 前段时间使用了一阵子 VIM, VIM 快捷键在熟悉了之后用起来确实方便很多, 并且 VIM 插件也非常强大, 占用内存也低. 以前用 WebStorm 写代码动不动 1G 内存以上… 现在用的比较多的就是 VSCode 了, VSCode 还自带了 TypeScript 的支持, 不过目前还没有学习 TypeScript 的打算, 感觉 VSCode 就是微软为前端开发而专门准备的, 不负众望真心好用. 前后端语言统一, 带来了包统一, 比如前后端都可以使用 underscore 等类库, 代码统一, 比如前后端可以共用一段输入检测代码, 工具链统一, 比如前后端都可以使用 ESLint 进行代码风格检查. 真的是非常棒的一种体验.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/tags/JavaScript/"},{"name":"ESlint","slug":"ESlint","permalink":"https://ruiming.github.io/tags/ESlint/"}]},{"title":"拥抱 vue 和 vuex","slug":"拥抱 vue 和 vuex","date":"2016-11-05T15:18:43.000Z","updated":"2016-11-05T15:32:14.000Z","comments":true,"path":"2016/11/05/拥抱 vue 和 vuex/","link":"","permalink":"https://ruiming.github.io/2016/11/05/拥抱 vue 和 vuex/","excerpt":"最近一段时间写了两个玩意, 一个是基于 PEG.js 的 XML Parser, 前面有一条博客说了 PEG.js 这东西, 事后自己也模仿着写出了这个 XML 解析器, 感觉并不难, 写着玩玩而已. 另外, 最近花时间特别多的另一件事就是写了一个 RSS 订阅器. 一开始写这个订阅器, 心想上一个项目代码不忍直视, 感觉自己需要写一些能拿出手的代码, 加上学校课程刚好要求做一些东西, 以及自己最近迷上了使用 RSS 订阅器这个东西(这么多理由=.=), 于是就自己动工开搞. 目前订阅器已经基本完工了, RSS 订阅器的网址是 www.enjoyrss.com, 项目开源在 Github 上面, 对于对 RSS 有兴趣或者想学习 Vue2, Vuex 或 Angular1 的人可能会有一些帮助. 额对了, 还有就是后端用的是 Koa2, 前后端鉴权专门在上一篇博客提了下, 想了解 Koa2 的人也可以看下. 数据流动问题其实每次做一个新的东西的时候, 我都会尽量尝试去使用各种新的技术和用法. 这样才能学到更多的东西. 在这个 RSS 订阅器中, 一开始我只是把自己认为的各种 Angular 最佳实践在项目中都运用了下, 想写出能够体现自己 Angular 水平的代码, 为此前面还写了一篇博客说一些我认为的哪些算是最佳实践. 但其实, 对 Angular 使用已经相当熟悉的我, 并没有在这一次中收获什么新的知识. 要说有, 大概就是前面那博客提到的一些 Angular 最新版本的一些新特性例如 Component 之类的吧, 然而自己并没有花时间去看. 在这个项目中, 另外的一点感受就是 Angular 的跨组件通信难题. 确切的说我觉得这个项目并不适合使用 Angular 来写. 例如 左边有一个订阅源栏, 它的未读数量要相应右侧的点击文章, 标记全部已读等事件. 它的订阅源列表也要对右侧的订阅和取消订阅事件做出相应. 为了缩减频繁的跨组件通信, 我将下方状态栏直接拆分成三条, 由各自的组件提供其状态栏覆盖原默认只有背景色的状态栏. 但跨组件通信仍然存在, 单单左侧面板就存在着五个事件监听. 123456789101112131415$scope.$on('EXPAND', () =&gt; vm.expand = !vm.expand)$scope.$on('FOLD', () =&gt; vm.expand = false)$scope.$on('ADD_FEED', (event, data) =&gt; &#123; if (vm.feeds.default) &#123; vm.feeds.default.push(data) &#125; else &#123; vm.feeds['default'] = [data] &#125;&#125;)$scope.$on('DELETE_FEED', (event, data) =&gt; &#123; vm.feeds = _.mapObject(vm.feeds, feeds =&gt; feeds = _.filter(feeds, feed =&gt; feed.feed_id !== data.feed_id))&#125;)$scope.$on('READ_POST', (event, data) =&gt; &#123; vm.feeds = _.mapObject(vm.feeds, feeds =&gt; _.each(feeds, feed =&gt; feed.feed_id === data ? feed.unread-- : ''))&#125;) 我需要监听折叠事件, 这个动作在其他组件被触发. 需要监听添加订阅源和取消订阅源事件, 并修改订阅源列表. 需要监听已读事件, 并对相应订阅源的未读文章数做减1操作… 在有些应用场景, 存在着需要大量父子组件通信, 兄弟组件通信, 以及没有父子和兄弟关系的组件之间的通信的行为, 这种时候, Angular 虽然也能解决, 但是不得不说 Angular 这种频繁的跨组件通信很容易产生问题, 特别是当一个组件可以被多个组件修改的时候.","text":"最近一段时间写了两个玩意, 一个是基于 PEG.js 的 XML Parser, 前面有一条博客说了 PEG.js 这东西, 事后自己也模仿着写出了这个 XML 解析器, 感觉并不难, 写着玩玩而已. 另外, 最近花时间特别多的另一件事就是写了一个 RSS 订阅器. 一开始写这个订阅器, 心想上一个项目代码不忍直视, 感觉自己需要写一些能拿出手的代码, 加上学校课程刚好要求做一些东西, 以及自己最近迷上了使用 RSS 订阅器这个东西(这么多理由=.=), 于是就自己动工开搞. 目前订阅器已经基本完工了, RSS 订阅器的网址是 www.enjoyrss.com, 项目开源在 Github 上面, 对于对 RSS 有兴趣或者想学习 Vue2, Vuex 或 Angular1 的人可能会有一些帮助. 额对了, 还有就是后端用的是 Koa2, 前后端鉴权专门在上一篇博客提了下, 想了解 Koa2 的人也可以看下. 数据流动问题其实每次做一个新的东西的时候, 我都会尽量尝试去使用各种新的技术和用法. 这样才能学到更多的东西. 在这个 RSS 订阅器中, 一开始我只是把自己认为的各种 Angular 最佳实践在项目中都运用了下, 想写出能够体现自己 Angular 水平的代码, 为此前面还写了一篇博客说一些我认为的哪些算是最佳实践. 但其实, 对 Angular 使用已经相当熟悉的我, 并没有在这一次中收获什么新的知识. 要说有, 大概就是前面那博客提到的一些 Angular 最新版本的一些新特性例如 Component 之类的吧, 然而自己并没有花时间去看. 在这个项目中, 另外的一点感受就是 Angular 的跨组件通信难题. 确切的说我觉得这个项目并不适合使用 Angular 来写. 例如 左边有一个订阅源栏, 它的未读数量要相应右侧的点击文章, 标记全部已读等事件. 它的订阅源列表也要对右侧的订阅和取消订阅事件做出相应. 为了缩减频繁的跨组件通信, 我将下方状态栏直接拆分成三条, 由各自的组件提供其状态栏覆盖原默认只有背景色的状态栏. 但跨组件通信仍然存在, 单单左侧面板就存在着五个事件监听. 123456789101112131415$scope.$on('EXPAND', () =&gt; vm.expand = !vm.expand)$scope.$on('FOLD', () =&gt; vm.expand = false)$scope.$on('ADD_FEED', (event, data) =&gt; &#123; if (vm.feeds.default) &#123; vm.feeds.default.push(data) &#125; else &#123; vm.feeds['default'] = [data] &#125;&#125;)$scope.$on('DELETE_FEED', (event, data) =&gt; &#123; vm.feeds = _.mapObject(vm.feeds, feeds =&gt; feeds = _.filter(feeds, feed =&gt; feed.feed_id !== data.feed_id))&#125;)$scope.$on('READ_POST', (event, data) =&gt; &#123; vm.feeds = _.mapObject(vm.feeds, feeds =&gt; _.each(feeds, feed =&gt; feed.feed_id === data ? feed.unread-- : ''))&#125;) 我需要监听折叠事件, 这个动作在其他组件被触发. 需要监听添加订阅源和取消订阅源事件, 并修改订阅源列表. 需要监听已读事件, 并对相应订阅源的未读文章数做减1操作… 在有些应用场景, 存在着需要大量父子组件通信, 兄弟组件通信, 以及没有父子和兄弟关系的组件之间的通信的行为, 这种时候, Angular 虽然也能解决, 但是不得不说 Angular 这种频繁的跨组件通信很容易产生问题, 特别是当一个组件可以被多个组件修改的时候. Angular 是双向数据绑定, 现在也有一种叫单向数据流的思想很火. 当多个视图依赖同一份状态, 一个状态可能受到多个视图的动作改变的时候, 数据流动就会开始变得混乱起来, 而在这个单向数据流里面, state 是我们的数据, view 是我们的视图, actions 是触发数据更改的可能方式. 试想, 如果我们把整个应用的数据都提取出来存放在一棵树里面, 组件的数据从该树获得, 而这个组件想要修改数据时, 就得通过另外一个东西即 actions 来触发 state 的更改, 而 state 的更改又自动同步的影响组件的数据. 这样的话, 上面我们说的那些问题会变得非常容易解决起来, 如果你还理解不了的话, 可以看下我后面怎么说的. Angular 的应用场景既然有 Angular 做不太来的事, 那么 Angular 到底适合用来做什么, 不适合做什么呢? 关于这点, 由于我没有接触真正的项目开发, 我只能谈谈自己的一些个人看法 Angular 的适用场景首先, 结论是 Angular 最适合用来做 CRUD 类型的针对桌面浏览器端的单页面应用(SPA) CRUDCRUD 即 Create, Read, Update, Delete. CRUD 类型, 即应用涉及的数据查询更改较为频繁的应用. 得益于双向绑定机制, 我们不需要做任何处理就可以实现 View 和 ViewModel 的同步, 我们只要在 View 层使用 ngModel 绑定变量, 就可以在控制器里直接使用它而无需担心它的值是否是我们需要的最新的值. 在 CRUD 应用中我们使用 Angular 这一类 MVVM 框架开发就会非常舒畅. 如果你不能感受到, 那么你可以试试用 React 去写一个表单的管理, 你需要监听每个 input 上面的 onChange 事件, 然后通过 setState 来修改, 并最终在该组件中更新修改. 相比起来, ngModel 简单得不能再简单了. 另外, 我们可以直接在 HTML 中使用诸如 ng-show, ng-repeat 等一类指令, 简单粗暴. 数据的变化和显示都变得非常简单. 桌面浏览器端之所以要特别提着一点, 是因为 Angular 体积不小. 这个 RSS 订阅器我桌面浏览器端用 Angular1 开发, 移动端用 Vue2 开发, 都做了打包压缩操作, 开启了 Gzip, 最后情况是 Angular 需要加载的 JS 以及各种辅助类库加起来在 250KB 左右. 而 Vue 只要 100KB 左右(图中的 build.js 文件合并了CSS文件), 不到 Angular 一半的大小. 当然, Angular 体积大是有原因的, 它本身就是一套大而全的框架, 拿体积和 Vue 说事是不太合适的. Vue 非常轻, 专注于 View 这一层, 而 Angular 自带了路由, 内置了 HTTP 的处理模块, 内置了 promise, 还集成了一个简化版的 jq… 如果你刚好 Angular 这些东西你都要用到, 那么 Angular 也是一个不错的选择了, 但如果你只是用到它的一部分或一点点功能并且你追求文件大小, 那么你可能要考虑一下. SPA这点没什么好说的, Angular 就是为这个而生的. Angular1 目前在全球中还是有很多的市场, 并且由于 Angular1 已经相当成熟稳定, 社区支持活跃, 而且是 Google 在维护, 估计未来几年仍然会由较大规模的应用, 目前国内有饿了么移动端, 微信网页版以及七牛, Coding 等在使用, 感觉说了一通废话, 还是看看 Google 怎么说的吧. Google 在 AngularJS 下批注的是 “HTML enhanced for web apps!” 下方有说明 Why AngularJS? HTML is great for declaring static documents, but it falters when we try to use it for declaring dynamic views in web-applications. AngularJS lets you extend HTML vocabulary for your application. The resulting environment is extraordinarily expressive, readable, and quick to develop. 其实感觉还不如我说的明白 =.= Angular 的不适用场景个人认为, Angular 在下面几点场景中不合适 移动端 其实 Angular 开发起移动端的 Webapp 很合适, 就是 Angular 的体积不太合适… 过去的可能要考虑迁移的成本以及必要性, 新的可能需要考虑下更合适的选项比如 Vue. 感觉在未来的移动端 Webapp 上面, Angular 的市场会逐渐降低 跨组件通信频繁 当你写的 Angular 应用中涉及较多的跨组件通信的时候, 你就应该考虑这个用 Angular 是不是真的合适了. 当然其实这个事情应该在最开始的时候就该考虑清楚了. 跨组件通信的问题在 Flux 中并不存在, Flux 能够轻松应对这种问题 谈谈 Vue.js订阅器移动端我用 Vue.js 来做. 接触了 Angular, 学起 Vue 也特别轻松, 三两下就搞定了 Vue 和 Vue-resource. Vue 和 Angular 的相似度比我想象的还要高, 像 vue-resource 这个和 ngresource 用起来没啥区别. 123456789101112131415161718192021222324252627282930// ng-resource(function () &#123; angular .module('app') .factory('User', $resource =&gt; &#123; return $resource('/api/user', &#123;&#125;, &#123; update: &#123; method: 'PUT' &#125;, logout: &#123; method: 'POST', url: '/auth/logout' &#125; &#125;) &#125;)&#125;())// vue-resourceconst User = Vue.resource('/api/user', &#123;&#125;, &#123; update: &#123; method: 'PUT' &#125;, logout: &#123; method: 'POST', url: '/auth/logout' &#125;&#125;)export User (⊙o⊙)… 我直接复制粘贴过去都 OK 了… 另外, 像 v-show 和 ng-show ,v-for 和 ng-for 之类的就更不用多说了. 但是, 不得不说一点, Vue 做的更好. 例如, Vue 可以把 v-for 提出来 123456&lt;ul&gt; &lt;template v-for=\"item in items\"&gt; &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;li class=\"divider\"&gt;&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt; 例如, Vue 可以使用 v-else 123456&lt;div v-if=\"Math.random() &gt; 0.5\"&gt; Sorry&lt;/div&gt;&lt;div v-else&gt; Not sorry&lt;/div&gt; 虽然 Angular 也可以做这些事, 但是我说了, Vue 做的更好. 当然了, Vue 不完全是在 Angular 上面重造轮子, Vue2 引入了虚拟 DOM, 又轻又快, 虽然 Vue 可以像 Angular 一样写 MVVM 应用. 但我个人更喜欢 Vuex 即 Flux 的写法, 这个后面我会说. 在使用 Vue 的过程中, 有几点感受特别深. 例如, 在 Vue 中, 当我在 /post/123 中跳到 /post/456 时, 我发现虽然路径变化了, 但是页面根本没重新渲染. 这对于从 Angular 过来或者说第一次接触 Vue 的人来说应该感觉一脸懵逼. 当然, 很快就查找到了答案, Vue 要求我们手动去更新数据. 至于为什么这么做, 是因为 Vue 可以在我们获取新数据后在原 DOM 上面做最小的修改, 这种修改的成本自然会比整个页面的销毁和重绘要节能和迅速的多. Vue 配合虚拟 DOM 技术可以比对找出最小的修改, 使得 DOM 的修改成本降到最低, 这大概就是 React 和 Vue 在视图上面更新之高效的秘诀了. 不过可能有人会问了, 这样不会很麻烦吗, 要手动监听路由变化然后重新获取数据. 感觉也还好其实, 例如下面这个例子, 这个例子在后面会进行分析. 12345678910111213141516171819202122export default &#123; computed: mapGetters(&#123; post: 'post' &#125;), async beforeRouteEnter (to, from, next) &#123; await store.dispatch('getPost', to.params.id) await store.dispatch('read') next() &#125;, watch: &#123; async '$route' (to, from) &#123; await store.dispatch('getPost', to.params.id) await store.dispatch('read') &#125; &#125;, components: &#123; headbar, postOption &#125;&#125; 可以看到 watch 的部分和 beforeRoute 的部分重复了, Vue 给的说法好像是封装为一个函数来执行, 我感觉还好, 就这样子算了… 上面都是 Vuex 的写法, 其实最开始我还是按 MVVM 那一套写法写的, 写完了之后才开始改到 Vuex 上面去. 另外, Vue 的动画和过渡效果虽然和 Angular 也是很像, 但比 Angular 强大很多. 再者 Vue 支持服务端渲染, 服务端渲染好不好用我不知道, 但确实解决了一些问题. 另外, 还有很多很不错的一些技巧啊, 比如 slot 这个超实用感觉. 不过我只是简单的用了下而已. 例如我定义了这样一个组件 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div id=\"head\" v-bind:class=\"&#123;expand2: expand&#125;\"&gt; &lt;header&gt; &lt;span class=\"icon-paragraph-left\" v-on:click=\"move()\" &gt;&lt;/span&gt; &lt;h2&gt;&lt;slot&gt;主页&lt;/slot&gt;&lt;/h2&gt; &lt;/header&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters, mapActions &#125; from 'vuex'export default &#123; computed: mapGetters(&#123; expand: 'expand', user: 'user' &#125;), methods: &#123; move: function() &#123; if(this.expand) &#123; this.$store.commit('COLLAPSE') &#125; else &#123; this.$store.commit('EXPAND') &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=\"sass\"&gt;&lt;/style&gt; 这里省去 CSS 样式, 反正放出来也没用, 做好这样一个组件之后, 下面这样用的结果 1234567&lt;!-- src --&gt;&lt;headbar&gt;文章&lt;/headbar&gt;&lt;!-- dist --&gt;&lt;header&gt; &lt;span class=\"icon-paragraph-left\"&gt;&lt;/span&gt; &lt;h2&gt;文章&lt;/h2&gt;&lt;/header&gt; 如果 headbar 里面不加任何东西, 那就会使用默认的值主页. slot 可以使用多个, 可以编号. 具体的用法可以查看官方文档, 貌似 Angular 也有类似的东西, 没了解过… 上面的例子中你可能注意到了, 我把 CSS, HTML, JavaScript 都写到了一起去了, 这就是 Vue 的 vue 单文件写法. 比起 Angular 里面我要建立一个文件夹, 文件夹里面放模板, 控制器, 样式表的做法, 我更喜欢 Vue 的做法, 特别好用, 当然了 vue 文件的编译依赖于 webpack. 我们还可以在 vue 文件中使用 pug 来书写 html, 使用 ts 来书写 vue, 使用 sass 来书写 css, 好用到爆. 估计再也回不去 Angular 了… 谈谈 Vuex我要单独把 Vuex 拿出来说一说, 因为它真的太好用了. 首先, 什么是 Vuex? Vuex 是一个专门为 Vue.js 应用设计的 状态管理模型 + 库。它为应用内的所有组件提供集中式存储服务，其中的规则确保状态只能按预期方式变更。它可以与 Vue 官方开发工具扩展(devtools extension) 集成，提供高级特征，比如 零配置时空旅行般（基于时间轴）调试，以及状态快照 导出/导入。 可以看看官方文档的说明 Vuex 和 Flux 类似, 大概可以用下面这个图来表示 一次完整的 vuex 数据流动大概如下: vue 组件通过 dispatch 一个 actions 或者直接 commit 一次 mutations 来间接修改 state. 通常我们在进入一个页面的时候, 需要获取一些请求资源, 我们可以通过 beforeRouteEnter 钩子在路由进入前获取数据, 例如(省去了部分代码): 123456// post.vueasync beforeRouteEnter (to, from, next) &#123; await store.dispatch('getPost', to.params.id) await store.dispatch('read') next()&#125; 在路由进入前, 触发了一个 getPost 事件. actions 处理数据逻辑 专门定义一个文件负责处理 actions, 在 Vue 中, actions 是用来处理异步的, 例如这个 getPost 事件: 12345678// actions.jsexport const getPost = (&#123; commit &#125;, id) =&gt; &#123; return Post.get(&#123; id &#125;).then(res =&gt; &#123; commit(types.RECEIVE_POST, res.data.data) &#125;)&#125; 获取到数据后, commit 一次修改, 这里使用了常量名, 其实对应的就是 RECEIVE_POST 这个字符串, 我们新建一个类型文件专门处理 mutations 的常量名和字符串的映射. 这主要是为了书写方便和重构方便吧我猜, 其实在 Redux 我们也是类似的处理. 12// mutation-types.jsexport const RECEIVE_POST = 'RECEIVE_POST' module 接收 mutation 并处理 module 是为了更合理的划分 store, 这点和 redux 一样. 其用法和 redux 也是很相像的 123456789101112131415161718// post.jsimport * as types from '../mutation-types'const state = &#123; post: &#123;&#125;&#125;const mutations = &#123; // 获取文章信息 [types.RECEIVE_POST](state, post) &#123; state.post = post &#125;&#125;export default &#123; state, mutations&#125; 自此, 我们就完成了一次更新 state 操作. 通过 getters 获取数据 那数据更新是更新了, 怎么用呢, 这时候就要依靠 getters 了. 12// getters.jsexport const post = state =&gt; state.post.post 就一句话就可以了, 但这只是简单的获取数据而已, 你也可以在里面对数据进行一些处理, 比如过滤, 排序之类的, 但要注意, 不能修改原 state 上面的数据. 这点和 redux 又是一致的. 最后完整的一个组件的 JS 部分就是这样: 123456789101112131415161718192021222324252627import &#123; Post &#125; from '../resource/resource.js'import headbar from '../components/headbar.vue'import postOption from '../components/post-option.vue'import store from '../store'import &#123; mapGetters, mapActions &#125; from 'vuex'export default &#123; computed: mapGetters(&#123; post: 'post' &#125;), async beforeRouteEnter (to, from, next) &#123; await store.dispatch('getPost', to.params.id) await store.dispatch('read') next() &#125;, watch: &#123; async '$route' (to, from) &#123; await store.dispatch('getPost', to.params.id) await store.dispatch('read') &#125; &#125;, components: &#123; headbar, postOption &#125;&#125; 通过 mapGetters 和 mapActions 我们可以很方便的绑定 acitons 和 getters. 上面还有个地方没说的就是 read 这个事件, 它还有一个和 getPost 事件很大区别的地方, 在于它会触发多个 state 的修改. 结合 vuex, 我已经轻松的实现了最近未读文章, 订阅源列表, 收藏文章, 广场热门订阅源的缓存自动更新从而实现了这四个页面只要一次请求. 可以访问网站体验下. 就未读而言, 首屏这里就由未读信息的显示了, 当我们进入一篇文章时, 触发了 read 这个 actions, 这个 action 只是做一个异步的 http 请求操作, 然后触发一个 mutation. 关键的地方是我们需要在 posts.js 这个文件中也监听这个 mutation , 然后对其 state 进行操作. 注意这里说的是 posts.js 而不是 post.js. 再换个例子, 取消订阅, 当用户在一个订阅源处点击取消订阅时, 由 action 发出的 mutation, 我们需要最近未读那里移除这个订阅源, 需要订阅源列表也移除这个订阅源, 需要广场那里热门订阅源的这个订阅源的订阅人数减一. 并且要注意的是, 这些对象是分开的. 在 vuex 中, 我们只要注意 payload 即 muitations 的传递数据以及在对应需要修改的 module 中监听 mutation 就好了. 这是非常自然的事情. 换做 Angular, 各种 on 和 emit 以及 broadcast 的能忍? 并且 vuex 提供了状态管理, 但是 angular 没有, 我们要自己缓存数据, 然后要去修改缓存, 这些在 angular 里面写起来特别不优雅. 本来还想对比以下 vuex 和 redux, 但由于篇幅有限, 加之我经验还不足, 且 redux 已经忘得差不多且没有重拾欲望, 想要了解下 redux 可以看看我这篇博客. vuex 也是 flux 的实现, 而且也是和 redux 一样采用单一的一棵状态管理, 因此两者自然由很多相似之处. 最后昨晚班游轰趴, 才睡了三个多钟, 中午补了四个小时觉, 写了这么多我感觉已经快撑不下去了, 其实我个人一直都认为要多做少说, 我不喜欢和人争论技术, 因为我觉得自己很菜很容易说错话, 虽然意识到错误了我可以去学习这是一种提升, 但那也只是在对方意识到你错的时候, 不然就很容易误导别人了, 博客也一样, 我写博客更多就是为了记录一下, 可能也存在很多错误的地方. 用了 Vue 之后, 感觉再也不会去用 Angular 了, 至于 Angular2, 额, 还是再看吧 =.=","categories":[{"name":"Vue","slug":"Vue","permalink":"https://ruiming.github.io/categories/Vue/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/tags/JavaScript/"},{"name":"Koa","slug":"Koa","permalink":"https://ruiming.github.io/tags/Koa/"},{"name":"Vue","slug":"Vue","permalink":"https://ruiming.github.io/tags/Vue/"},{"name":"Vuex","slug":"Vuex","permalink":"https://ruiming.github.io/tags/Vuex/"}]},{"title":"关于前后端分离鉴权的思考","slug":"关于前后端分离鉴权的思考","date":"2016-10-14T11:29:05.000Z","updated":"2016-11-16T16:04:47.000Z","comments":true,"path":"2016/10/14/关于前后端分离鉴权的思考/","link":"","permalink":"https://ruiming.github.io/2016/10/14/关于前后端分离鉴权的思考/","excerpt":"前后端分离项目的 Token 存储问题由来已久，有的人存 Cookie 有的人存 LocalStorage 或 SessionStorage，最近刚把 RSS 订阅器项目的鉴权问题做好，感觉算是目前比较稳妥安全的方案了，分享一下经验。 前端用的是 Angular，后端用的是 Koa，登录注册界面由 Koa 负责，由 Koa 根据用户是否登录来决定首页跳转。我不会一开始就讲我的做法，而是循序渐进的从传统的存储方式逐渐过渡到我的做法当中来。 如何安全的传输用户 token这是最传统也是最简单的方式了，前端登录，后端根据用户信息生成一个 token，并保存这个 token 和对应的用户 id，接着把 token 传给用户，存入浏览器 cookie，之后浏览器请求带上这个 cookie，后端根据这个 cookie 来标识用户。 但这样做问题就很多，如果我们的页面出现了 XSS 漏洞，由于 cookie 可以被 JavaScript 读取，XSS 漏洞会导致用户 token 泄露，而作为后端识别用户的标识，cookie 的泄露意味着用户信息不再安全。 尽管我们通过转义输出内容，使用 CDN 等可以尽量避免 XSS 注入，但谁也不能保证在大型的项目中不会出现这个问题。另外，后端每次都需要根据 token 查出用户 id，这就增加了数据库的查询和存储开销。 在设置 cookie 的时候，其实你还可以设置 httpOnly 以及 secure 项。设置 httpOnly 后 cookie 将不能被 JS 读取，浏览器会自动的把它加在请求的 header 当中，设置 secure 的话，cookie 就只允许通过 HTTPS 传输。 secure 选项可以过滤掉一些使用 HTTP 协议的 XSS 注入，但并不能完全阻止。 httpOnly 选项使得 JS 不能读取到 cookie，那么 XSS 注入的问题也基本不用担心了。但设置 httpOnly 就带来了另一个问题，就是很容易的被 XSRF，即跨站请求伪造。当你浏览器开着这个页面的时候，另一个页面可以很容易的跨站请求这个页面的内容。因为 cookie 默认被发了出去。 看起来我们不能兼顾。确实，光依靠这一个 token 我们没办法兼顾这两点。既然一个不够，那就两个。于是有了 XSRF-TOKEN，它和作为用户令牌的 token 类似，也是服务器生成的一个散列值。我们把 token 通过 httpOnly 发回去，把 XSRF-TOKEN 直接发回去。我们可以无视 httpOnly 的 cookie 因为我们没法操纵它，但对于这个 XSRF-TOKEN，我们就可以在我们网站的每个请求中都加入到 header 里面去。而服务端就需要检查这个 header 的 XSRF-TOKEN 是否真实有效。","text":"前后端分离项目的 Token 存储问题由来已久，有的人存 Cookie 有的人存 LocalStorage 或 SessionStorage，最近刚把 RSS 订阅器项目的鉴权问题做好，感觉算是目前比较稳妥安全的方案了，分享一下经验。 前端用的是 Angular，后端用的是 Koa，登录注册界面由 Koa 负责，由 Koa 根据用户是否登录来决定首页跳转。我不会一开始就讲我的做法，而是循序渐进的从传统的存储方式逐渐过渡到我的做法当中来。 如何安全的传输用户 token这是最传统也是最简单的方式了，前端登录，后端根据用户信息生成一个 token，并保存这个 token 和对应的用户 id，接着把 token 传给用户，存入浏览器 cookie，之后浏览器请求带上这个 cookie，后端根据这个 cookie 来标识用户。 但这样做问题就很多，如果我们的页面出现了 XSS 漏洞，由于 cookie 可以被 JavaScript 读取，XSS 漏洞会导致用户 token 泄露，而作为后端识别用户的标识，cookie 的泄露意味着用户信息不再安全。 尽管我们通过转义输出内容，使用 CDN 等可以尽量避免 XSS 注入，但谁也不能保证在大型的项目中不会出现这个问题。另外，后端每次都需要根据 token 查出用户 id，这就增加了数据库的查询和存储开销。 在设置 cookie 的时候，其实你还可以设置 httpOnly 以及 secure 项。设置 httpOnly 后 cookie 将不能被 JS 读取，浏览器会自动的把它加在请求的 header 当中，设置 secure 的话，cookie 就只允许通过 HTTPS 传输。 secure 选项可以过滤掉一些使用 HTTP 协议的 XSS 注入，但并不能完全阻止。 httpOnly 选项使得 JS 不能读取到 cookie，那么 XSS 注入的问题也基本不用担心了。但设置 httpOnly 就带来了另一个问题，就是很容易的被 XSRF，即跨站请求伪造。当你浏览器开着这个页面的时候，另一个页面可以很容易的跨站请求这个页面的内容。因为 cookie 默认被发了出去。 看起来我们不能兼顾。确实，光依靠这一个 token 我们没办法兼顾这两点。既然一个不够，那就两个。于是有了 XSRF-TOKEN，它和作为用户令牌的 token 类似，也是服务器生成的一个散列值。我们把 token 通过 httpOnly 发回去，把 XSRF-TOKEN 直接发回去。我们可以无视 httpOnly 的 cookie 因为我们没法操纵它，但对于这个 XSRF-TOKEN，我们就可以在我们网站的每个请求中都加入到 header 里面去。而服务端就需要检查这个 header 的 XSRF-TOKEN 是否真实有效。 由于 XSRF-TOKEN 以非 httpOnly 的形式存储在 cookie 中，正常情况下只有我们自己的网站可以获取到该 XSRF-TOKEN。这样 XSRF 攻击就变得不太可能了。另外由于用户 token 是通过 httpOnly 形式存储，JS 不可获取，这样也保证了用户 token 的安全。XSS 注入最多只能获取到 XSRF-TOKEN。 但还是有一种可能，XSS 注入取得 XSRF-TOKEN 后在当前页面发送请求出去。本文并不打算讨论 XSRF 和 XSS，明白这两个真正危害的地方就可以知道，这种 XSS 注入取得 XSRF-TOKEN 后发送请求其实并没有带来什么危害。不过呢，还是要看具体情况吧，如果我们的网站有一个投票 XXX 的接口，这个接口的链接被用在 XSS 注入中，那么当所有人打开这个页面的时候，都会自动的朝 XXX 投了一票。 不同于 XSRF， XSRF 可以从其他网站执行该段脚本，而这里只能注入到我们的网站中来执行。因为我们的 JS 也是这样子做的，取出 XSRF-TOKEN 放入请求头部然后发送请求出去，所以这就无法避免了。事实上，由于我们的前端代码都是公开的，无论 JS 层面绕多少个弯，XSS 注入还是可以照着做过来。但好在这种方式其实造成的影响相当有限，并不会比我们常说的 XSS 注入和 XSRF 攻击的危害大，要知道 XSS 注入危害的 cookie 的泄露，但其实这里并没有 cookie 的泄露。 我们再讨论另一个问题，前面也说了，服务器要经常去查询这个 token 对应的是哪一个用户。其实可不可以不要服务器去查询呢？如果我们生成 token 遵循一定的规律，比如我们使用对称加密算法来加密用户 id 形成 token，那么服务端以后其实只要解密该 token 就可以知道用户的 id 是什么了。不过呢，我只是举个例子而已，要是真这么做，只要你的对称加密算法泄露了，所有用户信息都不再安全了。恩，那用非对称加密算法来做呢，由公钥加密生成 token，私钥来解密 token，这样做就安全多了。其实现在有个规范就是这样做的，就是我们接下来要介绍的 JWT。 Json Web Token接下来我们就简单介绍 JWT 这个东西，全称叫 Json Web Token。 JWT 简介JWT 是一个开放标准(RFC 7519)，它定义了一种用于简洁，自包含的用于通信双方之间以 JSON 对象的形式安全传递信息的方法。JWT 可以使用 HMAC 算法或者是 RSA 的公钥密钥对进行签名。它具备两个特点： 简洁(Compact) 可以通过URL, POST 参数或者在 HTTP header 发送，因为数据量小，传输速度快 自包含(Self-contained) 负载中包含了所有用户所需要的信息，避免了多次查询数据库 JWT 组成JWT 由 Header, Payload, Signature 三部分组成，即头部，负载，签名，长这样： Header 头部 头部包含了两部分，token 类型和采用的加密算法 1234&#123; \"alg\": \"HS256\", \"typ\": \"JWT\"&#125; 它会使用 Base64Url 编码组成 JWT 结构的第一部分 Payload 这部分就是我们存放信息的地方了，你可以把用户 ID 等信息放在这里，JWT 规范里面对这部分有进行了比较详细的介绍，常用的由 iss（签发者），exp（过期时间），sub（面向的用户），aud（接收方），iat（签发时间）。这些我们应该规范的使用，因为他们可能是在校验中使用到了（猜测，表示我一个也没用到 =.= ） 例如： 12345&#123; \"sub\": \"1234567890\", \"name\": \"John Doe\", \"admin\": true&#125; 同样的，它会使用 Base64Url 编码组成 JWT 结构的第二部分 Signature 前面两部分都是使用 Base64Url 进行编码的，即客户端可以解开知道里面的信息。Signature 需要使用编码后的 header 和 payload 以及我们提供的一个密钥，然后使用 header 中指定的签名算法进行签名。签名的作用是保证 JWT 没有被篡改过。 三个部分通过 . 连接在一起就是我们的 JWT 了，它可能长这个样子： 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjU3ZmVmMTY0ZTU0YWY2NGZmYzUzZGJkNSIsInhzcmYiOiI0ZWE1YzUwOGE2NTY2ZTc2MjQwNTQzZjhmZWIwNmZkNDU3Nzc3YmUzOTU0OWM0MDE2NDM2YWZkYTY1ZDIzMzBlIiwiaWF0IjoxNDc2NDI3OTMzfQ.PA3QjeyZSUh7H0GfE0vJaKW4LjKJuC3dVLQiY4hii8s 长度貌似和你的加密算法和私钥有关系。其实到这一步可能就有人会想了，HTTP 请求总会带上 token，这样这个 token 传来传去占用不必要的带宽啊。如果你这么想了，那你可以去了解下 HTTP2，HTTP2 对头部进行了压缩，相信也解决了这个问题。 JWT 使用JWT 生成了，怎么使用就看你了，不过还是有一点要求的。当访问需要 JWT 验证的 API 时，需要把该 JWT 放入头部的 Authorization 中 1Authorization: Bearer &lt;token&gt; 注意 Bearer 是必须的，中间有一个空格，后面跟着 JWT，这样服务端就可以从 Authorization 取出来用了。当然了，你也可以完全爱怎么来就怎么来。但是按照规范你可以省很多事情。 简单的 JWT 流程是这样的，不带 XSRF 的，没有找到带 XSRF 的图 =.= JWT 实践刚才前面也说了，前端用的是 Angular，后端用的是 Koa，登录注册界面由 Koa 负责，由 Koa 根据用户是否登录来决定首页跳转。首先要强调下，下面说的不是唯一的方式，也不是最好的方式，而只是我自己这么用了并且我认为挺稳妥的。我在 Koa 中使用了两个模块，jsonwebtoken 和 koa-jwt。我以登录为例简单说下整个流程。 登录，生成 JWT在说登录的处理之前，我想先强调这个登录页面还是后端(ejs)来渲染的，而不是前端来渲染。这个其实也会影响到我们存储 token 的考虑。 1234567891011121314router.get(['/', '/login'], async (ctx, next) =&gt; &#123; if(ctx.cookies.get('jwt')) &#123; let token = jwt.decode(ctx.cookies.get('jwt')); if(token.id) &#123; let result = await UserModel.findById(token.id); if(result &amp;&amp; result._id) await send(ctx, './public/index.html'); &#125; else &#123; ctx.cookies.set('jwt', null, &#123;overwrite: true, expires: new Date()&#125;); ctx.render('login.ejs', &#123;err: 'JWT 验证失败'&#125;); &#125; &#125; else &#123; await ctx.render('login.ejs'); &#125;&#125;); 当用户访问网站主页或者登录页面的时候，首先要先判断下是否已经有效登录了，如果是，那么跳转到 Angular 中去，否则跳转到登录页面。因为我想法是做一个主页，这个主页不需要加载太多类库，只是简单的展示页面和登录注册页面，用户登录或注册成功后在跳转到 Angular 的入口文件去。 接下来就是真正的登录接口了 12345678910111213141516exports.login = async (ctx, next) =&gt; &#123; let result = await UserModel.findOne(&#123; email: ctx.request.body.email, password: SHA256(ctx.request.body.password).toString()&#125;); let xsrf = SHA256(_.random(999999999)).toString(); if(result &amp;&amp; result._id) &#123; let token = jwt.sign(&#123;id: result._id, xsrf: xsrf&#125;, config.app.secretKey); ctx.cookies.set(\"XSRF-TOKEN\", xsrf, &#123;httpOnly: false, overwrite: true, expires: new Date(new Date().getTime() + 5184000000)&#125;); ctx.cookies.set(\"jwt\", token, &#123;httpOnly: true, overwrite: true, expires: new Date(new Date().getTime() + 5184000000)&#125;); await ctx.redirect('/'); &#125; else &#123; let exist = await UserModel.findOne(&#123;email: ctx.request.body.email&#125;); if(exist &amp;&amp; exist._id) ctx.throw(401, '密码错误'); else ctx.throw(401, '邮箱未注册'); &#125;&#125; 恩，熟悉 Node 的应该看懂没啥问题。这里有个变量 xsrf ，作用前面我们已经说了，还有变量 token 就是 JWT 了。然后我们把他设置到 cookie 中，注意 xsrf 不能设置 httpOnly 而 token 需要设置为 httpOnly，不要忘了把 xsrf 也放入 JWT 的 payload 部分中去，这里 payload 存储了用户 id 和当前的 xsrf。 请求带上 XSRF我们需要在以后的每个请求都带上 XSRF-TOKEN，具体操作就是把 cookie 中的 XSRF-TOKEN 取出来，放入请求的 X-XSRF-TOKEN 头部中，然后发送出去就好了。如果你用的是 Angular，其实你什么都不需要做了，因为这一步 Angular 已经帮你做好了，前提是你的 xsrf 必须放到 cookie 中的 XSRF-TOKEN 这个里面。如果你用的不是 Angular，那你就自己查下怎么做吧，这一步并不难做到。 设置 header 和校验 XSRF前面说了，我们需要把 JWT 放到请求的 Authorization 头部中，但是由于我们对 JWT 设置了 httpOnly ，所以这个操作几乎就不太可能了。但别忘了我们可以在服务端做这一步，与此同时我们也可以把校验 XSRF 也做了，这里先不需要校验 JWT。 如果熟悉 Koa 的话就清楚 Koa 的中间件思路。我们在较顶层的位置写入： 12345678910111213141516171819202122232425// XSRF 检测，处理客户端未授权问题app.use(async (ctx, next) =&gt; &#123; let token = ctx.cookies.get('jwt'), xsrf = ctx.request.headers['x-xsrf-token']; ctx.request.header.authorization = 'Bearer ' + token; // 当 JWT 存在且访问 API 时，检测 XSRF if(token !== void 0 &amp;&amp; /^\\/api\\//.test(ctx.url)) &#123;; let verify = Promise.promisify(jwt.verify); await verify(token, config.app.secretKey).then(async (data) =&gt; &#123; if(xsrf !== data.xsrf) &#123; ctx.cookies.set(\"XSRF-TOKEN\", null, &#123;overwrite: true, expires: new Date()&#125;); ctx.cookies.set(\"jwt\", null, &#123;overwrite: true, expires: new Date()&#125;); ctx.status = 401; ctx.body = &#123; success: false, message: '用户验证失败'&#125;; &#125; else &#123; await next(); &#125; &#125;, err =&gt; &#123; ctx.cookies.set(\"XSRF-TOKEN\", null, &#123;overwrite: true, expires: new Date()&#125;); ctx.cookies.set(\"jwt\", null, &#123;overwrite: true, expires: new Date()&#125;) ctx.status = 401; ctx.body = &#123; success: false, message: '用户验证失败'&#125;; &#125;); &#125; else &#123; await next(); &#125; 最前面几行就是设置 header，可以看到非常简单。if 语句进来就是检验 XSRF 了，我的逻辑是只有用户请求 API 的时候并且 JWT 存在的时候才做检测。我们后面有对 JWT 的检测所以这里不需要做，如果 JWT 不存在或者方位的不是 API 直接 next 就好了。 这里调用了 jwt.verify 方法取出了 payload 的内容，这个方法是 jsonwebtoken 这个模块提供的。 检验 JWT有一点需要注意的是，有些资源我们允许用户无需登录就进行访问。例如我们前面的登录注册界面，还要像静态资源等等。使用 koa-jwt 可以很方便的做这件事情。 1234567app.use(handel.routes()) .use(handel.allowedMethods());app.use(jwt(&#123; secret: config.app.secretKey, algorithm: 'RS256' &#125;).unless(&#123; path: [/^\\/css|js|img|fonts/] &#125;));app.use(api.routes()) .use(api.allowedMethods()); handel 这个路由是我的登录注册页面和接口这些，而 api 就是 Angular 中需要用到的一系列接口。中间我们加入了一句话。这里的 jwt 是 koa-jwt 模块。 这些顺序不能乱，koa 中间件的加载是按自顶向下的顺序的，所以我们 handel 这里并不要 jwt 检测，而后面则需要。而我们前面说的 xsrf 检测和 header 处理自然是要放在更前的位置了。这里的 path 你可以根据需要修改。具体的用法参考文档就好了。 整个流程就完了，这个就实现了我们前面探讨的成果。既保护了 token 的安全，又防止了 XSRF 攻击。当然了我不敢说绝对安全，根本就没有绝对安全的东西。但目前这样的鉴权系统应该算马马虎虎了。 如果你的登录注册也是放在前端（比如由 Angular 来做），那你也可以像我上面说的这么做，或者可以把 jwt 作为登录请求的 response 返回，不过我不觉得这是一种安全的方式，关于其他的存储方式参考我后面给的链接吧，我就不多介绍了。 总结其实关于 JWT 存放到哪里一直由很多讨论，有人说存放到本地存储，有人说存 cookie。但我觉得上面我说的这种方式是挺稳妥的，如果你有什么意见和看法欢迎提出。参考资料也附出了比较热门的关于 jwt 存储位置的讨论文章，可以看下。 参考资料： jwt.io Where to Store your JWTs – Cookies vs HTML5 Web Storage Where to store JWT in browser? How to protect against CSRF?","categories":[{"name":"安全","slug":"安全","permalink":"https://ruiming.github.io/categories/安全/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"https://ruiming.github.io/tags/Angular/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/tags/JavaScript/"},{"name":"Koa","slug":"Koa","permalink":"https://ruiming.github.io/tags/Koa/"},{"name":"JWT","slug":"JWT","permalink":"https://ruiming.github.io/tags/JWT/"}]},{"title":"编译原理与PEG.js","slug":"编译原理与PEG-js","date":"2016-10-07T08:54:32.000Z","updated":"2016-11-16T16:06:12.000Z","comments":true,"path":"2016/10/07/编译原理与PEG-js/","link":"","permalink":"https://ruiming.github.io/2016/10/07/编译原理与PEG-js/","excerpt":"编译原理这学期开始上编译原理这门课，比较纳闷的一点是老师要求用 Java。作为一个想学好编译原理的 Java 黑，自然要寻找另一门可以进行实践的语言，编译在 JavaScript 中应用非常广泛，几乎所有主流的语言都可以编译到 JavaScript，Babel 编译 ES6 到 ES5，以及 CofferScript, TypeScript, JSX 等等编译为 JavaScript。另外，JavaScript 作为一门函数第一公民的语言，我想用来做编译也是特别方便的。一开始看了 Jison，感觉还是挺简单的，不过现在貌似流行 PEG.js，老实说我并不知道他们区别，我还只是一个初学者，或者初学者也算不上，因为最近一个月根本没好好听课 =.= 解析表达式在了解 PEG.js 之前有必要先了解下 PEG（解析表达文法），以及它与 CFG（上下文无关文法）的区别。以下摘选维基百科上面关于解析表达式的解释","text":"编译原理这学期开始上编译原理这门课，比较纳闷的一点是老师要求用 Java。作为一个想学好编译原理的 Java 黑，自然要寻找另一门可以进行实践的语言，编译在 JavaScript 中应用非常广泛，几乎所有主流的语言都可以编译到 JavaScript，Babel 编译 ES6 到 ES5，以及 CofferScript, TypeScript, JSX 等等编译为 JavaScript。另外，JavaScript 作为一门函数第一公民的语言，我想用来做编译也是特别方便的。一开始看了 Jison，感觉还是挺简单的，不过现在貌似流行 PEG.js，老实说我并不知道他们区别，我还只是一个初学者，或者初学者也算不上，因为最近一个月根本没好好听课 =.= 解析表达式在了解 PEG.js 之前有必要先了解下 PEG（解析表达文法），以及它与 CFG（上下文无关文法）的区别。以下摘选维基百科上面关于解析表达式的解释 解析表达文法里面的每一个非终结符本质上表示递归下降解析器里面的一个解析函数，其对应的解析表达式展示了这个函数包含的代码内容。概念上，每一个解析函数接受一个输入字符串作为参数，返回以下其中一个结果: 成功，函数可能向前移动或者“消耗”一个或多个输入字符串的字符 失败，不消耗任何字符 一个非终结符有可能成功但是不消耗任何输入字符，这也是一种不同于失败的结果。 只由一个终结符组成的原子解析表达式：成功，如果输入字符串的第一个字符就是定义中的终结符，这种情况下消耗这个输入字符；否之失败。由空字符串组成的原子解析表达式总是成功并且不消耗任何输入。只由一个非终结符A组成的原子解析表达式表示对非终结符A的解析函数的递归调用。 序列操作符 e1e2 首先调用 e1， 如果 e1成功， 接着对 e1 消耗剩下的输入字符串调用 e2， 最后返回结果。如果 e1 或者 e2 失败，那么序列表达式 e1e2 失败。 选择操作符 e1 / e2 首先调用 e1， 如果 e1成功， 立刻返回结果。否则如果 e1 失败，选择操作符回溯到输入字符串匹配 e1 的原始位置，调用 e2， 最后返回 e2 结果。 零个或多个，一个或多个，和可选操作符分别消耗零个或多个，一个或多个，或者零个或一个连续重复的子表达式e。与上下文无关文法和正则表达式不同的 是，尽管如此，在PEG里这些操作符总是执行贪婪的行为，那就是消耗尽可能多的输入，而且绝对不回溯。（正则表达式一开始执行贪婪匹配，但是如果整个正则表达式失败后，会回退并尝试短一些的匹配。）例如，解析表达式a总是尽可能多的消耗输入字符串中连续出现的a，解析表达式(a a)则必然会失败因为前半部分a*绝对不会留下一丁点a给后半部分去匹配。 最后，肯定断言和否定断言实现了句法断言。&amp;e 表达式调用子表达式e，如果e成功，则返回成功；否则返回失败。无论结果如何都不消耗任何字符。反之，当e失败时！e 表达式成功，e成功时！e 表达式失败， 同样无论结果如何都不消耗任何字符。因为向前判断的子表达式e 可以任意的复杂，所以断言表达式提供了强大的句法向前判断和去除二义性的能力。 PEG.jsPEG.js 是一个基于 JavaScript 的简单的解析器生成器，它用来生成一个快速且具备完善错误报告的解析器。你可以用它来处理复杂的数据或计算机语言，已经轻松的构造变换器，解释器，编译器以及其他的工具。 特性 简单和具有表现力的语法符号 集成了词法分析( lexcial )和语义分析( syntactical ) 具备优良的错误报告 基于解析表达式语法的形式，比传统的 LL(k) 和 LR(k) 解析器更强大 可以用于浏览器，命令行，或者通过 JavaScript 的 API 开始在线版本 是生成一个解析器最简单的方式，只要输入你定义的语法，尝试解析少量的输入，下载生成的解析后的代码。 安装Node.js如果要使用 pegj 命令，全局安装 PEG.js 1npm install -g pegjs 如果要使用 JavaScript 的 API，本地安装 PEG.js 1npm install pegjs 如果你两者都需要，那么两种方式都安装即可 浏览器下载 PEG.js 库(普通或者压缩的版本) 或者通过 Bower 安装 1bower install pegjs 生成一个解析器PEG.js 根据一个你希望解析的输入的语法以及你指定的返回结果(对匹配的进行语义分析)生成解析器。最后生成解析器本质上只是一个带有一些简单 API 的 JavaScript 对象。 命令行想要根据你的语法生成一个解析器，使用 pegjs 命令： 1pegjs arithmetics.pegjs 这将会把解析器代码写入一个以 ‘.js’ 为扩展名的相同文件名文件中， 你也可以自己指定输出： 1pegjs -o arithmetics-parser.js arithmetics.pegjs 如果你省略了输入和输出文件，那么将会使用标准的输入输出 默认下，解析器的生成采用了 Node.js 的模块格式，你可以使用 --format 选项来覆盖。 你可以调整一下几个选项： --allowed-start-rules – 逗号相隔的会被用来解析的规则（默认为第一个规则） --cache – 让解析器缓存结果，避免在极端情况下出现了指数级的解析时间而降低解析器速度 --dependency – 给解析器指定依赖（可以多次指定） --export-var – 指定一个全局变量名称，当没有进行模块到处时，解析器对象会以该名称命名 --extra-options – 其他的传递给 peg.generate 的选项（JSON 格式） --extra-options-file – 同上，只不过选项保存在文件里面 --format – 指定解析器的到导出格式，如 amd， commonjs，globals，umd（默认: commonjs） --optimize – 在优化解析速度（speed）和代码大小（size）之间进行选择（默认：speed） --plugin – 让 PEG.js 使用一个指定的插件（可以多次指定） --trace – 让解析器跟踪其运行情况 JavaScript API在 Node.js 中，需要引入 PEG.js 这个模块 1var peg = require('pegjs'); 在浏览器中，通过 &lt;script&gt; 标签引入 PEG.js 库到你的网页中。如果 PEG.js 使用 AMD 模块化方案，它会把模块定义在一个变量上面，否则他的 API 将会挂载在全局对象 peg 中 为了生成一个解析器，调用 peg.generate 方法并把你的语法作为参数传递进去 1var parser = peg.generate(\"start = ('a'/'b')+\"); 这个方法会返回解析器对象或者返回源码（取决于你的 output 参数 – 参见下文）。如果语法非法它将抛出错误，错误会包含 message 属性，它携带更详细的错误信息 你可以传入以下选项组成的对象作为 peg.generate 的第二个参数，以下选项是受支持的： allowedStartRules – 指定解析器从哪个规则开始解析（默认：语法中的第一个规则） cache – 如果为 true，解析器会缓存结果以避免指数级的解析时间影响解析器效率（默认：false） dependencies – 解析需要的依赖，它的值为一个变量与依赖模块映射的对象。解析器通过这些变量来使用那些模块。只有当 format 被设置为 amd，commonjs 或者 umd （默认：{}）时才有效。 exportVar – 一个全局对象名，当没有进行模块导出时，解析器对象会以该名称命名 format – 生成的解析器的导出格式（”amd”，”bare”，”commonjs”，”globals”，”umd”），只有当 output 设置为 source 时（默认：null）才有效 optimize – 在优化解析速度（speed）和代码大小（size）之间进行选择（默认：speed） output – 如果设置为 parser，这个方法将返回解析器对象；如果设置为 source，它会以字符串的形式返回生成的解析器的源码（默认：parser） plugin – 让 PEG.js 使用一个指定的插件（可以多次指定） trace – 让解析器跟踪其运行情况 使用解析器使用生成的解析器的方法十分简单，只要调用它的 parse 方法并把参数作为一个字符串传入即可。该方法会返回解析的结果（确切的值取决于你的生成该解析器的语法）或者抛出错误（如果你的输入非法）。抛出的错误信息带有 location，expected，found 以及包含更多错误信息的 message 12parser.parse(\"abba\"); // returns [\"a\", \"b\", \"b\", \"a\"]parser.parse(\"abcd\"); // throws an exception 你还可以通过传入第二个参数来调整解析行为，该参数是一个支持以下可选项的对象： startRule – 从这个规则开始解析 tracer – 追踪解析行为 解析器也支持你自定义的选项 句法和语义PEG.js 的句法不是面向行的，并且会忽略标记（token）之间的空白，这一点和 JavaScript 相似。你也可以使用 JavaScript 风格的注释（//... 和 /*...*/） 让我们看一个简单的可以识别形如 2*(3+4) 这样的表达式的语法。根据这个语法生成的解析器可以计算该表达式的值 1234567891011121314151617start = additiveadditive = left:multiplicative \"+\" right:additive &#123; return left + right; &#125; / multiplicativemultiplicative = left:primary \"*\" right:multiplicative &#123; return left * right; &#125; / primaryprimary = integer / \"(\" additive:additive \")\" &#123; return additive; &#125;integer \"integer\" = digits:[0-9]+ &#123; return parseInt(digits.join(\"\"), 10); &#125; 在顶层，语法包含了规则（在我们的例子中，有五条规则）。每条规则都由一个名字（例如 integer）来区分它们，并且还有一个解析表达式（例如 digits:[0-9]+ { return parseInt(digits.join(&quot;&quot;), 10); }）来定义一个对输入文本的匹配，你还可以在其中包含你的 JavaScript 代码来处理被成功匹配到的文本。规则可以包含别名以便于错误提示（例如上面的例子中，只有 integer 规则具有别名）。解析将从第一条规则，这条规则也叫作 start rule 一个规则名必须是一个 JavaScript 标识符，它后面跟着一个 = 和解析表达式。如果这个规则名有一个别名，它作为一个 JavaScript 字符串书写在规则名和 = 之间。规则之间需要用空格分割开，但在解析表达式后面跟着 ; 也是可以的。 你可以在第一个规则前初始化一些用 {} 闭合的 JavaScript 代码。这些代码会在解析器开始解析之前先执行。在初始化操作中定义的变量名和函数可以在规则操作和语义谓词中直接使用，同时他们也可以直接访问通过 options 传递进来的对象。初始化过程中括号必须严格闭合。比如我们来看一个简单的例子： 1234567891011121314151617181920212223&#123; function makeInteger(o) &#123; return parseInt(o.join(\"\"), 10); &#125;&#125;start = additiveadditive = left:multiplicative \"+\" right:additive &#123; return left + right; &#125; / multiplicativemultiplicative = left:primary \"*\" right:multiplicative &#123; return left * right; &#125; / primaryprimary = integer / \"(\" additive:additive \")\" &#123; return additive; &#125;integer \"integer\" = digits:[0-9]+ &#123; return makeInteger(digits); &#125; 规则的解析表达式用来匹配输入的文本。这里由好几种类型的表达式 – 匹配字符或字符类，显示可选部分和重复等等。表达式中也可以包含其他规则的引用。详细介绍见下文。 如果一个表达式成功的匹配到了一个输入流的部分文本，它会产生一个匹配结果，这是一个 JavaScript 值。例如： 一个匹配字符串的表达式生成一个包含被匹配串的 JavaScript 字符串 一个匹配包含子表达式的字符串的表达式生成一个含有全部被匹配项的 JavaScript 数组 当在表达式中使用规则名时，它将递归的解析下去并最终返回全部解析完成的结果 一个特殊的情况是解析表达式是一个解析行为 – 一段 JavaScript 代码包含在 {} 里面。它会处理匹配到的文本串并返回处理的结果，这个值是也被认为是表达式匹配的结果（换句话说，解析行为是对被匹配文本的一个变换器） 在我们的算术例子中由几个解析行为。比如这个表达式 digits:[0-9] + { return parseInt(digits.join(&quot;&quot;), 10); }，它处理 [0-9]+ 匹配的结果，这个结果是一个包含匹配的数字字符串组成的数组，它作为参数传入到该后面的行为被拼接成为一个 JavaScript number 对象后返回 解析表达式类型解析表达式有好几种类型，他们当中可能有些还包含子表达式从而形成一个递归结构 “literal“ ‘literal‘ 解析表达式会精确匹配字符串并返回，该字符串的句法和 JavaScript 一样。在字符串后面追加 i 使得匹配区分大小写 . 匹配一个字符并作为一个字符串返回 [characters] 从一个集合中匹配一个字符并作为一个字符串返回。集合中的字符可以以和 JavaScript 字符串相同的方式进行转义处理。集合中的字符也可以包含范围（例如 [a-z] 表示匹配一个小写字母）。在字符前面加上 ^ 表示取反（例如：[^a-z] 表示匹配一个非小写字母）。在右括号后面添加 i 可以让匹配区分大小写 rule 递归的匹配一个解析表达式规则并返回匹配的结果 ( expression ) 匹配一个子表达式并返回匹配的结果 expression * 匹配表达式零次或多次并以数组的形式返回匹配结果。这个匹配是贪婪匹配，即解析器会尽可能的进行多次匹配。不像正则表达式，解析表达式没有回溯 expression + 匹配表达式一次或多次并以数组的形式返回匹配结果。这个匹配是贪婪匹配，即解析器会尽可能的进行多次匹配。不像正则表达式，解析表达式没有回溯 expression ? 尝试匹配表达式，如果匹配成功，返回匹配的结果，否则返回 null。不像正则表达式，解析表达式没有回溯 &amp; expression 尝试匹配表达式，如果匹配成功，只返回 undefined 并且不消耗任何输入，否则认为匹配是失败的 ! expression 尝试匹配表达式，如果匹配不成功，只返回 undefined 并且不消耗任何输入，否则认为匹配是失败的 &amp; { predicate } predicate 是一段 JavaScript 代码，可以理解为是它是在一个函数里面等待执行。它会把前面表达式匹配得到的结果作为它的参数。它通过 return 来返回 JavaScript 值。If the returned value evaluates to true in boolean context，返回 undefined 并且不消耗任何输入，否则认为匹配是失败的 在 predicate 中的代码可以访问初始化时定义的变量和方法 在 predicate 中的代码可以通过调用 location 函数来访问当前位置信息，它会返回一个像下面这样的对象： 1234&#123; start: &#123; offset: 23, line: 5, column: 6 &#125;, end: &#123; offset: 23, line: 5, colume: 6&#125;&#125; start 和 end 都指向当前解析的位置，offset 为一个从 0 开始的偏移值，line 和 column 为从 1 开始的行号和列号 在 pedicate 中的代码可以通过 options 变量来访问解析器被调用时传递进来的选项对象 注意括号必须严格闭合 ! { predicate } predicate 是一段 JavaScript 代码，可以理解为是它是在一个函数里面等待执行。它会把前面表达式匹配得到的结果作为它的参数。它通过 return 来返回 JavaScript 值。If the returned value evaluates to false in boolean context，返回 undefined 并且不消耗任何输入，否则认为匹配是失败的 在 predicate 中的代码可以访问初始化时定义的变量和方法 在 predicate 中的代码可以通过调用 location 函数来访问当前位置信息，它会返回一个像下面这样的对象： 1234&#123; start: &#123; offset: 23, line: 5, column: 6 &#125;, end: &#123; offset: 23, line: 5, colume: 6&#125;&#125; start 和 end 都指向当前解析的位置，offset 为一个从 0 开始的偏移值，line 和 column 为从 1 开始的行号和列号 在 pedicate 中的代码可以通过 options 变量来访问解析器被调用时传递进来的选项对象 注意括号必须严格闭合 $ expression 尝试匹配表达式，如果匹配成功，返回匹配的文本而不是匹配的结果 label: expression 匹配表达式并使用 label 来保存匹配结果，label 必须是一个 JavaScript 符号 符号表达式通常和解析行为一起使用，表达式匹配结果保存在符号中，解析行为通过符号来访问匹配结果 expression_1 expression_2 … expression_n 匹配一连串表达式并把匹配结果作为一个数组返回 expression { action } 匹配表达式，如果匹配成功，则执行表达式，否则认为匹配是失败的 action 是一段 JavaScript 代码，可以理解为是它是在一个函数里面等待执行。它会把前面表达式匹配得到的结果作为它的参数。它通过 return 来返回 JavaScript 值。返回值是匹配的结果。 为了便于查错，action 里面可以调用 expected 函数来让解析器抛出一个错误。这个函数有两个参数，一个描述当前位置预期的结果和可选的当前位置的信息（默认为 location 函数调用返回的结果 – 见下文）。这个描述会作为抛出错误信息的一部分 action 里面也可以调用 error 函数，同样也会让编译器抛出错误。这个函数也由两个参数 – 错误信息和可选的位置信息（默认为 location 函数调用返回的结果 – 见下文）。错误信息将被抛出的错误所使用 action 里面的代码也可以访问语法初始化时的定义的变量和方法。注意必须严格括号闭合 action 里面的代码也可以通过 text 函数来访问前面表达式匹配的字符串 action 里面的代码也可以通过调用 location 函数来访问当前位置信息，它会返回一个像下面这样的对象： 1234&#123; start: &#123; offset: 23, line: 5, column: 6 &#125;, end: &#123; offset: 25, line: 5, colume: 8&#125;&#125; start 执行表达式开始的位置，而 end 指向表达式结束的位置。offset 是从 0 开始的偏移值，line 和 column 是从 1 开始的行数和列数 action 里面的代码可以通过 options 变量来访问解析器被调用时传递进来的选项对象 注意括号必须严格闭合 expression_1 / expression_2 / … / expression_n 尝试匹配第一个表达式，如果没有匹配到，则尝试第二个，以此类推。最后返回第一个匹配成功的表达式匹配的结果。如果没有成功匹配的表达式，则认为匹配失败。 兼容性解析器生成器和生成的解析器都可以在以下环境中运行： Node.js 4+ Internet Explorer 8+ Edge Firefox Chrome Safari Opera Development Project website Wiki Source code Issue tracker Google Group Twitter PEG.js is developed by David Majda (@dmajda). The Bower package is maintained by Michel Krämer (@michelkraemer). You are welcome to contribute code. Unless your contribution is really trivial you should get in touch with me first — this can prevent wasted effort on both sides. You can send code both as a patch or a GitHub pull request. Note that PEG.js is still very much work in progress. There are no compatibility guarantees until version 1.0.","categories":[{"name":"PEG","slug":"PEG","permalink":"https://ruiming.github.io/categories/PEG/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/tags/JavaScript/"},{"name":"Compiler","slug":"Compiler","permalink":"https://ruiming.github.io/tags/Compiler/"},{"name":"PEG.js","slug":"PEG-js","permalink":"https://ruiming.github.io/tags/PEG-js/"}]},{"title":"Angular 最佳实践总结 (一)","slug":"Angular 最佳实践总结 (一)","date":"2016-09-29T06:45:13.000Z","updated":"2016-11-16T16:07:04.000Z","comments":true,"path":"2016/09/29/Angular 最佳实践总结 (一)/","link":"","permalink":"https://ruiming.github.io/2016/09/29/Angular 最佳实践总结 (一)/","excerpt":"搞了快一年的 Angular，Angular 真的是一个非常强大非常齐全非常好用的框架，而且拥有强大的社区支持，虽然踩了很多坑，但是仍然无悔学习了这样一个框架。Angular 2 已经正式发布了，我也打算学 Angular2 去了，现在手头上还有一个用 Angular 的项目，这个项目我是想把我学到的很多 Angular 的最佳实践都用进去，借此我就想干脆也写几篇博客总结下好了，我写的比较散，想到什么就说什么。 使用单次绑定或单向绑定从 Angular 1.3 开始就有了 once-time binding，Angular 1.5 开始支持了指令和组件的 one-way binding。看看他们的用法： 单次绑定很简单，加上:: 就可以了。 1&lt;p&gt;&#123;&#123;::vm.title&#125;&#125;&lt;/p&gt; An expression that starts with :: is considered a one-time expression. One-time expressions will stop recalculating once they are stable, which happens after the first digest if the expression result is a non-undefined value (see value stabilization algorithm below). 当 digest 结束之后并且单次绑定的值不为 undefined 时，这个值将不再被监听。官方称这个算法为 Value stabilization algorithm 还解释了一下。看到这个，再想起 Angular 源码那注释，觉得真的业界良心啊。想具体了解下单次绑定，出门右转 -&gt; docs.angularjs 在视图进行单向绑定也很简单，使用 ng-bind 就可以了，这里主要说的是指令和组件中的单向绑定。 其实 Angular1 还是不断再发展，现在最新的是 1.5.9，加了很多新的东西，也做了很多性能优化。单向绑定也是 1.5 之后才引入的新东西。1.5 也引入了一个新的东西叫 component，和 directive 差不多，具体我没用过我也不太了解，不过写法简洁了很多。单向绑定主要就是用于 component 和 directive 的。 随便找个比较简单的例子来说下，","text":"搞了快一年的 Angular，Angular 真的是一个非常强大非常齐全非常好用的框架，而且拥有强大的社区支持，虽然踩了很多坑，但是仍然无悔学习了这样一个框架。Angular 2 已经正式发布了，我也打算学 Angular2 去了，现在手头上还有一个用 Angular 的项目，这个项目我是想把我学到的很多 Angular 的最佳实践都用进去，借此我就想干脆也写几篇博客总结下好了，我写的比较散，想到什么就说什么。 使用单次绑定或单向绑定从 Angular 1.3 开始就有了 once-time binding，Angular 1.5 开始支持了指令和组件的 one-way binding。看看他们的用法： 单次绑定很简单，加上:: 就可以了。 1&lt;p&gt;&#123;&#123;::vm.title&#125;&#125;&lt;/p&gt; An expression that starts with :: is considered a one-time expression. One-time expressions will stop recalculating once they are stable, which happens after the first digest if the expression result is a non-undefined value (see value stabilization algorithm below). 当 digest 结束之后并且单次绑定的值不为 undefined 时，这个值将不再被监听。官方称这个算法为 Value stabilization algorithm 还解释了一下。看到这个，再想起 Angular 源码那注释，觉得真的业界良心啊。想具体了解下单次绑定，出门右转 -&gt; docs.angularjs 在视图进行单向绑定也很简单，使用 ng-bind 就可以了，这里主要说的是指令和组件中的单向绑定。 其实 Angular1 还是不断再发展，现在最新的是 1.5.9，加了很多新的东西，也做了很多性能优化。单向绑定也是 1.5 之后才引入的新东西。1.5 也引入了一个新的东西叫 component，和 directive 差不多，具体我没用过我也不太了解，不过写法简洁了很多。单向绑定主要就是用于 component 和 directive 的。 随便找个比较简单的例子来说下， 1234567891011121314151617181920212223242526(function()&#123; 'use strict'; var app = angular.module('app'); app.component('menuBar', &#123; // defines a two way binding in and out of the component bindings: &#123; brand:'&lt;' &#125;, // Load the template templateUrl: '/js/components/appComponent.html', controller: function () &#123; // A list of menus this.menu = [&#123; name: \"Home\", component: \"home\" &#125;, &#123; name: \"About\", component: \"about\" &#125;, &#123; name: \"Contact\", component: \"contact\" &#125;]; &#125; &#125;);&#125;)(); 单向绑定就上面的 &lt; ，我们知道一般有 @, =, &amp; 三种方式，分别表示绑定字面量，绑定表达式，绑定事件，而新增的 &lt; 是用来实现单向绑定的。上面这段代码是从别的地方找来的，由于我自己没有使用过，所以暂时不过多介绍，晚点搞清楚了再补充下。 谨慎使用 $interval如果我们要实现实时显示当前时间的效果，可以有下面三种方式: 12345678910111213141516171819vm.time = Date.now();// 方式一setInterval(() =&gt; &#123; vm.time = Date.now(); $scope.$digest();&#125;, 1000);// 方式二setInterval(() =&gt; &#123; $scope.$apply(() =&gt; &#123; vm.time = Date.now(); &#125;)&#125;, 1000);// 方式三$interval(() =&gt; &#123; vm.time = Date.now();&#125;, 1000); 考虑到页面还有其他双向绑定量，你觉得上面三种方式哪种性能消耗会小一点？ 我这边测试了下，三种方式导致当前 digest 所执行的 watcher 表达式数量分别是 方式一 (34) &lt; 方式二 (140) = 方式三 (140)。 我感觉有种被骗的感觉，我记得大家都说不要手动调用 $digest 啊要用 $apply 啊… 但事实是这里的方式一是性能最好的，如果要说原因，那是因为$scope.$digest() 只会触发当前 scope 进行 digest，而其余的就会从 $rootScope 下来整个都进行 digest，对于我们这里只是想要实现时间变化的需求来说就显得有点多于了，这种情况下还是方式一合适些。当然了你也可以用原生 JS 来写，但这样就使用不了 Angular 的日期格式化功能了~ 不少人认为 Angular 脏检查是轮询，如果不加限制使用 $interval，不就和轮询没区别了。所以能少用就少用，这里不用 $interval 是因为它会在每次循环结束自动调用 $rootScope 上面的 digest，因此使用 setInterval，如果你不触发 digest，那么这个数据的变化是不会同步到视图中的，所以我们手动的触发了当前作用于的 digest。 ng-repeat 使用 trackby 优化Angular 会为每个 watch 变量生成一个 hashkey，并使用他来跟踪其值的变化，当我们使用 ng-repeat 时，如果数组的内容发生了变化，Angular 不会重新销毁和渲染整个 DOM，而是找出变化的一部分做出修改，由于 hashkey 是根据节点内容产生的，这意味着我们的数组中不能有完全一样的两个节点存在。并且当数组的子项为对象时，用一个类似的新的数组覆盖它会导致 Angular 销毁并重新渲染整个 DOM。我们试一试便知。 123456789&lt;!-- 不使用 track by --&gt;&lt;p ng-repeat=\"item in items\"&gt; &#123;&#123;item.value&#125;&#125;&lt;/p&gt;&lt;!-- 使用 track by --&gt;&lt;p ng-repeat=\"item in vm.items track by item.key\"&gt; &#123;&#123;item.value&#125;&#125;&lt;/p&gt; 我们在控制器里面这样写看下 123vm.items = [&#123;key: 1, value: 2&#125;, &#123;key: 3, value: 4&#125;, &#123;key: 5, value: 6&#125;];$timeout(() =&gt; vm.items = [&#123;key: 1, value: 2&#125;, &#123;key: 3, value: 4&#125;, &#123;key: 5, value: 6&#125;], 2000);$timeout(() =&gt; vm.items.push(&#123;key: 7, value: 8&#125;), 3000); 可以自己试一试，然后调出开发者工具查看下 DOM 的变化 结果是： 不使用 track by 2 秒后重新渲染全部子节点，3 秒后添加渲染了一个新节点。 使用 track by 2 秒后没变化，3秒后添加渲染了一个新节点。 他们的区别就在数组重新赋值上面，还有就是数组必须是一个由对象组成的数组。在有些情况下，我们可能需要使用一个新的数组覆盖旧的数组，而他们之间可能有部分是相同的，如果我们使用 trackBy，Angular 就可以利用这一部分已经渲染好的 DOM，从而达到了优化的目的。 如果没有特别的唯一标识可以指定，也可以直接使用 track by $index，也可以起到一样的作用。 关闭调试信息据说这个方法很多人都不知道？ 1$compileProvider.debugInfoEnabled(false); 这样就可以关闭 Angular 插在视图里面的任何辅助调试信息例如 ng-if 和 ng-repeat 等注释以及 ng-binding 等 CSS 类。上线的时候关掉会比较好一点。 使用超级强大的 interceptors这个在做全局请求和相应处理时特别强大，通过它我们可以实现统一修改每个请求的 header，对返回的结果进行处理，全局 HTTP 错误响应处理等等。用法也相当简单： 12345678910111213141516$httpProvider.interceptors.push(function($q) &#123; return &#123; 'request': function(config) &#123; &#125;, 'requestError': function(rejection) &#123; &#125;, ‘response': function(response) &#123; &#125;, 'responseError': function(rejection) &#123; &#125; &#125;&#125;); 额，举个粟子： 12345678910111213141516171819(function() &#123; angular .module('app') .factory('tokenInjector', tokenInjector); function tokenInjector($injector, $q, $cookies, $cacheFactory, $timeout) &#123; let jwt = undefined; return &#123; request: function(config) &#123; if(void 0 === jwt) &#123; jwt = $cookies.get('jwt'); &#125; config.headers['Authorization'] = \"Bearer \" + jwt; return $q.when(config); &#125;, &#125; &#125;;&#125;()); 上面新建了一个 tokenInjector，之后我们这样使用就可以了: 1$httpProvider.interceptors.push(tokenInjector); 作用就是实现每次请求都自动把 token 添加到 header 的 Aturhorization 中。除此之外还可以做好多好多东西，这里就不详细介绍下去了。 使用 ui-router 替代 ngRoute自从用了 ui-router 就再也回不去 ngRoute 了，ui-router 使用状态来进行转移，支持多视图和嵌套视图，使用方法更加灵活，并且也有更加丰富的 API。多视图，嵌套视图你知道意味什么吧，这些 ngRoute 做不到，官方现在也是主推 ui-router，前段时间 ui-router 已经出了新的 1.0 版本，相信大部分开发者还是在用老版本吧，可以考虑迁移了，想要了解新版本的迁移事项看这里。 对于还在使用 ngRoute 的童鞋，我也强烈建议你去使用 ui-router。 多视图和嵌套视图就不多说了，除此之外还有比较强大实用的地方就是 ui-router 提供的生命周期钩子即 $stateChangeStart, $stateChangeSuccess, $stateChangeError，ngRoute 不知道有没有，没有去了解过。下面举个粟子说下用法： 123456789101112131415161718$rootScope.$on(\"$stateChangeStart\", function (event, toState, toStateParams, fromState, fromStateParams) &#123; $rootScope.loading = true;&#125;);$rootScope.$on(\"$stateChangeSuccess\", function (event, toState, toStateParams, fromState, fromParams) &#123; if(ga) &#123; let re = /\\&#123;(.*?)&#125;/g, url; if(Object.keys(toStateParams).length &gt; 0) &#123; url = toState.url.replace(re, Object.values(toStateParams).reduce((pre, curr) =&gt; curr)); &#125; else &#123; url = toState.url; &#125; ga('send', 'pageview', url); &#125; $rootScope.loading = false;&#125;);$rootScope.$on(\"$stateChangeError\", function (event, toState, toStateParams, fromState, fromParams, error) &#123; $rootScope.loading = false;&#125;); 其实上面应该时比较 tricky 的做法，作用就是全局视图切换动画以及让 google analysis 工作，从 stateChangeStart 开始，isLoading 变为 true 直到 stateChangeSuccess 的时候变为 false。我们把 isLoading 挂在 $rootScope 上面方便使用，用这个变量就可以判断是否加载一个 Loading 的 DOM。 其次，由于单页应用特性，google analysis 只被加载一次从而无法实时反馈用户当前所访问的页面，我们可以手动进行调用，上面就是用法了，也是每次在成功状态变化之后发送当前 url。 不过遗憾的是这个 API 在 ui-router 1.0 版本废弃了，不过 ui-router 1.0 目录下带了另一个文件，引入这个文件即可以继续使用。我猜测 ui-router 1.0 应该是有更好的解决方案来替代它，详细的可以自己去了解下。 另外还想说的一个地方就是 ui-router 的 resolve 功能，允许我们在控制器初始化之前先获取和处理数据，如果 resolve 的东西是一个 promise，如果 promise 状态为 rejected，那么视图就不会被成功切换。基于此我们可以把视图需要的一些 HTTP 请求放到 ui-router 的 resolve 上面来做，然后再注入到控制器给控制器使用，并且这样还可以避免数据未到达时视图的数据显示问题以及数据请求失败后的问题。举个粟子： 12345678910111213141516.state('posts', &#123; url: '/posts/:type', templateUrl: 'posts/posts_tpl.html', controller: 'PostsController as vm', resolve: &#123; posts: function(Posts, $stateParams, $q) &#123; let defer = $q.defer(); if(['unread', 'mark'].indexOf($stateParams.type) !== -1) &#123; defer.resolve(Posts.get(&#123;type: $stateParams.type&#125;).$promise); &#125; else &#123; defer.reject('参数不正确'); &#125; return defer.promise; &#125;, &#125;&#125;) 这是一个路由的状态，这里应用了 promise 的反模式，其实我自己也不是特别了解，之前看到一篇文章再批评这个。我回去学习下再补充。 这个地方的作用就是判断 state 传进的参数是否符合要求，如果不符合要求则无法加载，符合要求的话就会去请求资源，如果请求失败的话视图也不会被加载，即状态不会切换成功，如果请求成功我们可以再控制器依赖注入 posts 取得返回结果。","categories":[{"name":"Angular","slug":"Angular","permalink":"https://ruiming.github.io/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"https://ruiming.github.io/tags/Angular/"}]},{"title":"Angular1之折腾记","slug":"Angular1之折腾记","date":"2016-09-24T15:40:50.000Z","updated":"2016-11-16T16:08:02.000Z","comments":true,"path":"2016/09/24/Angular1之折腾记/","link":"","permalink":"https://ruiming.github.io/2016/09/24/Angular1之折腾记/","excerpt":"前几天 Angular2 正式发布了，虽然他也在我的学习计划里面，但我并没有把他应用在我最近开展的一个项目中。最近在写一个 Rss 订阅器，基于 Angular1 和 Koa2(总感觉两个有点不搭 =.= )，主要是不想在这个项目花太长时间，再者我还想集我目前掌握的所有技术之大成写一个能拿的出手的项目，所以就没有选择 Angular2 了。至于 Koa2，其实很早就想学了，只是之前一直在忙别的。 angular-resource 介绍今天捣鼓 Angular 的 Resource 功能，前端后端都掌握在自己的手上时去用 Angular 的 Resource 特别舒服，大大减少了代码量，特么强大。12345678910(function() &#123; angular .module('app') .factory('Post', $resource =&gt; &#123; return $resource('/api/feed/:feed_id/post/:id', &#123;id: '@_id'&#125;, &#123; update: &#123;method: 'PUT'&#125;, get: &#123;method: 'GET', cache: true&#125; &#125;); &#125;)&#125;()); 在上面我定义了一个 Post 资源，一旦创建完成后，他就自动拥有了以下方法。1234567&#123; 'get': &#123;method: 'GET'&#125;, 'save': &#123;method: 'POST'&#125;, 'query': &#123;method: 'GET', isArray: true&#125;, 'remove': &#123;method: 'DELETE'&#125;, 'delete': &#123;method: 'DELETE'&#125;&#125; 有些 IE 浏览器可能不支持 delete，这时候可以使用 remove。我们还可以自定义或者修改里面的方法，比如我上面中就自定义了一个 update 方法以及给 get 方法开启了缓存。","text":"前几天 Angular2 正式发布了，虽然他也在我的学习计划里面，但我并没有把他应用在我最近开展的一个项目中。最近在写一个 Rss 订阅器，基于 Angular1 和 Koa2(总感觉两个有点不搭 =.= )，主要是不想在这个项目花太长时间，再者我还想集我目前掌握的所有技术之大成写一个能拿的出手的项目，所以就没有选择 Angular2 了。至于 Koa2，其实很早就想学了，只是之前一直在忙别的。 angular-resource 介绍今天捣鼓 Angular 的 Resource 功能，前端后端都掌握在自己的手上时去用 Angular 的 Resource 特别舒服，大大减少了代码量，特么强大。12345678910(function() &#123; angular .module('app') .factory('Post', $resource =&gt; &#123; return $resource('/api/feed/:feed_id/post/:id', &#123;id: '@_id'&#125;, &#123; update: &#123;method: 'PUT'&#125;, get: &#123;method: 'GET', cache: true&#125; &#125;); &#125;)&#125;()); 在上面我定义了一个 Post 资源，一旦创建完成后，他就自动拥有了以下方法。1234567&#123; 'get': &#123;method: 'GET'&#125;, 'save': &#123;method: 'POST'&#125;, 'query': &#123;method: 'GET', isArray: true&#125;, 'remove': &#123;method: 'DELETE'&#125;, 'delete': &#123;method: 'DELETE'&#125;&#125; 有些 IE 浏览器可能不支持 delete，这时候可以使用 remove。我们还可以自定义或者修改里面的方法，比如我上面中就自定义了一个 update 方法以及给 get 方法开启了缓存。 那怎么使用呢？也很简单，如果对 restfulAPI 比较熟悉应该很容易理解。 1234567891011$stateProvider .state('feed.post', &#123; url: '/post/:post_id', templateUrl: 'post/post_tpl.html', controller: 'PostController as vm', resolve: &#123; post: function(Post, $stateParams, $state) &#123; return Post.get(&#123;feed_id: $stateParams.id, id: $stateParams.post_id&#125;).$promise; &#125; &#125; &#125;) 这里就调用了 get 方法，同时把参数传入，这样就好了。其他方法其实一样的。resource 也有很多功能。 1$resource(url, [paramDefaults], [actions], options); 第二个参数设置默认参数用，比如我们发起了一个 get 请求得到数据，这条数据有一个 _id 属性，我们可以把他绑定为默认的 id 参数，这样在之后执行该资源的其他方法时我们可以不指定 id。第三个参数就是自定义方法的地方了，前面我给 get 方法升级了下，是这样的，这个也就是第三个参数了。 1234$resource('/api/feed/:feed_id/post/:id', &#123;id: '@_id'&#125;, &#123; update: &#123;method: 'PUT'&#125;, get: &#123;method: 'GET', cache: true&#125;&#125;); 格式是这样的： 123&#123;action1: &#123;method:?, params:?, isArray:?, headers:?, ...&#125;, action2: &#123;method:?, params:?, isArray:?, headers:?, ...&#125;, ...&#125; 更多说明参考官方文档咯。第四个参数没看明白，可以自己看下官方文档。 angular-resource 缓存问题上一个项目没有用 angular-resource 的时候，我就在 factory 里面缓存 response，下次请求时直接返回该 response。由于用户所操作的和所缓存的都是同一个对象，因此在进行一些对该 response 的修改时比如，用户进行点赞操作，那么我除了发出一个请求之外，我还要将 response 里的是否点赞的值修改过来，这样视图才能反映出来，由于和缓存是同一份东西，因此实现了缓存的同步变化。但不知道是不是这种方式容易导致缓存被破坏还是怎么样，我看了下 angular 以及 angular-resource 的部分源码，发现 angular 在处理 http 缓存时对数据进行了 serialize 操作，而且第一次返回给用户的并不是缓存的结果，而是自己 resource 里面的东西，下次访问时才从缓存取出来后 deserialize 后返回。关于这个问题其实老早就有人发出 issue 了，但官方并没有回应，目前比较好的解决方案就是在修改资源时，删除缓存。可以这样操作: 123var $httpDefaultCache = $cacheFactory.get('$http');$httpDefaultCache.remove(key)；// The cache key is the request URL including search parameters; 那有没有更好的办法呢，其实我也想过，有想到用缓存数据替代返回到控制器的数据，然而从这个尝试开始就发现了很多很坑的地方。我在 httpInjector 里面拦截 response 加入了这么一段代码1234567891011setTimeout(() =&gt; &#123; // 只对 resource 的 cache 进行处理 if(config.config &amp;&amp; config.config.cache === true) &#123; let url = config.config.url; $cacheFactory.get('$http').get(url)[1] = angular.fromJson($cacheFactory.get('$http').get(url)[1]); config.resource.data = $cacheFactory.get('$http').get(url)[1].data; config.config.data = $cacheFactory.get('$http').get(url)[1].data; config.data = $cacheFactory.get('$http').get(url)[1].data; console.log($cacheFactory.get('$http').get(url)); &#125; &#125;); 作用就时强制 serialize 缓存的数据，然后讲全部数据都替换成缓存中的数据，由于在这一阶段并没有开始缓存，所以要设置 setTimeout 推迟操作。这样做了之后，对第一次加载仍然没有什么影响，但第二次加载时就开始起作用了，更改会同步变化到缓存，其实就是之后用的就直接是缓存的对象，而不再是 deserialize 化后的数据，这一步应该归功于我修改了缓存中数据的存储形式。由于第一次返回给控制器的数据并不是从缓存取出来的，而是从 resource 里面取出来的即上面的 config.resource.data，所以我也把他改到缓存中的对象去。为了更好说明问题，我把控制器代码也贴上来。我的目的就是进行 mark 操作后缓存也会自动同步过来。1234567891011121314151617181920(function() &#123; angular .module('app') .controller('PostController', PostController); function PostController($state, post, Post, $scope, _, $rootScope, $timeout, $cacheFactory) &#123; var vm = this; vm.post = post; vm.mark = mark; vm.currentPost = post.data.result; vm.currentPostDetail = post.data.detail; function mark() &#123; vm.currentPostDetail.mark = !vm.currentPostDetail.mark; Post.update(&#123;feed_id: vm.currentPost.feed_id[0], id: vm.currentPost._id&#125;, &#123;type: 'mark'&#125;); &#125; &#125;&#125;()); 按理说，控制器初始化的时候 post 是一个 resource 对象，我在 setTimeout 中修改了 resource 内部的数据，指向到缓存中被 serialize 化的数据。而 vm.currentPost 和 vm.currentPostDetail 又是分别指向 post.data.result 和 post.data.detail，应该我在 vm 上面的操作可以影响到缓存才对，然而并不能。试试看修改 mark 方法。12345function mark() &#123; vm.currentPostDetail.mark = !vm.currentPostDetail.mark; post.data.detail.mark = !post.data.detail.mark; Post.update(&#123;feed_id: vm.currentPost.feed_id[0], id: vm.currentPost._id&#125;, &#123;type: 'mark', revert: true&#125;);&#125; 也就是加了一句话，更改 post 中的数据。结果是工作了！这说明 post 确实此时是指向缓存的。那 vm.currentPostDetail 也是指向 post.data.detail 的，为什么它不工作？其实这不是 angular 的锅，console 试试下面就知道了。12345pre = &#123;status: 200, result: &#123;detail: &#123;a:1&#125;, result: &#123;b:2&#125;&#125;&#125;;ctrl = pre.result.detail; // &#123;a:1&#125;cache = &#123;status: 200, result: &#123;detail: &#123;a:2&#125;, result: &#123;b:3&#125;&#125;&#125;;pre = cache;console.log(ctrl); // &#123;a:1&#125; 应该不止我一个人会认为最后结果应该是 {a: 2} 吧…其实上面还可以再简化成这样1234a = &#123;a:1&#125;;b = a;a = &#123;a:2&#125;;console.log(b); // &#123;a:1&#125; 画一个图的话是这样子的。这样应该就明了了，所以由于控制器第一次取到的 response 一定是 resource 内部的结果，而 httpInjector 是在返回 response 前进行修改，因此我们无法通过 httpInjector 来达到目的。唯一能做到的方法就是让控制器接受到的结果与缓存指向同一内存，假设 $cacheFactory 缓存 http 的结果没有被序列化，那么将 resource 中的数据加入缓存，同时把这个数据返回给控制器，就实现了控制器数据和缓存数据指向一致的目的，所以最终问题还是在 $cacheFactory 把结果给序列化了再存储。为了验证下我们的说法，可以修改下 angular 源码下面的地方:123456789101112131415161718192021function done(status, response, headersString, statusText) &#123; if (cache) &#123; if (isSuccess(status)) &#123; cache.put(url, [status, response, parseHeaders(headersString), statusText]); &#125; else &#123; // remove promise from the cache cache.remove(url); &#125; &#125; function resolveHttpPromise() &#123; resolvePromise(response, status, headersString, statusText); &#125; if (useApplyAsync) &#123; $rootScope.$applyAsync(resolveHttpPromise); &#125; else &#123; resolveHttpPromise(); if (!$rootScope.$$phase) $rootScope.$apply(); &#125;&#125; 把这一行1cache.put(url, [status, response, parseHeaders(headersString), statusText]); 改为1cache.put(url, [status, angular.fromJson(response), parseHeaders(headersString), statusText]); 之后就会发现，从第二次开始缓存的数据就会同步变更了，因为存的是对象，所以下次从缓存取的时候就直接用的对象，所以就可以保持数据的同步了。但第一次还是不行，我也没有再深究下去了，源码有点绕，看不太懂。另外，过程中曾经有想利用 $stateChangeStart 和 $stateChangeSuccess 着手，但是发现这两个事件没有效果，查了资料才知道，ui-router 的新版本(1.0)已经有较大的变化，不再支持上面的事件，而是转而通过 $transition 来操作。如果你还在用老版本的 ui-router，可以试试看这个新版本的，迁移可以参考这里。 花了好几个小时想尝试解决这个问题都没搞定，现在还是搞不懂为什么 angular 要把数据序列化后缓存，是为了数据的稳定吗？如果可以提供一个 option 来设置不是很好吗？不知道有没有什么解决方案，一直没找着，貌似是因为缓存的数据就不应该被修改，但在一些场景它还是有应用用途的吧。","categories":[{"name":"Angular","slug":"Angular","permalink":"https://ruiming.github.io/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"https://ruiming.github.io/tags/Angular/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/tags/JavaScript/"}]},{"title":"提升网站加载速度的 N 个方法","slug":"提升网站加载速度的 N 个方法","date":"2016-09-11T05:53:33.000Z","updated":"2016-09-29T05:07:37.000Z","comments":true,"path":"2016/09/11/提升网站加载速度的 N 个方法/","link":"","permalink":"https://ruiming.github.io/2016/09/11/提升网站加载速度的 N 个方法/","excerpt":"Web 这几年的一个变化之一估计就是各种优化小技巧不断涌出…自己也琢磨和尝试了不少优化，毕竟自己项目的网页首屏加载也是一度接近 2M 的。以下针对 HTTP1 和 HTTP1.1，在 HTTP2 中，很多最佳实践都适得其反了。 减少文件传输数量现在前端代码发布上线的时候一般都会进行压缩，混淆，合并等操作，他们起到了减少文件体积和数量以及混淆代码降低可读性的作用。 浏览器针对同一域名的并发请求数目是有限制的，而在 HTTP1 和 HTTP1.1 中每传输一个资源就得建立一条连接。因此当网站的请求资源数量过多时，会导致后面资源请求的阻塞，也会导致频繁的连接建立和关闭带来的开销。一般浏览器的并发请求数量在4-8之间。因此我们针对同一域名的资源不宜过多，否则就会导致后面资源的阻塞。 针对该问题，我们可以采用合并文件，将资源分到不同域名，缓加载资源，提前加载资源，缓存等手段。具体如下： 合并文件以减少并发请求数量 合并文件也不能简单粗暴的合并为一个，对于长时间不会改变的文件我们要单独合并出来，这个文件是可以进行长期缓存的，而一些变动较为频繁的我们就不应该和上面的这些文件合并在一起，并且他们也不应该设置过激的缓存策略。 将次要文件延迟加载，比如 Google Analysis 一些无关痛痒的文件可以放到页面最尾部，这是最佳实践，这里特别想提一下 async 和 defer，他们并没有对文件的请求产生影响，只是影响了执行的过程，所以我们不应该使用 async 或者 defer 方法来优化。 使用 async，会立即开始并行加载，加载完成后会进行执行并阻塞主渲染进程。 使用 defer，会立即开始并行加载，但会延迟到最后才执行。 分散资源到不同域名 比如图片有专门的域名(img.xxx.com)来存储。一些资源可以考虑第三方 CDN 比如 Bootcss 的 CDN，因为这类 CDN 使用较广，有可能用户浏览器已经有过缓存，这就避免了再次请求和加载，同时也减轻了服务器压力。 使用雪碧图(css sprites)来合并小图片 这个优化技术其实挺常见，将图片合并为一个后使用 background-image 和 background-position 等来控制显示雪碧图的哪一部分就好了，据说还可以自动生成雪碧图自动定位。 利用 200 缓存 这是一个比较极端的缓存方式，200 缓存时浏览器不发出网络请求，直接调用本地缓存，这需要强制浏览器使用本地缓存。我们可以使用 Expires 标志。即给出日期时间，超出该时间后则认为是过时，浏览器才会重新发起请求。这个具体细节我还不太了解。过后补充。 使用懒加载(lazy load) 很多网站特别是有大量图片的网站都会使用该技术。当用户下滑页面时，才开始加载下面的图片。一来减少了页面加载的请求数和加载时间，二来也减少用户流量。不过可能有人会说这样体验不太好，好在业内有人把这个技术做到了堪称极致的地步，就是预先加载一个高度压缩的原图，然后淡出原图。大家应该有体验到类似的技术，就不多说了。 使用预加载技术(prefetch) 这个技术知道的人可能不多，MDN 上面是这样解释的： 页面资源预加载(Link prefetch)是浏览器提供的一个技巧，目的是让浏览器在空闲时间下载或预读取一些文档资源，用户在将来将会访问这些资源。一个Web页面可以对浏览器设置一系列的预加载指示，当浏览器加载完当前页面后，它会在后台静悄悄的加载指定的文档，并把它们存储在缓存里。当用户访问到这些预加载的文档后，浏览器能快速的从缓存里提取给用户。 不过资源预加载其实使用的并不多，可能是因为技术本身不成熟，浏览器支持不够等原因。目前没有发现有哪个网站使用了这个技术。感兴趣的自己去了解下，这里不多阐述这个技术。 集中加载资源 额，这个名字是我自己起的，姑且我认为也是一种优化手段，主要针对的时 SPA。比如 Angular 搭建的 SPA。Angular 提供了 templateCache 这个模块。这个在前面的博客中已经介绍过，简单说就是一个数组，我们把模板全部都预先放入这个数组中。Angular 在请求页面的时候会先检查 templateCache 是否已经缓存了，如果有则直接调用这个缓存的模板，否则发出网络请求获取该模板，同时会放入 templateCache 中缓存。有人可能会问那不是增加了首屏加载的体积大小了吗？的确，但比起用户每点击一个新的页面就发起一个请求而言，这种方式无疑会更适合不是吗？并且如果你的文件确实太大了，那你应该考虑下你是否充分利用了指令功能。 减少文件大小除了减少文件数量，减少文件大小也同样重要，不过比起合并文件这样简单的减少文件数量的操作，减少文件大小就没来的那么简单了。常用的方法如下：","text":"Web 这几年的一个变化之一估计就是各种优化小技巧不断涌出…自己也琢磨和尝试了不少优化，毕竟自己项目的网页首屏加载也是一度接近 2M 的。以下针对 HTTP1 和 HTTP1.1，在 HTTP2 中，很多最佳实践都适得其反了。 减少文件传输数量现在前端代码发布上线的时候一般都会进行压缩，混淆，合并等操作，他们起到了减少文件体积和数量以及混淆代码降低可读性的作用。 浏览器针对同一域名的并发请求数目是有限制的，而在 HTTP1 和 HTTP1.1 中每传输一个资源就得建立一条连接。因此当网站的请求资源数量过多时，会导致后面资源请求的阻塞，也会导致频繁的连接建立和关闭带来的开销。一般浏览器的并发请求数量在4-8之间。因此我们针对同一域名的资源不宜过多，否则就会导致后面资源的阻塞。 针对该问题，我们可以采用合并文件，将资源分到不同域名，缓加载资源，提前加载资源，缓存等手段。具体如下： 合并文件以减少并发请求数量 合并文件也不能简单粗暴的合并为一个，对于长时间不会改变的文件我们要单独合并出来，这个文件是可以进行长期缓存的，而一些变动较为频繁的我们就不应该和上面的这些文件合并在一起，并且他们也不应该设置过激的缓存策略。 将次要文件延迟加载，比如 Google Analysis 一些无关痛痒的文件可以放到页面最尾部，这是最佳实践，这里特别想提一下 async 和 defer，他们并没有对文件的请求产生影响，只是影响了执行的过程，所以我们不应该使用 async 或者 defer 方法来优化。 使用 async，会立即开始并行加载，加载完成后会进行执行并阻塞主渲染进程。 使用 defer，会立即开始并行加载，但会延迟到最后才执行。 分散资源到不同域名 比如图片有专门的域名(img.xxx.com)来存储。一些资源可以考虑第三方 CDN 比如 Bootcss 的 CDN，因为这类 CDN 使用较广，有可能用户浏览器已经有过缓存，这就避免了再次请求和加载，同时也减轻了服务器压力。 使用雪碧图(css sprites)来合并小图片 这个优化技术其实挺常见，将图片合并为一个后使用 background-image 和 background-position 等来控制显示雪碧图的哪一部分就好了，据说还可以自动生成雪碧图自动定位。 利用 200 缓存 这是一个比较极端的缓存方式，200 缓存时浏览器不发出网络请求，直接调用本地缓存，这需要强制浏览器使用本地缓存。我们可以使用 Expires 标志。即给出日期时间，超出该时间后则认为是过时，浏览器才会重新发起请求。这个具体细节我还不太了解。过后补充。 使用懒加载(lazy load) 很多网站特别是有大量图片的网站都会使用该技术。当用户下滑页面时，才开始加载下面的图片。一来减少了页面加载的请求数和加载时间，二来也减少用户流量。不过可能有人会说这样体验不太好，好在业内有人把这个技术做到了堪称极致的地步，就是预先加载一个高度压缩的原图，然后淡出原图。大家应该有体验到类似的技术，就不多说了。 使用预加载技术(prefetch) 这个技术知道的人可能不多，MDN 上面是这样解释的： 页面资源预加载(Link prefetch)是浏览器提供的一个技巧，目的是让浏览器在空闲时间下载或预读取一些文档资源，用户在将来将会访问这些资源。一个Web页面可以对浏览器设置一系列的预加载指示，当浏览器加载完当前页面后，它会在后台静悄悄的加载指定的文档，并把它们存储在缓存里。当用户访问到这些预加载的文档后，浏览器能快速的从缓存里提取给用户。 不过资源预加载其实使用的并不多，可能是因为技术本身不成熟，浏览器支持不够等原因。目前没有发现有哪个网站使用了这个技术。感兴趣的自己去了解下，这里不多阐述这个技术。 集中加载资源 额，这个名字是我自己起的，姑且我认为也是一种优化手段，主要针对的时 SPA。比如 Angular 搭建的 SPA。Angular 提供了 templateCache 这个模块。这个在前面的博客中已经介绍过，简单说就是一个数组，我们把模板全部都预先放入这个数组中。Angular 在请求页面的时候会先检查 templateCache 是否已经缓存了，如果有则直接调用这个缓存的模板，否则发出网络请求获取该模板，同时会放入 templateCache 中缓存。有人可能会问那不是增加了首屏加载的体积大小了吗？的确，但比起用户每点击一个新的页面就发起一个请求而言，这种方式无疑会更适合不是吗？并且如果你的文件确实太大了，那你应该考虑下你是否充分利用了指令功能。 减少文件大小除了减少文件数量，减少文件大小也同样重要，不过比起合并文件这样简单的减少文件数量的操作，减少文件大小就没来的那么简单了。常用的方法如下： 开启 GZIP 压缩 GZIP 压缩应用非常广泛，因其可以有效明显的减少文件的体积。在 Nginx 中，我们可以很简单的进行配置开启 GZIP 压缩。 12345678gzip on;gzip_vary on;gzip_comp_level 4;gzip_buffers 16 8K;gzip_min_length 1k;gzip_proxied any;gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;gzip_disable \"MSIE [1-6]\\.\"; 这是我项目服务器上面 Nginx 关于 gzip 的配置。我们关心的当然还是压缩前后文件大小的差异，找别人的一个图贴下： 可以看到效果还是很明显的，一般 GZIP 等级不宜高于 4 级。因为压缩意味着浏览器下载后还需要解压，所以压缩等级过高反而会带来性能问题（移动端耗电增加）甚至是降低页面渲染（解压占用CPU影响页面渲染且耗时）。 另外，大文件压缩效果更明显，所以合并文件后再压缩会比分开压缩效果要好。 使用 WebP 格式图片 WebP 是 Google 推出的一种同时提供有损压缩与无损压缩的图片文件格式。根据 Google 较早的测试，无损压缩后的 WebP 比 PNG 文件少了45%的文件大小，即使这些 PNG 文件经过其他压缩工具压缩之后，WebP 还是可以减少28%的文件大小。 WebP 在互联网上已经非常流行，主流浏览器都已经支持，并且国内也有大量站点如淘宝网，腾讯网，QQ空间等等都使用了这一格式。另外，针对不支持的浏览器，也可以引入相应的 shim 解决。 书写压缩友好的代码 这个对开发人员就要较高的要求了，并且如果不是对文件体积有很大的要求一般都不会做到这一步。在代码压缩的过程有一步就是进行变量替换，举一个前面博客中的例子来说 123456 var ArrayProto = Array.prototype, ObjProto = Object.prototype;var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;var push = ArrayProto.push, slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty; Array.prototype.push 是无法压缩的，而如果我们赋值 ArrayProto = Array.prototype ，那么 ArrayProto 就可以被替换掉，同理，上面中的 push, slice 等都是对压缩友好的。除此之外，一般的压缩工具还会把 undefined 都替换为 void 0，一来可以避免 underfined 重写的问题，二来字符数少了。目前我比较清楚的就这两个，有兴趣的话可以去了解下压缩的过程，对比下压缩前后。 避免引入无用代码有一种比较常见的场景是我们使用了 FontAweSome 等的文件后，虽然我们可以很方便的通过写 CSS 类名来添加修改图标，但我们用到的毕竟时少数图标，所以其他没有用到的图标的引入就是非必须的。这个我自己没有实践过，可以看看Optimize Font Awesome for only used classes这里的讨论。除了去做筛选之外，还有的办法就是我们不要引入整个图标文件，有些提供图标的网站可以让你自己选择需要的图标后以字体和 CSS 文件的形式下载下来。这样做就稍微麻烦一点，不过既然你要图文件小，那麻烦一点也没什么。 其他 Web 提速手段前面集中就文件请求数和文件体积开展讨论，其实还远远不止上面这些办法。常用的还有以下这些。 dns-prefetch 这个其实和前面说的资源预加载差不多，只是这个是 DNS 预解析。用户访问一个新的域名之前，会首先通过 DNS 解析得到他的 IP 地址，之后才开始建立连接。DNS 解析也是需要时间的，而这个技术的作用就是在用户页面空闲的时候去预获取 IP 地址并缓存，这样当访问该域名页面的时候，就不需要再解析域名，从而缩短了页面加载时间。 Preconnect 这个和上面差不多，但是不光会解析 DNS 还会建立 TCP 握手连接和 TLS 协议(如果需要的话)用法如下： 1&lt;link rel=\"preconnect\" href=\"https://ruiming.github.io\"&gt; 但是这个的支持还比较一般，我也没找到有谁使用了这个技术。 其实类似的预xx技术还挺多，还有预渲染等，感兴趣的可以参考此处 使用第三方 CDN 前面也有稍微提了下 CDN。对于 CDN 的使用应该根据实际情况来，如果整个页面就只引入了两三个第三方库，我们可以考虑使用公共 CDN 比如 Bootcss 的 CDN。其一是真的很快，比七牛什么都快好多，其二是用的人多，可能用户浏览器已经缓存了，另外 Bootcss 的 CDN 默认使用 HTTP2，在支持 HTTP2 的浏览器中，他也可以避免影响我们网站资源并发请求数量的问题，当然如果你也是用 HTTP2 这个问题就不大了。 如果不使用公共 CDN，对于个人也可以使用七牛或者其他的提供的 CDN 存储。CDN 的好处在可以根据用户位置就近分配资源，同时也可以减轻服务器压力。 参考资料：WebP 探寻之路: https://isux.tencent.com/introduction-of-webp.html一箩筐的预加载技术: http://www.alloyteam.com/2015/10/prefetching-preloading-prebrowsing","categories":[{"name":"还不知道分什么类好","slug":"还不知道分什么类好","permalink":"https://ruiming.github.io/categories/还不知道分什么类好/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/tags/JavaScript/"},{"name":"HTTP","slug":"HTTP","permalink":"https://ruiming.github.io/tags/HTTP/"},{"name":"Web","slug":"Web","permalink":"https://ruiming.github.io/tags/Web/"}]},{"title":"浅谈 Angular 脏检查","slug":"浅谈 Angular 脏检查","date":"2016-09-04T06:57:22.000Z","updated":"2016-09-09T11:11:58.000Z","comments":true,"path":"2016/09/04/浅谈 Angular 脏检查/","link":"","permalink":"https://ruiming.github.io/2016/09/04/浅谈 Angular 脏检查/","excerpt":"Angular 的脏值检查机制一直是 Angular 被人诟病的地方，但瑕不掩瑜，Angular 还是一个非常优秀的框架，并且 Angular2 也已经抛弃了这个脏值检查的算法。最近在看《AngularJS 深度剖析与最佳实践》，不得不说是一本很好的书籍，作者在第三章开始讲背后的原理，这里分析了 Angular 的 $digest 函数，即脏检查机制。所以自己也去下载了 Angular 最新的源码去瞧了下，然后做下笔记吧。 首先要注意，Angular 的 digest 的触发不是定时的，只有在指定的事件触发之后才会进入 $digest。基本上我们用的带 $ 的东西调用之后都可能会触发 digest。比如我们使用 setTimeout 就不会触发 digest，即当你使用 setTimeout 更改 viewmodel 的值后，它不会同步的反映到用户的视图中去，解决方法有两个，一个是使用 Angular 提供的 $timeout 替代 setTimeout，$timeout 会在执行结束之后自动触发 digest； 另一个方法是手动调用 $apply，$apply 是 Angular 对 digest 的一层封装，我们一般不会直接调用 digest 而是通过使用 $apply 方法。比如对于 setTimeout，我们就可以这样触发 digest。12345setTimeout(() =&gt; &#123; $scope.$apply(() =&gt; &#123; $scope.test = 123; &#125;) &#125;, 500); 我们看一个例子，这也是 Angular 源码 $digest 部分的一个示例。12345678910111213141516171819202122var scope = ...;scope.name = 'misko';scope.counter = 0;expect(scope.counter).toEqual(0);scope.$watch('name', function(newValue, oldValue)&#123; scope.counter = scope.counter + 1;&#125;);expect(scope.counter).toEqual(0);// 执行第一次 digest，第一次 digest 会遍历全部的 watcher，并触发上面的方法，从而使的 count+1scope.$digest();expect(scope.counter).toEqual(1);// 第二次调用时，由于上一次调用检查 name 不脏，所以不会再去处理scope.$digest();expect(scope.counter).toEqual(1);// 第三次调用时，由于 name 发生了变化，使得当前值和上一次保存的值不同，所以会触发起 $watch 方法scope.name = 'adam';scope.$digest();expect(scope.counter).toEqual(2); Angular 的脏值检查过程大致如下：对当前作用域和子作用域上的 $$watchers 进行遍历，$$watches 保存着 scope 上的所有变量以及其 $watch 方法，调用时会取当前值和上一次值进行比较，如果不相等则会调用 $watch 方法，同时会保存当前的值以在下一次进行比较，并且记录此次检查结果为脏。然后重复进行直到数据不脏为止，因此至少要 digest 两次，超出 10 次会报错，可以调高这个次数限制。当数据不再脏即 model 稳定下来之后， Angular 才会开始一次性批量更新 UI。从而减少了浏览器的 repaint 次数，提升性能。 深入到源码来看：","text":"Angular 的脏值检查机制一直是 Angular 被人诟病的地方，但瑕不掩瑜，Angular 还是一个非常优秀的框架，并且 Angular2 也已经抛弃了这个脏值检查的算法。最近在看《AngularJS 深度剖析与最佳实践》，不得不说是一本很好的书籍，作者在第三章开始讲背后的原理，这里分析了 Angular 的 $digest 函数，即脏检查机制。所以自己也去下载了 Angular 最新的源码去瞧了下，然后做下笔记吧。 首先要注意，Angular 的 digest 的触发不是定时的，只有在指定的事件触发之后才会进入 $digest。基本上我们用的带 $ 的东西调用之后都可能会触发 digest。比如我们使用 setTimeout 就不会触发 digest，即当你使用 setTimeout 更改 viewmodel 的值后，它不会同步的反映到用户的视图中去，解决方法有两个，一个是使用 Angular 提供的 $timeout 替代 setTimeout，$timeout 会在执行结束之后自动触发 digest； 另一个方法是手动调用 $apply，$apply 是 Angular 对 digest 的一层封装，我们一般不会直接调用 digest 而是通过使用 $apply 方法。比如对于 setTimeout，我们就可以这样触发 digest。12345setTimeout(() =&gt; &#123; $scope.$apply(() =&gt; &#123; $scope.test = 123; &#125;) &#125;, 500); 我们看一个例子，这也是 Angular 源码 $digest 部分的一个示例。12345678910111213141516171819202122var scope = ...;scope.name = 'misko';scope.counter = 0;expect(scope.counter).toEqual(0);scope.$watch('name', function(newValue, oldValue)&#123; scope.counter = scope.counter + 1;&#125;);expect(scope.counter).toEqual(0);// 执行第一次 digest，第一次 digest 会遍历全部的 watcher，并触发上面的方法，从而使的 count+1scope.$digest();expect(scope.counter).toEqual(1);// 第二次调用时，由于上一次调用检查 name 不脏，所以不会再去处理scope.$digest();expect(scope.counter).toEqual(1);// 第三次调用时，由于 name 发生了变化，使得当前值和上一次保存的值不同，所以会触发起 $watch 方法scope.name = 'adam';scope.$digest();expect(scope.counter).toEqual(2); Angular 的脏值检查过程大致如下：对当前作用域和子作用域上的 $$watchers 进行遍历，$$watches 保存着 scope 上的所有变量以及其 $watch 方法，调用时会取当前值和上一次值进行比较，如果不相等则会调用 $watch 方法，同时会保存当前的值以在下一次进行比较，并且记录此次检查结果为脏。然后重复进行直到数据不脏为止，因此至少要 digest 两次，超出 10 次会报错，可以调高这个次数限制。当数据不再脏即 model 稳定下来之后， Angular 才会开始一次性批量更新 UI。从而减少了浏览器的 repaint 次数，提升性能。 深入到源码来看：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119$digest: function() &#123; var watch, value, last, fn, get, watchers, length, dirty, ttl = TTL, next, current, target = this, watchLog = [], logIdx, asyncTask; beginPhase('$digest'); $browser.$$checkUrlChange(); if (this === $rootScope &amp;&amp; applyAsyncId !== null) &#123; $browser.defer.cancel(applyAsyncId); flushApplyAsync(); &#125; lastDirtyWatch = null; do &#123; dirty = false; current = target; for (var asyncQueuePosition = 0; asyncQueuePosition &lt; asyncQueue.length; asyncQueuePosition++) &#123; try &#123; asyncTask = asyncQueue[asyncQueuePosition]; asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals); &#125; catch (e) &#123; $exceptionHandler(e); &#125; lastDirtyWatch = null; &#125; asyncQueue.length = 0; // 脏值检查开始 traverseScopesLoop: do &#123; // 获取当前 scope 的 $$watchers if ((watchers = current.$$watchers)) &#123; // process our watches // 遍历执行这些 watches length = watchers.length; while (length--) &#123; try &#123; watch = watchers[length]; if (watch) &#123; get = watch.get; if ((value = get(current)) !== (last = watch.last) &amp;&amp; !(watch.eq ? equals(value, last) : (typeof value === 'number' &amp;&amp; typeof last === 'number' &amp;&amp; isNaN(value) &amp;&amp; isNaN(last)))) &#123; // 优先使用 === 判断 value 和 last，其次再是根据他们是否为数字做 ng 的深度相等判断或者 isNaN 判断 dirty = true; lastDirtyWatch = watch; // 如果 watch.eq 为 true，表示该 watch 的目标为对象，所以把该对象克隆到 watch.last 上面以下一次 digest 时来判断 // 如果 watch.eq 为 false，表示该 watch 的目标为数字，所以直接赋值就可以了 // 这里和上面一样都是为了提高速度和性能用 watch.last = watch.eq ? copy(value, null) : value; // 获取该 watch 的表达式并执行 fn = watch.fn; // 如果 last 和最开始的值相同则使用后者，否则使用前者。 fn(value, ((last === initWatchVal) ? value : last), current); if (ttl &lt; 5) &#123; logIdx = 4 - ttl; if (!watchLog[logIdx]) watchLog[logIdx] = []; watchLog[logIdx].push(&#123; msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp, newVal: value, oldVal: last &#125;); &#125; &#125; else if (watch === lastDirtyWatch) &#123; dirty = false; break traverseScopesLoop; &#125; &#125; &#125; catch (e) &#123; $exceptionHandler(e); &#125; &#125; &#125; // Insanity Warning: scope depth-first traversal // yes, this code is a bit crazy, but it works and we have tests to prove it! // this piece should be kept in sync with the traversal in $broadcast // 对当前 scope 的子 scope 做遍历 if (!(next = ((current.$$watchersCount &amp;&amp; current.$$childHead) || (current !== target &amp;&amp; current.$$nextSibling)))) &#123; while (current !== target &amp;&amp; !(next = current.$$nextSibling)) &#123; current = current.$parent; &#125; &#125; &#125; while ((current = next)); // 脏值检查未结束但此时 ttl 为 0，则抛出错误 if ((dirty || asyncQueue.length) &amp;&amp; !(ttl--)) &#123; clearPhase(); throw $rootScopeMinErr('infdig', '&#123;0&#125; $digest() iterations reached. Aborting!\\n' + 'Watchers fired in the last 5 iterations: &#123;1&#125;', TTL, watchLog); &#125; // 循环遍历直到 dirty 为 false 并且 asyncQueue.length = 0 &#125; while (dirty || asyncQueue.length); clearPhase(); // 执行 postDigest 序列 while (postDigestQueuePosition &lt; postDigestQueue.length) &#123; try &#123; postDigestQueue[postDigestQueuePosition++](); &#125; catch (e) &#123; $exceptionHandler(e); &#125; &#125; postDigestQueue.length = postDigestQueuePosition = 0;&#125; 不过这段代码我也不是全都理解了，但是核心的算了解了。总体来看这个算法还是很简单粗暴的，这里保留了一段注释，有意思，官方吐槽的感觉。 由于脏检查的性能问题，在页面绑定数据较多的时候，我们应该尽量减少双向绑定的数量，比如使用 ngInfiniteScroll 这样的插件，适当使用单向绑定，甚至是取消一些变量的 watch 方法。","categories":[{"name":"Angular","slug":"Angular","permalink":"https://ruiming.github.io/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"https://ruiming.github.io/tags/Angular/"}]},{"title":"项目采坑笔记","slug":"项目采坑笔记","date":"2016-08-15T08:37:19.000Z","updated":"2016-08-15T15:38:01.000Z","comments":true,"path":"2016/08/15/项目采坑笔记/","link":"","permalink":"https://ruiming.github.io/2016/08/15/项目采坑笔记/","excerpt":"有段时间没写博客了，前段时间在看 Underscore 源码所以写的多了点，这段时间还是在忙自己的其他项目去了，还是有不少收获的。 Angular 视图过渡动画之前使用 angular-promise-button 这个模块实现了按钮的自动变化，以前自己是用很多标志位来判断特别二。不仅如此，页面切换动画也是用标志位判断，这样就特别不好维护特别不优雅，上次重构的时候就把这些全部去掉了。但是问题来了，页面数据未到达时候页面就渲染肯定会造成视觉上的问题，怎么解决呢。我们都想写一些应用很广的代码，比如指令，比如上面这个 angular-promise-button 模块等等。其实要解决上面的问题，也是几行代码就可以解决的事情了。我所使用的是 Angular 的 ui-router。ngRoute 应该也差不多。在 ui-router 中可以使用 resolve 达到在控制器初始化以及视图加载前确保数据到达。比如：1234567891011121314$stateProvider .state('me',&#123; url: '/me', controller: 'MeCtrl', templateUrl: 'me/me_tpl.html', controllerAs: 'vm', nav: true, resolve: &#123; me: function(userservice) &#123; return userservice.getUserInfo() .then(response =&gt; response); &#125; &#125; &#125;) 只有 resolve 中的全部方法执行完后，才会开始初始化控制和加载视图。这个数据如果在控制器或者视图中要使用，可以在控制器中进行依赖注入。例如上面这个我的控制器是这样写的：1234567891011121314(function()&#123; 'use strict'; angular .module('index') .controller('MeCtrl', MeCtrl); MeCtrl.$inject = ['me']; function MeCtrl(me) &#123; let vm = this; vm.user = me; &#125;&#125;()); resolve中的方法是阻塞页面进行的，这样就会带来问题了，如果数据请求比较久将导致网站停滞，我们这时候就希望可以有过渡动画出来。要达到全局过渡效果的作用，可以直接监听 $rootScope 中的三个状态即 $stateChangeStart 和 $stateChangeSuccess 以及 $stateChangeError 事件。例如上面这个例子中，当我们触发 me 这个 state 时，也就触发了 $rootScope 上的 $stateChangeStart 事件，当处理结束后将出发 $stateChangeSuccess 并加载视图， 处理失败就会触发 $stateChangeError 事件。代码如下：123456789101112131415161718192021222324252627282930313233343536angular .module('index', [ 'ui.router', 'ui.bootstrap', 'ngAnimate', 'ngSanitize', 'ngTouch', 'infinite-scroll', 'angularPromiseButtons' ]) .config(config) .run(($state,$rootScope) =&gt; &#123; $rootScope.$state = $state; $rootScope.$on(\"$stateChangeStart\", (event, toState, toStateParams, fromState, fromStateParams) =&gt; &#123; var isLoading = toState.resolve; if(!isLoading) &#123; for (var prop in toState.views) &#123; if (toState.views.hasOwnProperty(prop)) &#123; if(toState.views[prop].resolve) &#123; isLoading = true; break; &#125; &#125; &#125; &#125; if (isLoading) &#123; $rootScope.loading = true; &#125; &#125;); $rootScope.$on(\"$stateChangeSuccess\", (event, toState, toParams, fromState, fromParams) =&gt; &#123; $rootScope.loading = false; &#125;); $rootScope.$on(\"$stateChangeError\", (event, toState, toParams, fromState, fromParams, error) =&gt; &#123; $rootScope.loading = false; &#125;); &#125;); 入口页面，省去了其他代码，这里第一行就是视图，第二行是加载动画，通过ng-show来控制显示。第三行是引入导航栏，这个在后面会说下。123&lt;div ui-view class=\"uiview\" ng-show=\"!$root.loading\"&gt;&lt;/div&gt;&lt;div class=\"cssload-thecube\" ng-show=\"$root.loading\"&gt; loading... &lt;/div&gt;&lt;div ng-show=\"$state.current.nav\" ng-include=\"'navbar/navbar_tpl.html'\"&gt;&lt;/div&gt; 可以看到上面的代码中是监听了 $stateChangeStart 事件，然后获取目标 state 上的 resolve 方法，当 state 上的 resolve 方法全部结束后，$rootScope.loading 设置为 false，否则保持为 true。当监听到 $stateChangeSuccess 或者 $stateChangeError 事件时，置 $rootScope.loading 为 false，退出过渡动画。在视图中可以使用 $root 得到 $rootScope。可以看到这里有很多参数，可见其功能是很强大的。","text":"有段时间没写博客了，前段时间在看 Underscore 源码所以写的多了点，这段时间还是在忙自己的其他项目去了，还是有不少收获的。 Angular 视图过渡动画之前使用 angular-promise-button 这个模块实现了按钮的自动变化，以前自己是用很多标志位来判断特别二。不仅如此，页面切换动画也是用标志位判断，这样就特别不好维护特别不优雅，上次重构的时候就把这些全部去掉了。但是问题来了，页面数据未到达时候页面就渲染肯定会造成视觉上的问题，怎么解决呢。我们都想写一些应用很广的代码，比如指令，比如上面这个 angular-promise-button 模块等等。其实要解决上面的问题，也是几行代码就可以解决的事情了。我所使用的是 Angular 的 ui-router。ngRoute 应该也差不多。在 ui-router 中可以使用 resolve 达到在控制器初始化以及视图加载前确保数据到达。比如：1234567891011121314$stateProvider .state('me',&#123; url: '/me', controller: 'MeCtrl', templateUrl: 'me/me_tpl.html', controllerAs: 'vm', nav: true, resolve: &#123; me: function(userservice) &#123; return userservice.getUserInfo() .then(response =&gt; response); &#125; &#125; &#125;) 只有 resolve 中的全部方法执行完后，才会开始初始化控制和加载视图。这个数据如果在控制器或者视图中要使用，可以在控制器中进行依赖注入。例如上面这个我的控制器是这样写的：1234567891011121314(function()&#123; 'use strict'; angular .module('index') .controller('MeCtrl', MeCtrl); MeCtrl.$inject = ['me']; function MeCtrl(me) &#123; let vm = this; vm.user = me; &#125;&#125;()); resolve中的方法是阻塞页面进行的，这样就会带来问题了，如果数据请求比较久将导致网站停滞，我们这时候就希望可以有过渡动画出来。要达到全局过渡效果的作用，可以直接监听 $rootScope 中的三个状态即 $stateChangeStart 和 $stateChangeSuccess 以及 $stateChangeError 事件。例如上面这个例子中，当我们触发 me 这个 state 时，也就触发了 $rootScope 上的 $stateChangeStart 事件，当处理结束后将出发 $stateChangeSuccess 并加载视图， 处理失败就会触发 $stateChangeError 事件。代码如下：123456789101112131415161718192021222324252627282930313233343536angular .module('index', [ 'ui.router', 'ui.bootstrap', 'ngAnimate', 'ngSanitize', 'ngTouch', 'infinite-scroll', 'angularPromiseButtons' ]) .config(config) .run(($state,$rootScope) =&gt; &#123; $rootScope.$state = $state; $rootScope.$on(\"$stateChangeStart\", (event, toState, toStateParams, fromState, fromStateParams) =&gt; &#123; var isLoading = toState.resolve; if(!isLoading) &#123; for (var prop in toState.views) &#123; if (toState.views.hasOwnProperty(prop)) &#123; if(toState.views[prop].resolve) &#123; isLoading = true; break; &#125; &#125; &#125; &#125; if (isLoading) &#123; $rootScope.loading = true; &#125; &#125;); $rootScope.$on(\"$stateChangeSuccess\", (event, toState, toParams, fromState, fromParams) =&gt; &#123; $rootScope.loading = false; &#125;); $rootScope.$on(\"$stateChangeError\", (event, toState, toParams, fromState, fromParams, error) =&gt; &#123; $rootScope.loading = false; &#125;); &#125;); 入口页面，省去了其他代码，这里第一行就是视图，第二行是加载动画，通过ng-show来控制显示。第三行是引入导航栏，这个在后面会说下。123&lt;div ui-view class=\"uiview\" ng-show=\"!$root.loading\"&gt;&lt;/div&gt;&lt;div class=\"cssload-thecube\" ng-show=\"$root.loading\"&gt; loading... &lt;/div&gt;&lt;div ng-show=\"$state.current.nav\" ng-include=\"'navbar/navbar_tpl.html'\"&gt;&lt;/div&gt; 可以看到上面的代码中是监听了 $stateChangeStart 事件，然后获取目标 state 上的 resolve 方法，当 state 上的 resolve 方法全部结束后，$rootScope.loading 设置为 false，否则保持为 true。当监听到 $stateChangeSuccess 或者 $stateChangeError 事件时，置 $rootScope.loading 为 false，退出过渡动画。在视图中可以使用 $root 得到 $rootScope。可以看到这里有很多参数，可见其功能是很强大的。再看下上面这个第三行1&lt;div ng-show=\"$state.current.nav\" ng-include=\"'navbar/navbar_tpl.html'\"&gt;&lt;/div&gt; 结合上面的 JS 代码来看，我已经把 $state 注入到了 $rootScope 中了，之后我就可以使用 $state.current 来获取当前的视图状态和信息。我需要实现导航栏仅仅出现在我指定的页面中，下方按钮可以根据当前视图来激活。第一点可以通过给路由 state 补充变量比如我这里的 nav 来实现，需要导航栏的地方就设置 nav 为 true, 否则就不设置。第二点则可以利用 ui-sref-active 来实现。如下：123456789&lt;!-- navbar/navbar_tpl.html --&gt;&lt;nav class=\"bookist-nav navbar navbar-default\" role=\"navigation\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li ui-sref-active=\"active\"&gt;&lt;a ui-sref=\"index\"&gt;&lt;i class=\"fa fa-home fa-lg\"&gt;&lt;/i&gt;&lt;p&gt;首页&lt;/p&gt;&lt;/a&gt;&lt;/li&gt; &lt;li ui-sref-active=\"active\"&gt;&lt;a ui-sref=\"booklists\"&gt;&lt;i class=\"fa fa-th-large fa-lg\"&gt;&lt;/i&gt;&lt;p&gt;书单&lt;/p&gt;&lt;/a&gt;&lt;/li&gt; &lt;li ui-sref-active=\"active\"&gt;&lt;a ui-sref=\"cart\"&gt;&lt;i class=\"fa fa-shopping-cart fa-lg\"&gt;&lt;/i&gt;&lt;p&gt;购物车&lt;/p&gt;&lt;/a&gt;&lt;/li&gt; &lt;li ui-sref-active=\"active\"&gt;&lt;a ui-sref=\"me\"&gt;&lt;i class=\"fa fa-user fa-lg\"&gt;&lt;/i&gt;&lt;p&gt;我的&lt;/p&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 最后还有一个地方就是，下面这个代码1&lt;div ui-view class=\"uiview\" ng-show=\"!$root.loading\"&gt;&lt;/div&gt; ui-view 的用法其实还不少，如果你有去注意的话，会看到这个视图在变化的时候其类名会变化，依次我们可以结合 angular-animate 来实现切换动画。注意这个切换动画是在视图加载后才开始的，和上面的不一样，如果同时使用，则会在上方过渡效果结束后触发。例如，我们可以实现淡入淡出：123456789.uiview &#123; &amp;.ng-enter &#123; transition: .5s; opacity: 0; &#125; &amp;.ng-enter-active &#123; opacity: 1; &#125;&#125; 所以上面其实说了好几点： 使用路由上的 resolve 来实现在控制器初始化前获取到需要的数据 监听 $rootScope 上的事件来实现 resolve 等待动画 在 ui-view 上通过使用 angular-animate 来实现视图的切换动画 通过 ui-sref-active 在当 ui-sref 和当前 state 一致时激活 active 类名 把 $state 注入到 $rootScope 达到在视图中获取 $state 用途 使用 $root 得到 $rootScope，利用 $root 获取 $rootScope 上的对象 静态资源自动发布七牛云这个很简单啦，我使用了 gulp-qiniu 这个模块来实现，很简单，结合前面说的 gulp-usemin 就更完美了。1234&lt;!-- build:js //cdn.bookist.org/bookist.min.js --&gt;&lt;script src=\"src/js/bookist.js\"&gt;&lt;/script&gt;&lt;script src=\"src/js/templates.js\"&gt;&lt;/script&gt;&lt;!-- endbuild --&gt; 例如对上面 index.html 中的这一片段，我们要在开发环境中使用本地资源，而在线上环境则使用 CDN 资源。我们可以这样配置 gulpfile。12345678910111213141516gulp.task('cdn', () =&gt; &#123; gulp.src('index.html') .pipe(usemin()) .pipe(gulp.dest('backend/app/templates')); gulp.src(['./src/js/bookist.js', './src/js/templates.js']) .pipe(plumber()) .pipe(uglify()) .pipe(babel()) .pipe(concat('bookist.min.js')) .pipe(qiniu(&#123; accessKey: \"xxx\", secretKey: \"xxx\", bucket: \"bookist\", private: false &#125;));&#125; 运行上面的任务后就会在 backend/app/templates 生成一个修改过的 index.html。对于上面的片段，处理之后是这样的：1&lt;script src=\"//cdn.bookist.org/bookist.min.js\"&gt;&lt;/script&gt; 前面的注释是给 usemin 使用的，所以要按照规范书写。同时上面的任务也会把资源发布到七牛云上面，如果你还想指定文件头或者版本号之类的信息，可以参考 gulp-qiniu 的文档进行配置。上面的方法有一个小问题就是还会在 backend/app/templates 生成一个 cdn.bookist.org 的文件夹，不过无所谓咯，放到 .gitignore 就好了。至于图片和 css 都差不多吧，就不多说了。 微信坑逼有段时间我的网站在微信显示部分地方是有问题的，但在手机浏览器和电脑都没任何问题，一开始以为是样式的问题。等到自己要去解决这个问题了，才知道是 js 的问题。由于微信开发工具不支持 linux，然后我虚拟机的 win10 有不知道什么原因一直连接不到手机。所以就手动调试了，这边改一点，发布上去，然后等微信缓存没了看效果(微信恶心的缓存…我都叫用苹果的人帮我看，因为苹果可以刷新..)。就这样一步步看，最后定位了问题代码。中间过程就不描述了，直接看：1234for(let book of books) &#123; if(book.rate) book.star = Math.ceil(book.rate/2); else if(book.star) book.star = Math.ceil(book.star/2);&#125; 省略了无关代码，这是一个方法里面的部分代码，如果一个对象传入这个方法中，在微信会得不到返回值，在手机浏览器和电脑上都正常。虽然这里使用了 ES6 的语法，但是我其实已经大量使用 let…of… 语句，项目并没有出现太大问题，就只是上面描述的一些地方异常而已。再者我使用了 babel 转码了。越想越觉得没道理啊。。。最后虚拟机换了 win7 然后手机连接上了，打开了微信开发工具，调试微信 webview，报错 Symbol is not defined。果断控制台敲 Symbol，结果 Symbol is not defined。好吧，问题出来了，微信这个辣鸡不支持 Symbol…但问题是我没有用 Symbol 这个东西啊，我瞄了 babel 一眼。看下上面那段代码转码的结果：1234567891011121314151617181920212223var _iteratorNormalCompletion5 = true;var _didIteratorError5 = false;var _iteratorError5 = undefined;try &#123; for (var _iterator5 = books[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) &#123; var book = _step5.value; if (book.rate) book.star = Math.ceil(book.rate / 2);else if (book.star) book.star = Math.ceil(book.star / 2); &#125;&#125; catch (err) &#123; _didIteratorError5 = true; _iteratorError5 = err;&#125; finally &#123; try &#123; if (!_iteratorNormalCompletion5 &amp;&amp; _iterator5.return) &#123; _iterator5.return(); &#125; &#125; finally &#123; if (_didIteratorError5) &#123; throw _iteratorError5; &#125; &#125; 什么鬼…算了，不看了，但是确定了是 babel 转码导致的。然后查了下资料： Babel默认只转换新的JavaScript句法(syntax)，而不转换新的API，比如Iterator, Generator, Set, Maps, Proxy, Reflect, Symbol, Promise等全局对象，以及一些定义在全局对象上的方法(比如Object.assign)都不会转码。 其实早有耳闻 polyfill 这个东西，但我想他一般是用在 IE 这种辣鸡浏览器上的，没想到微信 webview 这么不争气。多打包一个 babel-polyfill 解决了这个问题。坑比微信… 故事还没结束…昨天发现网站并没有使用 http2，但是已经进行了设置了，最后查了很多资料原因好像是 openssl 的问题，但由于使用的是 docker，貌似不太好搞，但其实更换 nginx 版本就好了，原先是1.9版本，换成1.11-alpine 版就解决了，用 docker 更换 nginx 版本非常方便。额，具体原因不深究了，可能跟 alpine 这个字眼有关？不清楚…http2 具备多路复用的特点，在 http1.1 中，并行传输文件是有限制的，因为用户端和服务端的最大连接数是有限制的，而连接的建立和销毁又会带来开销，所以在 http1.1 中对文件进行压缩合并是很有必要的。不过在 http2 就不需要这样做了，http2 可以在一条通道上传输多个文件，如果合并剩几个，就没法发挥并行传输的优势，而且文件太大，还会降低运输层的效率，即丢包或者乱序到达的影响。我把网站改到了 http2 后，就不再进行文件合并了，转而可以大量使用 bootcss 的 CDN，bootcss 的 CDN 支持 http2，传输很快。至于上面没有的和自己写的，就发布到七牛云上面。恩，电脑上加载是变快了很多。但是感觉不到微信加载变快…最后发现是微信不支持 http2…好伤心…最后我的方案是产生两个 css 文件和两个 js 文件，之所以是两个，因为一个是自己写的，经常变，另一个是用别人的，几乎不会变。 最后又发现微信好像支持 spdy… 心好累，算了，降了 nginx 版本开启 spdy 不理了。 总结： Angular 是一个大而全的框架，我觉得很强大很牛逼，越来越喜欢 Angular 了 使用 CDN 可以大大的加速，尽量使用 CDN 微信这个坑比我就不说了，不支持 Symbol 不支持 http2 能用 http2 就尽量用 http2 考虑浏览器兼容性，根据需要引入 babel-polyfill","categories":[{"name":"Angular","slug":"Angular","permalink":"https://ruiming.github.io/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"https://ruiming.github.io/tags/Angular/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/tags/JavaScript/"}]},{"title":"浅谈 JavaScript 模块定义规范","slug":"浅谈JavaScript模块定义规范","date":"2016-08-06T14:28:35.000Z","updated":"2016-08-06T14:31:33.000Z","comments":true,"path":"2016/08/06/浅谈JavaScript模块定义规范/","link":"","permalink":"https://ruiming.github.io/2016/08/06/浅谈JavaScript模块定义规范/","excerpt":"JS 模块定义常见的有三种方式，即 AMD, CMD 和 CommonJS。其实还有一个 UMD，他是 CommonJS 和 AMD 揉和在一起而已。不过这些都 out 了，拥抱 ES6 吧。话虽这么说，你让那些不用 ES6 不用 babel 的怎么活，所以还是要了解下滴。 CommonJSCommonJS 是服务端即 Node.js 采用的模块化方案，我们应该都很熟悉了。例如：12const fs = require('fs');fs.readFileSync(); 这个过程是同步的，只有成功加载 fs 后才能执行后面的步骤。但在服务器文件都在本地，所以这个问题不大。但这个在浏览器就不合适了，如果文件加载耗时很长，将导致一直等待。 AMDAMD 全称 Asynchronous Module Definition，意思就是异步模块定义。用法如下：123require(['math'], function(math) &#123; math.add(1, 2);&#125;); math 模块的加载和 math.add() 方法的执行不是同步的，这样浏览器就不会假死。RequireJs 和 CurlJs 实现了 AMD 规范，将他们嵌入网页，就可以在浏览器端进行模块化编程了。关于 AMD 的详细模块定义可以参考wiki)。这里给出 Underscore 的 AMD 定义方法：12345if (typeof define == 'function' &amp;&amp; define.amd) &#123; define('underscore', [], function() &#123; return _; &#125;);&#125; CMDCMD 全称 Common Module Definition，意思就是通用模块定义。。对于依赖的模块，AMD 是提前执行，而 CMD 是延迟执行。AMD 推崇依赖前置，而 CMD 则推崇依赖就近。例如：1234define(function(require, exports, module) &#123; const math = require('./math'); math.add(1, 2);&#125;); CMD 的主要实现是 SeaJSAMD 预先加载所有依赖，使用的时候才去执行，速度快，可以并行加载多个模块。但这就需要开发的时候把全部依赖都提前定义，不便于开发和阅读，而且部分依赖（弱依赖）可能只在少数情况下使用。CMD 只有在真正需要的时候才去加载依赖，使用的时候才去定义执行，但这个加载逻辑偏重，耗性能。 UMDUMD 全称 Universal Module Definition。UMD 是 AMD 和 CommonJS 的揉和，他优先使用 CommonJS 的加载方式，其次才使用 AMD 的加载方式。例如：1234567891011121314(function (window, factory) &#123; if (typeof exports === 'object') &#123; module.exports = factory(); &#125; else if (typeof define === 'function' &amp;&amp; define.amd) &#123; define(factory); &#125; else &#123; window.eventUtil = factory(); &#125;&#125;)(this, function () &#123; //module ...&#125;); 其实就是一个服务端和浏览端通用的模块解决方案。 ES6 ModuleES6 在语言规格的层面上实现了模块功能，并且实现非常简单，完全可以替代现有的模块加载方案，成为浏览器和服务端都通用的模块解决方案。","text":"JS 模块定义常见的有三种方式，即 AMD, CMD 和 CommonJS。其实还有一个 UMD，他是 CommonJS 和 AMD 揉和在一起而已。不过这些都 out 了，拥抱 ES6 吧。话虽这么说，你让那些不用 ES6 不用 babel 的怎么活，所以还是要了解下滴。 CommonJSCommonJS 是服务端即 Node.js 采用的模块化方案，我们应该都很熟悉了。例如：12const fs = require('fs');fs.readFileSync(); 这个过程是同步的，只有成功加载 fs 后才能执行后面的步骤。但在服务器文件都在本地，所以这个问题不大。但这个在浏览器就不合适了，如果文件加载耗时很长，将导致一直等待。 AMDAMD 全称 Asynchronous Module Definition，意思就是异步模块定义。用法如下：123require(['math'], function(math) &#123; math.add(1, 2);&#125;); math 模块的加载和 math.add() 方法的执行不是同步的，这样浏览器就不会假死。RequireJs 和 CurlJs 实现了 AMD 规范，将他们嵌入网页，就可以在浏览器端进行模块化编程了。关于 AMD 的详细模块定义可以参考wiki)。这里给出 Underscore 的 AMD 定义方法：12345if (typeof define == 'function' &amp;&amp; define.amd) &#123; define('underscore', [], function() &#123; return _; &#125;);&#125; CMDCMD 全称 Common Module Definition，意思就是通用模块定义。。对于依赖的模块，AMD 是提前执行，而 CMD 是延迟执行。AMD 推崇依赖前置，而 CMD 则推崇依赖就近。例如：1234define(function(require, exports, module) &#123; const math = require('./math'); math.add(1, 2);&#125;); CMD 的主要实现是 SeaJSAMD 预先加载所有依赖，使用的时候才去执行，速度快，可以并行加载多个模块。但这就需要开发的时候把全部依赖都提前定义，不便于开发和阅读，而且部分依赖（弱依赖）可能只在少数情况下使用。CMD 只有在真正需要的时候才去加载依赖，使用的时候才去定义执行，但这个加载逻辑偏重，耗性能。 UMDUMD 全称 Universal Module Definition。UMD 是 AMD 和 CommonJS 的揉和，他优先使用 CommonJS 的加载方式，其次才使用 AMD 的加载方式。例如：1234567891011121314(function (window, factory) &#123; if (typeof exports === 'object') &#123; module.exports = factory(); &#125; else if (typeof define === 'function' &amp;&amp; define.amd) &#123; define(factory); &#125; else &#123; window.eventUtil = factory(); &#125;&#125;)(this, function () &#123; //module ...&#125;); 其实就是一个服务端和浏览端通用的模块解决方案。 ES6 ModuleES6 在语言规格的层面上实现了模块功能，并且实现非常简单，完全可以替代现有的模块加载方案，成为浏览器和服务端都通用的模块解决方案。1import &#123;stat, exists, readFile&#125; from 'fs'; 这种做法将只在 fs 模块加载3个方法，其他方法不会进行加载。ES6 可以在编译时就完成模块加载，效率比 CommonJS 的加载方式高。在浏览器中使用 ES6 模块的语法：1&lt;script type=\"module\" src=\"foo.js\"&gt;&lt;/script&gt; 目前 Node 默认模块格式是 CommonJS，ES6 的模块方案还不支持，但可以通过 babel 来使用。 现在推荐做法是广泛使用 ES6 甚至 ES7 来书写 JavaScript 以提高开发效率，再使用 babel 转码就好了。所以前后端我们也都可以使用 ES6 的 Module 来进行。其他的模块加载方案应该会渐渐退出历史舞台。 ECMAScript6 入门 Module","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/tags/JavaScript/"}]},{"title":"Underscore 源码学习(七)","slug":"Underscore源码学习(七)","date":"2016-08-06T07:53:18.000Z","updated":"2016-08-06T13:03:57.000Z","comments":true,"path":"2016/08/06/Underscore源码学习(七)/","link":"","permalink":"https://ruiming.github.io/2016/08/06/Underscore源码学习(七)/","excerpt":"Underscore 中间 flatten 相关的方法之前一直不是很理解，现在完全搞懂了，稍微说一下。12345678910111213141516171819202122232425var flatten = function(input, shallow, strict, output) &#123; output = output || []; var idx = output.length; for (var i = 0, length = getLength(input); i &lt; length; i++) &#123; var value = input[i]; // 若value为数组，把里面东西去出来赋值给output // 否则直接赋值给output // isArrayLike的判断可以去掉，保留的原因是因为他用来判断value是否为数组很快，可以迅速筛选掉非数组 if (isArrayLike(value) &amp;&amp; (_.isArray(value) || _.isArguments(value))) &#123; // Flatten current level of array or arguments object. if (shallow) &#123; // 如果给了shallow参数，只只遍历一层 var j = 0, len = value.length; while (j &lt; len) output[idx++] = value[j++]; &#125; else &#123; // 一直遍历下去，如果是元素则按下面赋值，如果是数组则继续遍历 flatten(value, shallow, strict, output); idx = output.length; &#125; &#125; else if (!strict) &#123; output[idx++] = value; &#125; &#125; return output;&#125;; 这个方法不难看懂，作用是将input平铺展开，如果 shallow 为 true，则只展开一层。12_.flatten([1, 2, [3], [[4, [5]]]]) // [1, 2, 3, 4, 5]_.flatten([1, 2, [3], [[4, [5]]]], true) // [1, 2, 3, [4, [5]]] 这里的 strict 参数就是之前一直卡住的原因，就是下面这个地方：1234567891011_.without = restArgs(function(array, otherArrays) &#123; return _.difference(array, otherArrays);&#125;);_.difference = restArgs(function(array, rest) &#123; rest = flatten(rest, true, true); // 遍历array，如果array中一个元素包含在rest中，则去掉该元素 return _.filter(array, function(value)&#123; return !_.contains(rest, value); &#125;);&#125;); 这是两个方法，那时候想 without 方法调用的时候, otherArrays是一个数组了，到 difference 方法的时候，这个数组去调用 flatten 方法的时候不是会出问题吗？1_.flatten([1, 2, 3], true, true) // [] 脑子里面就这样想…卡了好久，等我基本看了全部源码才会过来看才理解了。difference 方法的 restArgs 很重要，他们两个是各自独立的方法，但是 without 可以共用 difference 的逻辑。上面那样子理解是有问题的，因为在 without 方法中 otherArrays 如果是[1, 2, 3]，到了 flatten 调用的时候因为 restArgs 的关系他变成了 [[1, 2, 3]]，调用最后返回结果[1, 2, 3]。然后我就纳闷了，加了一层又解除这是何解…不过抛开 without 方法去看 difference 方法就能理解了。","text":"Underscore 中间 flatten 相关的方法之前一直不是很理解，现在完全搞懂了，稍微说一下。12345678910111213141516171819202122232425var flatten = function(input, shallow, strict, output) &#123; output = output || []; var idx = output.length; for (var i = 0, length = getLength(input); i &lt; length; i++) &#123; var value = input[i]; // 若value为数组，把里面东西去出来赋值给output // 否则直接赋值给output // isArrayLike的判断可以去掉，保留的原因是因为他用来判断value是否为数组很快，可以迅速筛选掉非数组 if (isArrayLike(value) &amp;&amp; (_.isArray(value) || _.isArguments(value))) &#123; // Flatten current level of array or arguments object. if (shallow) &#123; // 如果给了shallow参数，只只遍历一层 var j = 0, len = value.length; while (j &lt; len) output[idx++] = value[j++]; &#125; else &#123; // 一直遍历下去，如果是元素则按下面赋值，如果是数组则继续遍历 flatten(value, shallow, strict, output); idx = output.length; &#125; &#125; else if (!strict) &#123; output[idx++] = value; &#125; &#125; return output;&#125;; 这个方法不难看懂，作用是将input平铺展开，如果 shallow 为 true，则只展开一层。12_.flatten([1, 2, [3], [[4, [5]]]]) // [1, 2, 3, 4, 5]_.flatten([1, 2, [3], [[4, [5]]]], true) // [1, 2, 3, [4, [5]]] 这里的 strict 参数就是之前一直卡住的原因，就是下面这个地方：1234567891011_.without = restArgs(function(array, otherArrays) &#123; return _.difference(array, otherArrays);&#125;);_.difference = restArgs(function(array, rest) &#123; rest = flatten(rest, true, true); // 遍历array，如果array中一个元素包含在rest中，则去掉该元素 return _.filter(array, function(value)&#123; return !_.contains(rest, value); &#125;);&#125;); 这是两个方法，那时候想 without 方法调用的时候, otherArrays是一个数组了，到 difference 方法的时候，这个数组去调用 flatten 方法的时候不是会出问题吗？1_.flatten([1, 2, 3], true, true) // [] 脑子里面就这样想…卡了好久，等我基本看了全部源码才会过来看才理解了。difference 方法的 restArgs 很重要，他们两个是各自独立的方法，但是 without 可以共用 difference 的逻辑。上面那样子理解是有问题的，因为在 without 方法中 otherArrays 如果是[1, 2, 3]，到了 flatten 调用的时候因为 restArgs 的关系他变成了 [[1, 2, 3]]，调用最后返回结果[1, 2, 3]。然后我就纳闷了，加了一层又解除这是何解…不过抛开 without 方法去看 difference 方法就能理解了。12345678_.without([1, 2, 3, 4, 5, 6], 1, 2, 3);// 1, 2, 3通过restArgs变为[1, 2, 3]，传入difference方法// [1, 2, 3]通过restArgs变为[[1, 2, 3]]，传入flatten方法// 返回[1, 2, 3]，剩下的可以看懂了不解释// 之所以shallow和strict都为true，是因为不需要两个数组即使内容一样他们也是不想等的，// 不需要进行处理，所以没必要展开_.difference([1, 2, 3, 4, 5, 6], [1, 2], [3]);// [1, 2], [3]通过restArgs变为[1, 2, 3]，传入difference方法，其余同 所以其实 difference 方法的 restArgs 虽然对与 without 方法中的调用是多余的，但是作为一个独立的方法，他还是有必要的。上面注释应该说的很清楚了，完。 其实只是我自己没看清楚而已，也不难。这个地方的很多方法比如 union, intersection等等都是集合的相关操作。比如 difference 就是差集，union 就是并集，而intersection 就是交集。","categories":[{"name":"Underscore","slug":"Underscore","permalink":"https://ruiming.github.io/categories/Underscore/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/tags/JavaScript/"},{"name":"Underscore","slug":"Underscore","permalink":"https://ruiming.github.io/tags/Underscore/"}]},{"title":"Underscore 源码学习(六)","slug":"Underscore源码学习(六)","date":"2016-08-05T05:59:06.000Z","updated":"2016-08-05T06:07:51.000Z","comments":true,"path":"2016/08/05/Underscore源码学习(六)/","link":"","permalink":"https://ruiming.github.io/2016/08/05/Underscore源码学习(六)/","excerpt":"关于 Underscore 的 mixin 方法。首先先看个例子：12345678910function Panel() &#123; consoe.log(this, this instanceof Panel); if(this instanceof Panel) &#123; return this; &#125; else &#123; return new Panel(); &#125;&#125;a = Panel(); // Window falseb = new Panel(); // Panel&#123;&#125; true 当函数作为构造器使用时，函数内的 this 执行被新建的对象。当函数被调用时，函数内的 this 则为被调用的对象，在这里是 Window。12345var _ = function(obj) &#123; if (obj instanceof _) return obj; if (!(this instanceof _)) return new _(obj); this._wrapped = obj;&#125;; 同样的，如果我们使用下面方法调用：1var under = _(); 第二个条件成立，所以新建一个 _ 对象后返回，注意这里是再次调用这个函数。如果我们这样调用：1var under = new _(); 就好像上面第二次调用一样，这时候就构造了 under 这个对象，如果传入了参数 obj，则把 obj 存入 under 这个对象的 _wrapped 属性中。Underscore 提供了一个 OO 的调用方法，即:1234567891011121314151617181920212223var chainResult = function(instance, obj) &#123; return instance._chain ? _(obj).chain() : obj;&#125;;_.mixin = function(obj) &#123; // 遍历obj中的函数 _.each(_.functions(obj), function(name) &#123; // 避免原型链查找，提升性能 var func = _[name] = obj[name]; _.prototype[name] = function() &#123; // 把wrapped作为数组第一个参数(context)，其余传参push到这个数组中 var args = [this._wrapped]; push.apply(args, arguments); // 如果this是一个_实例，则使用func调用的结果来新建_实例后返回以供继续链式调用 // 如果this不是一个_实例，则直接返回func调用的结果 return chainResult(this, func.apply(_, args)); &#125;; &#125;); return _;&#125;;// 把Underscore对象mixin化，这样就可以直接在_上调用方法_.mixin(_); 当然我们还可以把自己写的方法通过 mixin 加入到 Underscore 对象中。","text":"关于 Underscore 的 mixin 方法。首先先看个例子：12345678910function Panel() &#123; consoe.log(this, this instanceof Panel); if(this instanceof Panel) &#123; return this; &#125; else &#123; return new Panel(); &#125;&#125;a = Panel(); // Window falseb = new Panel(); // Panel&#123;&#125; true 当函数作为构造器使用时，函数内的 this 执行被新建的对象。当函数被调用时，函数内的 this 则为被调用的对象，在这里是 Window。12345var _ = function(obj) &#123; if (obj instanceof _) return obj; if (!(this instanceof _)) return new _(obj); this._wrapped = obj;&#125;; 同样的，如果我们使用下面方法调用：1var under = _(); 第二个条件成立，所以新建一个 _ 对象后返回，注意这里是再次调用这个函数。如果我们这样调用：1var under = new _(); 就好像上面第二次调用一样，这时候就构造了 under 这个对象，如果传入了参数 obj，则把 obj 存入 under 这个对象的 _wrapped 属性中。Underscore 提供了一个 OO 的调用方法，即:1234567891011121314151617181920212223var chainResult = function(instance, obj) &#123; return instance._chain ? _(obj).chain() : obj;&#125;;_.mixin = function(obj) &#123; // 遍历obj中的函数 _.each(_.functions(obj), function(name) &#123; // 避免原型链查找，提升性能 var func = _[name] = obj[name]; _.prototype[name] = function() &#123; // 把wrapped作为数组第一个参数(context)，其余传参push到这个数组中 var args = [this._wrapped]; push.apply(args, arguments); // 如果this是一个_实例，则使用func调用的结果来新建_实例后返回以供继续链式调用 // 如果this不是一个_实例，则直接返回func调用的结果 return chainResult(this, func.apply(_, args)); &#125;; &#125;); return _;&#125;;// 把Underscore对象mixin化，这样就可以直接在_上调用方法_.mixin(_); 当然我们还可以把自己写的方法通过 mixin 加入到 Underscore 对象中。在这段代码后面还把原生的一些操作方法也添加到这个 _ 上面，这样我们就可以直接在 _ 上调用这些方法。例如：12345678910// Add all mutator Array functions to the wrapper._.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) &#123; var method = ArrayProto[name]; _.prototype[name] = function() &#123; var obj = this._wrapped; method.apply(obj, arguments); if ((name === 'shift' || name === 'splice') &amp;&amp; obj.length === 0) delete obj[0]; return chainResult(this, obj); &#125;;&#125;); 上面这些方法并不是 Underscore 新建的，不存在于 Underscore 对象的原型链上，所以我们要把他们加进去。和上面 mixin 方法类似，下面这段代码是为了兼容 IE 而采取的操作：1if ((name === 'shift' || name === 'splice') &amp;&amp; obj.length === 0) delete obj[0]; jdalton commented on 6 Dec 2011IE bugs with splice() and shift(), failing to remove the 0 indexed value, when using an array-like-object with _(…).IE compatibility mode and IE &lt; 9 have buggy Array shift() and splice() functions that fail to remove the last element, object[0], of array-like-objects even though the length property is set to 0. 通过上面这些方法把 Underscore 转化为可面向对象编程，调用更加优雅，我们可以有以下两种使用方法：12_.map([1, 2, 3], function(n)&#123; return n * 2; &#125;);_([1, 2, 3]).map(function(n)&#123; return n * 2; &#125;); 至于选择哪一种就看你的喜好了～","categories":[{"name":"Underscore","slug":"Underscore","permalink":"https://ruiming.github.io/categories/Underscore/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/tags/JavaScript/"},{"name":"Underscore","slug":"Underscore","permalink":"https://ruiming.github.io/tags/Underscore/"}]},{"title":"Underscore 源码学习(五)","slug":"Underscore源码学习(五)","date":"2016-08-04T07:18:48.000Z","updated":"2016-08-04T11:41:34.000Z","comments":true,"path":"2016/08/04/Underscore源码学习(五)/","link":"","permalink":"https://ruiming.github.io/2016/08/04/Underscore源码学习(五)/","excerpt":"Underscore 的函数大部分还是挺好理解的，感觉过一遍就行了，不过今天看到两个函数感觉还是挺有意思的，并且也挺常用。这两个函数就是 throttle 和 debounce。 throttle1234567891011121314151617181920212223242526272829303132333435363738394041424344454647_.throttle = function(func, wait, options) &#123; var timeout, context, args, result; var previous = 0; if (!options) options = &#123;&#125;; var later = function() &#123; // 更改previous即上一次执行时间为当前时间 previous = options.leading === false ? 0 : _.now(); timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; &#125;; var throttled = function() &#123; var now = _.now(); // 如果leading为false时禁用第一次首先执行，previous等于now（效果同已经执行过一次，所以第一次被禁用） // 这个if语句只在第一次执行该函数的时候有效 if (!previous &amp;&amp; options.leading === false) previous = now; var remaining = wait - (now - previous); context = this; args = arguments; // 超时处理和未到时的处理 if (remaining &lt;= 0 || remaining &gt; wait) &#123; // timeout不为null时清除掉并设置为null if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; // 立即调用 result = func.apply(context, args); if (!timeout) context = args = null; &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; // 如果没有禁用最后一次执行 timeout = setTimeout(later, remaining); // remaining毫秒后执行later &#125; // 返回调用的结果 return result; &#125;; throttled.cancel = function() &#123; clearTimeout(timeout); previous = 0; timeout = context = args = null; &#125;; return throttled;&#125;; 其实一步步去理解也不难，就不细说这个方法了。这个方法有可选项设置，分别为 {leading: false} 和 {trailing: false}。 所以一般有四类情况： 默认情况第一次调用时立即响应，之后每个周期内最多执行一次，周期内触发会产生定时执行使在上一次执行时间 preview 周期时间后再次执行。 设置 leading 为 false同默认情况区别在于第一次调用不会立即执行而是等待周期时间后再次执行，如果在周期时间内触发，一样等待上一次执行时间 preview 周期时间后再执行。 设置 trailing 为 false最后周期内最多执行一次，但在周期时间内调用不会触发 timeout，只能在上一次 timeout 失效后调用才能生效并且此时调用将立即执行。 设置 leading 和 trailing 为 false如果同时还设置 leading 为 false 的话，那么第一次调用不会立即执行而是等待周期时间后才执行，在这段时间内调用都不会有效果。","text":"Underscore 的函数大部分还是挺好理解的，感觉过一遍就行了，不过今天看到两个函数感觉还是挺有意思的，并且也挺常用。这两个函数就是 throttle 和 debounce。 throttle1234567891011121314151617181920212223242526272829303132333435363738394041424344454647_.throttle = function(func, wait, options) &#123; var timeout, context, args, result; var previous = 0; if (!options) options = &#123;&#125;; var later = function() &#123; // 更改previous即上一次执行时间为当前时间 previous = options.leading === false ? 0 : _.now(); timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; &#125;; var throttled = function() &#123; var now = _.now(); // 如果leading为false时禁用第一次首先执行，previous等于now（效果同已经执行过一次，所以第一次被禁用） // 这个if语句只在第一次执行该函数的时候有效 if (!previous &amp;&amp; options.leading === false) previous = now; var remaining = wait - (now - previous); context = this; args = arguments; // 超时处理和未到时的处理 if (remaining &lt;= 0 || remaining &gt; wait) &#123; // timeout不为null时清除掉并设置为null if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; // 立即调用 result = func.apply(context, args); if (!timeout) context = args = null; &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; // 如果没有禁用最后一次执行 timeout = setTimeout(later, remaining); // remaining毫秒后执行later &#125; // 返回调用的结果 return result; &#125;; throttled.cancel = function() &#123; clearTimeout(timeout); previous = 0; timeout = context = args = null; &#125;; return throttled;&#125;; 其实一步步去理解也不难，就不细说这个方法了。这个方法有可选项设置，分别为 {leading: false} 和 {trailing: false}。 所以一般有四类情况： 默认情况第一次调用时立即响应，之后每个周期内最多执行一次，周期内触发会产生定时执行使在上一次执行时间 preview 周期时间后再次执行。 设置 leading 为 false同默认情况区别在于第一次调用不会立即执行而是等待周期时间后再次执行，如果在周期时间内触发，一样等待上一次执行时间 preview 周期时间后再执行。 设置 trailing 为 false最后周期内最多执行一次，但在周期时间内调用不会触发 timeout，只能在上一次 timeout 失效后调用才能生效并且此时调用将立即执行。 设置 leading 和 trailing 为 false如果同时还设置 leading 为 false 的话，那么第一次调用不会立即执行而是等待周期时间后才执行，在这段时间内调用都不会有效果。 比如12var func = _.throttle(updatePosition, 100);$(window).scroll(func); 由于 scroll 过程时, func 函数的调用是很密集的，我们不能每次调用都去执行，可以通过设置 throttle 来达到节流阀的作用。leading 和 trailing 只是实现上细微的不同而已。 throll 主要应用在鼠标移动，mousemove 事件，DOM 元素动态定位，window 对象的 resize 和 scroll 等事件。这些事件触发频率高，但又要尽可能进行响应。 debounce12345678910111213141516171819202122232425262728293031323334_.debounce = function(func, wait, immediate) &#123; var timeout, result; var later = function(context, args) &#123; timeout = null; if (args) result = func.apply(context, args); &#125;; var debounced = restArgs(function(args) &#123; // 再次调用且上次还未执行，则清除上次的timeout // 只是timeout事件不再执行，但timeout依旧存在 if (timeout) clearTimeout(timeout); // 如果immediate为true if (immediate) &#123; // 如果timeout为null，则立即调用函数 // 如果timeout不为null，则callNow为false，函数不执行 var callNow = !timeout; timeout = setTimeout(later, wait); if (callNow) result = func.apply(this, args); &#125; else &#123; // 延迟later执行，如果这个还没到时间再来一次，则新的会覆盖上一次的 timeout = _.delay(later, wait, this, args); &#125; return result; &#125;); debounced.cancel = function() &#123; clearTimeout(timeout); timeout = null; &#125;; return debounced;&#125;; 这个函数就要比上面那个好理解一点，说明下这个函数： 如果 immediate 为 true，周期 100ms 0 =&gt; 立即执行，设置 timeout 50 =&gt; 重新设置 timeout，不执行 100 =&gt; 重新设置 timeout，不执行 200 =&gt; timeout 到时，执行函数 如果 immediate 为 false, 周期 100ms 0 =&gt; 设置 timeout，不执行 100 =&gt; timeout 到时，执行函数 120 =&gt; 设置 timeout，不执行 180 =&gt; 重新设置 timeout，不执行 280 =&gt; timeout 到时，执行函数 其实 timeout 就变成一个控制两次事件触发间隔用的，并且和上面的 throttle 不同，timeout 会被重新设置。 debounce 主要应用在文本输入 keydown 事件，keyup 事件，例如做 autocomplete。 结合两个的应用细细体味下他们差别。如果想自己体验下差别，传送门。","categories":[{"name":"Underscore","slug":"Underscore","permalink":"https://ruiming.github.io/categories/Underscore/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/tags/JavaScript/"},{"name":"Underscore","slug":"Underscore","permalink":"https://ruiming.github.io/tags/Underscore/"}]},{"title":"谈谈 React 和 Redux","slug":"谈谈React和Redux","date":"2016-08-01T07:53:32.000Z","updated":"2016-08-04T08:33:16.000Z","comments":true,"path":"2016/08/01/谈谈React和Redux/","link":"","permalink":"https://ruiming.github.io/2016/08/01/谈谈React和Redux/","excerpt":"刚回到家的时候学习了 React 和 Redux，现在才想来总结一下，不知道会不会忘的差不多了…本来是想写一个问卷发布系统的，使用 React 和 Redux 已经完成了基础的几个功能，但是那个代码量…用 Angular 写简直轻轻松松的好吧…然后就去重构项目还有现在学的 Underscore 去了。是时候重新回顾下了。此处主要讲的是 Redux 。 关于 Redux redux 是facebook 提出的 flux 架构的一种优秀实现；而且不局限于为 react 提供数据状态处理。它是零依赖的，可以配合其他任何框架或者类库一起使用。要想配合 react，还得引入 react-redux。 关于 Flux那什么是 Flux 呢？见下图Flux 可以分为四个部分： View: 视图层 Action: 视图层触发的动作 Dispatcher: 派发器，用来接受 Actions, 执行回调函数 Store：数据层，用来存放应用的状态，其变更会触发 View 层更新 Flux 的最大特点就是单向流动，他的过程大概如下： 用户访问 View ，触发了动作 Action Dispatcher 收到 Action ，根据 Action 类别进行相应的处理，处理结束后要求 Store 更新 Store 进行更新，通知 View 层刷新 View 层收到通知更新页面 额，其实我没有用 Flux，不敢讲太多了，简单的说就是一种单项数据流动的解决方案吧。我是直接学 Redux，对 Flux 也就大概了解这么多了。 Redux 和 FluxRedux 是 Flux 的一种实现，但他们又有所不同，在 Flux 中，Store 可以有多个，但 Redux 有且只能有一个 Store，Flux 中存在 Dispatcher，在 Redux 则没有这个，而是用 reducer 代替了。不多说了，直接往下说 Redux 吧，我快扯不下去 Flux 了=.= 理解ReduxRedux 由四部分组成： Action Reducer Store Views 我们结合具体的应用场景来看 Action先从 Action 说起，一个 Action 是一个普通的对象。123456789101112131415161718192021export const SET_PAPER_TITLE = 'SET_PAPER_TITLE';export const ADD_QUESTION = 'ADD_QUESTION';export const REMOVE_QUESTION = 'REMOVE_QUESTION';export function setPaperTitle(newTitle) &#123; return &#123; type: SET_PAPER_TITLE, value: newTitle &#125;&#125;export function addQuestion(type) &#123; return &#123; type: ADD_QUESTION, questionType: type &#125;&#125;export function removeQuestion(questionId) &#123; return &#123; type: REMOVE_QUESTION, questionId: questionId &#125;&#125; type 属性是必须的，表示动作类别，其他的参数可以自定。我们先不用管 Action 有什么用，后面会提到。","text":"刚回到家的时候学习了 React 和 Redux，现在才想来总结一下，不知道会不会忘的差不多了…本来是想写一个问卷发布系统的，使用 React 和 Redux 已经完成了基础的几个功能，但是那个代码量…用 Angular 写简直轻轻松松的好吧…然后就去重构项目还有现在学的 Underscore 去了。是时候重新回顾下了。此处主要讲的是 Redux 。 关于 Redux redux 是facebook 提出的 flux 架构的一种优秀实现；而且不局限于为 react 提供数据状态处理。它是零依赖的，可以配合其他任何框架或者类库一起使用。要想配合 react，还得引入 react-redux。 关于 Flux那什么是 Flux 呢？见下图Flux 可以分为四个部分： View: 视图层 Action: 视图层触发的动作 Dispatcher: 派发器，用来接受 Actions, 执行回调函数 Store：数据层，用来存放应用的状态，其变更会触发 View 层更新 Flux 的最大特点就是单向流动，他的过程大概如下： 用户访问 View ，触发了动作 Action Dispatcher 收到 Action ，根据 Action 类别进行相应的处理，处理结束后要求 Store 更新 Store 进行更新，通知 View 层刷新 View 层收到通知更新页面 额，其实我没有用 Flux，不敢讲太多了，简单的说就是一种单项数据流动的解决方案吧。我是直接学 Redux，对 Flux 也就大概了解这么多了。 Redux 和 FluxRedux 是 Flux 的一种实现，但他们又有所不同，在 Flux 中，Store 可以有多个，但 Redux 有且只能有一个 Store，Flux 中存在 Dispatcher，在 Redux 则没有这个，而是用 reducer 代替了。不多说了，直接往下说 Redux 吧，我快扯不下去 Flux 了=.= 理解ReduxRedux 由四部分组成： Action Reducer Store Views 我们结合具体的应用场景来看 Action先从 Action 说起，一个 Action 是一个普通的对象。123456789101112131415161718192021export const SET_PAPER_TITLE = 'SET_PAPER_TITLE';export const ADD_QUESTION = 'ADD_QUESTION';export const REMOVE_QUESTION = 'REMOVE_QUESTION';export function setPaperTitle(newTitle) &#123; return &#123; type: SET_PAPER_TITLE, value: newTitle &#125;&#125;export function addQuestion(type) &#123; return &#123; type: ADD_QUESTION, questionType: type &#125;&#125;export function removeQuestion(questionId) &#123; return &#123; type: REMOVE_QUESTION, questionId: questionId &#125;&#125; type 属性是必须的，表示动作类别，其他的参数可以自定。我们先不用管 Action 有什么用，后面会提到。 Reducer在 Action 这一层中，可以筛选掉脏数据，多余的参数不会传入，真正处理数据是在 Reducer 中。12345678910111213141516171819202122232425262728293031323334353637383940414243444546import &#123; SET_PAPER_TITLE, ADD_QUESTION, REMOVE_QUESTION, ADD_OPTION, REMOVE_OPTION, SET_QUESTION_TITLE, SET_OPTION_TITLE &#125; from '../action/action'import &#123; combineReducers &#125; from 'redux'function paperReducer(state=[], action) &#123; switch(action.type) &#123; case SET_PAPER_TITLE: return Object.assign(&#123;&#125;, state, &#123; title: action.value &#125;); default: return state; &#125;&#125;function questionsReducer(state=[], action) &#123; switch(action.type) &#123; case ADD_QUESTION: return [ ...state, &#123; title: '', type: action.questionType, content: ['','','',''] &#125; ]; case REMOVE_QUESTION: return [ ...state.slice(0, action.questionId), ...state.slice(action.questionId+1) ]; case ADD_OPTION: case REMOVE_OPTION: case SET_QUESTION_TITLE: case SET_OPTION_TITLE: return [ ...state.slice(0, action.questionId), questionReducer(state[action.questionId], action), ...state.slice(action.questionId+1) ]; default: return state; &#125;&#125;var paperApp = combineReducers(&#123; paper: paperReducer, questions: questionsReducer&#125;);export default paperApp; 这里列了很多 Action，但在上面的 Action 部分我只提了两个，其他的其实都一样的，就是参数可能有些区别而已。这里就要好好说一笔了，reducer 之所以叫 reducer，一个原因就是他很类似 JavaScript 中数组的 reduce 方法，接收两个参数，一个是当前状态，一个是处理方法。但在 Redux 中，不要直接修改当前状态即 state，而应该返回一个新的 state，而这样做的其中一个好处就是可以实现时间旅行的功能，即可以回溯到任意版本的数据，并且对于判断 state 是否发生修改也很重要，如果是在原引用上修改我们得用 deepEqual 深度遍历来对比值，而如果返回了一个新的对象则可以直接使用 === 来判断两个数据是否一致，不一致则触发更改。reducer 方法应该都能看懂，接下来是 combineReducers 这个。我上面其实涉及到三个 reducer 了，分别是 paperReducer questionsReducer questionReducer 但为了减少空间，我没有把 questionReducer 写出来。其实注意看从29行到32行的四个 Action，我都传入 state 中的部分数据给了 questionReducer 去做处理。因为这些都是涉及一个问题的修改的，所以就单独列出来。这样就不致于一个 reducer 写太多东西。实质上还是两个 reducer 而已，这里的 combineReducers 就是把这两个 reducer 合并在一起。这两个 reducer 一个是处理问卷信息如问卷标题，一个是处理问卷的问题比如新建删除问题，问题修改这些。 Store使用 combineReducers 就要求我们 Store 的设计合理，因为 Store 和 reducer 是要对应的，questionsReducer 只要处理问题，而 paperReducer 只要处理问卷本身，所以也就不需要往 paperReducer 传入完整的 state 信息。我们看下 Store。12345678910111213141516171819202122232425262728293031import React from 'react'import &#123; createStore &#125; from 'redux'import &#123; render &#125; from 'react-dom'import &#123; Provider &#125; from 'react-redux'import paperApp from './reducer/reducer'import App from './containers/App'const initialState = &#123; paper: &#123; title: 'asd', time: \"2016-7-19\", author: \"Ruiming\", &#125;, questions: [&#123; title: '', type: 'radio', content: ['', '', '', ''] &#125;, &#123; title: '', type: 'checkbox', content: ['','','',''] &#125;]&#125;;let store = createStore(paperApp, initialState);let rootElement = document.getElementById('index');render ( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, rootElement); 我们初始一个数据 initialState，调用 createStore 方法需要传入两个参数，分别就是我们上面 combineReducers 后的paperApp和我们的数据。在初始数据中，有两个对象分别是paper和questions，这就刚好和 combineReducers 中的paper和questions对应，从而实现传递部分state。下面的 render 部分是就是渲染部分了， Provider 是 react-redux 提供的一个容器，将 Store 作为属性传递给该容器。 Views我们看下 App 的内容1234567891011121314151617181920212223242526272829303132333435363738import React, &#123; Component, PropTypes &#125; from 'react'import &#123; connect &#125; from 'react-redux'import &#123; addQuestion, addOption, setPaperTitle, setQuestionTitle, setOptionTitle, removeQuestion, removeOption &#125; from '../action/action'import Header from '../components/Header'import NewQuestionBar from '../components/NewQuestionBar'import OptionsBar from '../components/OptionsBar'class App extends Component &#123; render() &#123; const &#123; dispatch, title, questions &#125; = this.props; return &lt;div ref=\"paper\"&gt; &lt;Header title=&#123;title&#125; setPaperTitle=&#123;(title) =&gt; dispatch(setPaperTitle(title))&#125; /&gt; &lt;NewQuestionBar addQuestion=&#123;(type) =&gt; dispatch(addQuestion(type))&#125; /&gt; &lt;section className=\"paper\"&gt; &lt;ul className=\"paper-list\"&gt; &#123;questions.map(function(question, i) &#123; return &lt;OptionsBar content=&#123;question.content&#125; addQuestion=&#123;() =&gt; dispatch(addQuestion())&#125; addOption=&#123;(questionId) =&gt; dispatch(addOption(questionId))&#125; /&gt; &#125;.bind(this)) &#125; &lt;/ul&gt; &lt;/section&gt; &lt;/div&gt; &#125;&#125;function select(state) &#123; return &#123; paper: state.paper, questions: state.questions &#125;&#125;export default connect(select)(App); 上面我去掉了很多部分，只保留了 addQuestion 和 addOption 这两个，我们看下这两个就好了。其实这部分的写法就是 React 写法而已，只是多了个 dispatch 方法。注意下最后的 connect 方法，他的作用是： 把所需要的 state 属性挂载到组件的 props 上。 为组件的 props 添加 dispatch 方法。 Redux 运行过程介绍完了 Redux 的四个部分，接下来就要说下这个运行的流程了。这才是理解 Redux 的关键。 用户在视图触发 dispatch 事件 Redux 响应用户操作生成 action action 传到 store 层，可以使用中间件进行一些处理 action 传 state 和 action 给 reducer 处理 reducer 返回一个新的 state store 读取 reducer 返回的内容，设置新的状态 大致就是以上过程，action 是唯一可以改变状态的途径，不仅包括用户的触发，也可以是来自服务器的推送，action 进行预处理后会传到 store，由 store 发送动作给 reducer，带上当前状态和当前动作，reducer 根据动作的 type 来进行不同的处理。注意 action 和 reducer 都是纯函数。 Redux 大致就是这么一回事，我们可以看到所有数据都来自一个对象 Store，这样就方便了调试测试，可以把 Store 就想象成一个数据库。state 只读，只能通过 action 改变，并且必须保证 reducer 是纯函数，所谓纯函数就是相同参数传入无数次他们都返回相同的东西，其实就是内部没有使用外部变量，外部变量总是伴随着不确定性。 React 和 AngularReact 现在很博人眼球，虚拟DOM提升了页面渲染性能，并且衍生的 React Native 也非常有诱惑力，单向数据流动虽然带来了清晰的逻辑和更高的性能，但降低了开发效率。另外，使用 React 开发的应用天然组件化，也方便了后期的维护。 Angular 是一个功能完善全面的框架，还自带了 $http, ngRoute, jQlite, $q, service 等等。提供了一整套的解决方案，估计这点很合大公司的胃口。并且 Angular 社区成熟活跃，生态完整，目前仍是最流行的前端框架，没有之一，非常适合用来写单页应用。数据双向绑定给开发带来了很大的便利，但双向绑定带来了性能损耗并且脏值检查性能也不好。 对比起来，我还是更喜欢 Angular，他的开发效率高，而且写起来很清晰，虽然他也有一些问题，但是在没有达到一个量级前这些问题是很难被体现出来的。而 React 可能在开发多端或者注重体积或者是在大型应用中可能才会去考虑吧。 另外 Angular2 也实现了虚拟 DOM，同样支持服务端渲染，使用 web worker 提升性能，TypeScript 提升了 JavaScript 项目的健壮性，而 Web Components 无疑是是未来趋势。我对 Angular2 同样满怀期待，我认为 Angular2 未来也会同 Angular1 一样火起来。 计划是再学习 react-router，写一个完整的 React 应用，后端使用 Koa 来开发。不过还是等手头上的东西处理完先吧。 除了 Angular1 和 Angular2 以及 React ，还有 Vue 和 Vue2 以及阿里的 Weex，前端的水深着呢！ 深入到源码：解读 redux 的设计思路与用法","categories":[{"name":"React","slug":"React","permalink":"https://ruiming.github.io/categories/React/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"https://ruiming.github.io/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"https://ruiming.github.io/tags/Redux/"}]},{"title":"Underscore 源码学习(四)","slug":"Underscore源码学习(四)","date":"2016-08-01T07:37:14.000Z","updated":"2016-08-04T08:33:06.000Z","comments":true,"path":"2016/08/01/Underscore源码学习(四)/","link":"","permalink":"https://ruiming.github.io/2016/08/01/Underscore源码学习(四)/","excerpt":"终于看完了 Underscore 的集合部分了，看 Underscore 源码真的是长见识了，感觉真的受益匪浅。但是集合里面方法也挺多的，我都不知道该拿哪些出来讲下，最近接触了 Redux，就说下 createRedux 这个方法吧，为后面讲 Redux 做个铺垫。先看源码123456789101112131415161718192021var createReduce = function(dir) &#123; var reducer = function(obj, iteratee, memo, initial) &#123; var keys = !isArrayLike(obj) &amp;&amp; _.keys(obj), length = (keys || obj).length, index = dir &gt; 0 ? 0 : length - 1; if(!initial) &#123; memo = obj[keys ? keys[index] : index]; index += dir; &#125; for(; index &gt;= 0 &amp;&amp; index &lt; length; index += dir) &#123; var currentKey = keys ? keys[index] : index; memo = iteratee(memo, obj[currentKey], currentKey, obj); &#125; return memo; &#125;; return function(obj, iteratee, memo, context) &#123; var initial = arguments.length &gt;= 3; return reducer(obj, opitimizeCb(iteratee, context, 4), memo, initial); &#125;;&#125;; 这是 reduce 函数的工厂函数，用于生成一个 reducer ，dir 是决定方向用的。我们从最后一个 return 开始看起，即1234return function(obj, iteratee, memo, context) &#123; var initial = arguments.length &gt;= 3; return reducer(obj, opitimizeCb(iteratee, context, 4), memo, initial);&#125;; 我们使用 reduce 的时候，如果没有指定 memo 值，这时候参数个数只有两个即 obj 和 iteratee，所以 initial 为 false 表示没有初始化。对于没初始的情况，就是增加了一个 if 语句里面的内容而已，作用是把第一个元素作为 memo 值。接着就是有没有初始化都共用的部分了，通过一个 for 循环把 keys 遍历，并把相应的信息交给 iteratee 去处理，参数 memo 是上一次处理结果。遍历完后把最后的处理结果 memo 返回就完了。这个函数派生了两个方法，即12_.reduce = _.foldl = _.inject = createReduce(1);_.reduceRight = _.foldr = createReduce(-1); 只是方向不同而已。举个例子方便理解些，例如：123var sum = _.reduce([1, 2, 3, 4, 5], function(accumulator, value, index, collection) &#123; return accmulator + value;&#125;, 0); 结果为 15 这个应该很明显，js 原生也有 reduce 方法，如下：123[1, 2, 3, 4, 5].reduce(function(left, right) &#123; return left + right;&#125;);","text":"终于看完了 Underscore 的集合部分了，看 Underscore 源码真的是长见识了，感觉真的受益匪浅。但是集合里面方法也挺多的，我都不知道该拿哪些出来讲下，最近接触了 Redux，就说下 createRedux 这个方法吧，为后面讲 Redux 做个铺垫。先看源码123456789101112131415161718192021var createReduce = function(dir) &#123; var reducer = function(obj, iteratee, memo, initial) &#123; var keys = !isArrayLike(obj) &amp;&amp; _.keys(obj), length = (keys || obj).length, index = dir &gt; 0 ? 0 : length - 1; if(!initial) &#123; memo = obj[keys ? keys[index] : index]; index += dir; &#125; for(; index &gt;= 0 &amp;&amp; index &lt; length; index += dir) &#123; var currentKey = keys ? keys[index] : index; memo = iteratee(memo, obj[currentKey], currentKey, obj); &#125; return memo; &#125;; return function(obj, iteratee, memo, context) &#123; var initial = arguments.length &gt;= 3; return reducer(obj, opitimizeCb(iteratee, context, 4), memo, initial); &#125;;&#125;; 这是 reduce 函数的工厂函数，用于生成一个 reducer ，dir 是决定方向用的。我们从最后一个 return 开始看起，即1234return function(obj, iteratee, memo, context) &#123; var initial = arguments.length &gt;= 3; return reducer(obj, opitimizeCb(iteratee, context, 4), memo, initial);&#125;; 我们使用 reduce 的时候，如果没有指定 memo 值，这时候参数个数只有两个即 obj 和 iteratee，所以 initial 为 false 表示没有初始化。对于没初始的情况，就是增加了一个 if 语句里面的内容而已，作用是把第一个元素作为 memo 值。接着就是有没有初始化都共用的部分了，通过一个 for 循环把 keys 遍历，并把相应的信息交给 iteratee 去处理，参数 memo 是上一次处理结果。遍历完后把最后的处理结果 memo 返回就完了。这个函数派生了两个方法，即12_.reduce = _.foldl = _.inject = createReduce(1);_.reduceRight = _.foldr = createReduce(-1); 只是方向不同而已。举个例子方便理解些，例如：123var sum = _.reduce([1, 2, 3, 4, 5], function(accumulator, value, index, collection) &#123; return accmulator + value;&#125;, 0); 结果为 15 这个应该很明显，js 原生也有 reduce 方法，如下：123[1, 2, 3, 4, 5].reduce(function(left, right) &#123; return left + right;&#125;); 我们看下 Underscore 的例子，主要想说明下他的运行过程，如下：12345678910if(!initial) memo = 1; index = 1;endiffor memo = iteratee(1, 2, 1, [1, 2, 3, 4, 5]) = 3; memo = iteratee(3, 3, 2, [1, 2, 3, 4, 5]) = 6; memo = iteratee(6, 4, 3, [1, 2, 3, 4, 5]) = 10; memo = iteratee(10, 5, 4, [1, 2, 3, 4, 5]) = 15;endforreturn memo = 15; 额，我也不知道写的是什么东西，只是描述下过程而已，你懂的。剩下的集合部分感觉也没啥好说的了，花点时间看下就可以看懂了=.=。","categories":[{"name":"Underscore","slug":"Underscore","permalink":"https://ruiming.github.io/categories/Underscore/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/tags/JavaScript/"},{"name":"Underscore","slug":"Underscore","permalink":"https://ruiming.github.io/tags/Underscore/"}]},{"title":"Underscore 源码学习(三)","slug":"Underscore源码学习(三)","date":"2016-07-31T06:37:31.000Z","updated":"2016-08-04T08:32:56.000Z","comments":true,"path":"2016/07/31/Underscore源码学习(三)/","link":"","permalink":"https://ruiming.github.io/2016/07/31/Underscore源码学习(三)/","excerpt":"这次主要说剩余参数。在 ES5 中，如果想要函数接收任意数量的参数，必须使用特殊变量 arguments，举个例子，我们要实现一个加法函数，要求第一个数乘2，然后与其他数相加。1234567function add() &#123; var sum = arguments[0] * 2; for(var i = 1; i &lt; arguments.length; i++) &#123; sum += arguments[i]; &#125; return sum;&#125; 在 ES6 中，我们可以使用 ... 操作符，例如：1234567function add(first, ...args) &#123; var sum = first*2; for(let arg of args) &#123; sum += arg; &#125; return sum;&#125; 使用 ES5 我们无法给函数定义参数，而只能通过 arguments 来获取参数，这样写明显带来了可读性的降低。而 ES6 我们就可以在函数声明里面写明参数，对于不定长的参数，则可以使用 ... 操作符。... 还有另一个常用的应用场景，比如下面例子：12345678910function test() &#123; console.log(arguments); console.log(arguments instanceof Array); console.log(arguments instanceof Object);&#125;test(1, 2, 3);// Result:[1, 2, 3]falsetrue 如果细看输出的[1, 2, 3]会发现他是这样的：我们再试试下面的12345678var arr = [1, 2, 3];console.log(arr);console.log(arr instanceof Array);console.log(arr instanceof Object);// Result:[1, 2, 3]truetrue 再看下[1, 2, 3]这行输出里面是什么：从 instanceof 我们就知道了 arguments 并不是真正的数组。伪数组实质是一个对象。要把一个伪数组转为数组，可以这样用1var arr = Array.prototype.slice.call(arguments); 上面这种做法在很多地方都可以看到。除了上面这样做之外，我们还可以使用 ES6 的 Array.from 来处理，如下：1var arr = Array.from(arguments); 但在 ES6 中，我们使用 ... 运算符并不存在这个问题，比如上面第二个例子，args 是一个数组。鉴于此，我们应该尽量使用 ES6 剩余参数写法和 Array.from 的写法，因为这样更容易理解，而且写起来更简洁。另外，我们还可以使用 ... 操作符来复制数组，如下：","text":"这次主要说剩余参数。在 ES5 中，如果想要函数接收任意数量的参数，必须使用特殊变量 arguments，举个例子，我们要实现一个加法函数，要求第一个数乘2，然后与其他数相加。1234567function add() &#123; var sum = arguments[0] * 2; for(var i = 1; i &lt; arguments.length; i++) &#123; sum += arguments[i]; &#125; return sum;&#125; 在 ES6 中，我们可以使用 ... 操作符，例如：1234567function add(first, ...args) &#123; var sum = first*2; for(let arg of args) &#123; sum += arg; &#125; return sum;&#125; 使用 ES5 我们无法给函数定义参数，而只能通过 arguments 来获取参数，这样写明显带来了可读性的降低。而 ES6 我们就可以在函数声明里面写明参数，对于不定长的参数，则可以使用 ... 操作符。... 还有另一个常用的应用场景，比如下面例子：12345678910function test() &#123; console.log(arguments); console.log(arguments instanceof Array); console.log(arguments instanceof Object);&#125;test(1, 2, 3);// Result:[1, 2, 3]falsetrue 如果细看输出的[1, 2, 3]会发现他是这样的：我们再试试下面的12345678var arr = [1, 2, 3];console.log(arr);console.log(arr instanceof Array);console.log(arr instanceof Object);// Result:[1, 2, 3]truetrue 再看下[1, 2, 3]这行输出里面是什么：从 instanceof 我们就知道了 arguments 并不是真正的数组。伪数组实质是一个对象。要把一个伪数组转为数组，可以这样用1var arr = Array.prototype.slice.call(arguments); 上面这种做法在很多地方都可以看到。除了上面这样做之外，我们还可以使用 ES6 的 Array.from 来处理，如下：1var arr = Array.from(arguments); 但在 ES6 中，我们使用 ... 运算符并不存在这个问题，比如上面第二个例子，args 是一个数组。鉴于此，我们应该尽量使用 ES6 剩余参数写法和 Array.from 的写法，因为这样更容易理解，而且写起来更简洁。另外，我们还可以使用 ... 操作符来复制数组，如下：1var itemsCopy = [...items]; 额，说多了，其实我是想说说 Underscore 中的 restArgs 这个东西…看下：123456789101112131415161718192021var restArgs = function(func, startIndex) &#123; startIndex = startIndex == null ? func.length -1 : +startIndex; return function() &#123; var length = Math.max(arguments.length - startIndex, 0); var rest = Array(length); for(var index = 0; index &lt; length; index++) &#123; rest[index] = arguments[index + startIndex]; &#125; switch (startIndex) &#123; case 0: return func.call(this, rest); case 1: return func.call(this, arguments[0], rest); case 2: return func.call(this, arguments[0], arguments[1], rest); &#125; var args = Array(startIndex + 1); for (index = 0; index &lt; startIndex; index++) &#123; args[index] = arguments[index]; &#125; args[startIndex] = rest; return func.apply(this, args); &#125;;&#125;; 这个的作用就类似与 ES6 中的 ... 操作符。这段代码作用是把 func 中 startIndex 开始的（如果没有指定则为被函数声明参数的最后一位开始）后面的参数全部变为一个数组传入 func 中。这里有几个可圈可点的地方： fun.length 和 arguments.length函数也具有 length 方法，得到的值是函数定义的参数的个数，但注意如果中间有一个含默认值的参数，则这个数和后面的参数都不会计算进去。例如： 1234function test1(arg1, arg2, arg3 = 1, arg4) &#123;&#125;;function test2(arg1, arg2, arg3) &#123;&#125;;test1.length; // 2test2.length // 3 而 arguments.length 则一直表示传入函数的参数个数。 使用 + 转换为数字你可能注意到了下面这句话有个 + 运算符。 1startIndex = startIndex == null ? func.length - 1 : +startIndex; 其用途就是尝试把 startIndex 转为数字，我们举例看下就明白了。 123456var a = '123', b = '123s', c = '0x321', d = '-0', e = '-Infinity'+a; // 123+b; // NaN+c; // 801+d; // -0+e; // -Infinity 应该很清楚了，就不说明了。然后关于这里的 switch 其实就是一个优化而已，前面都提到过了，不提了。 我们看下 Underscore 运用到 restArgs 方法的地方：1234567_.invoke = restArgs(function(obj, method, args) &#123;var isFunc = _.isFunction(method); return _.map(obj, function(value) &#123; var func = isFunc ? method : value[method]; return func == null ? func : func.apply(value, args); &#125;);&#125;); 这个方法的作用是在 obj 的每个元素上面执行 method 方法，例如：12345_.invoke([[5, 1, 7], [3, 2, 1]], 'sort');_.invoke([['a', 'b', 'c'], ['w', 'g', 's']], 'join', '#');// Result:1,5,7,1,2,3a#b#c,w#g#s 由于 method 需要的参数个数是未知的，所以我们这里使用了 args 再用 restArgs 达到类似 ... 操作符的效果。本来还想说说 Underscore 的几个方法的…但是好像已经写了挺多的了，还是下一次再介绍吧，后面的很多方法其实都不难理解，不过最好结合他的实际应用例子这样就更容易去理解些。","categories":[{"name":"Underscore","slug":"Underscore","permalink":"https://ruiming.github.io/categories/Underscore/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/tags/JavaScript/"},{"name":"Underscore","slug":"Underscore","permalink":"https://ruiming.github.io/tags/Underscore/"}]},{"title":"Underscore 源码学习(二)","slug":"Underscore源码学习(二)","date":"2016-07-29T13:29:23.000Z","updated":"2016-08-04T08:32:42.000Z","comments":true,"path":"2016/07/29/Underscore源码学习(二)/","link":"","permalink":"https://ruiming.github.io/2016/07/29/Underscore源码学习(二)/","excerpt":"Underscore 源码的学习落下了好几天，因为前几天一直正在重构项目和搞 React，不过这几天应该会花较多时间在 Underscore 上面了。这次主要说下 Underscore 两个比较重要的函数吧，一个是optimizeCb，另一个是cb，这两个花了我挺长时间看的，而且是整个 Underscore 非常重要的函数，后面很多地方都使用到了它。 optimizeCb 函数1234567891011121314151617var optimizeCb = function(func, context, argCount) &#123; if (context === void 0) return func; switch (argCount == null ? 3 : argCount) &#123; case 1: return function(value) &#123; return func.call(context, value); &#125;; case 3: return function(value, index, collection) &#123; return func.call(context, value, index, collection); &#125;; case 4: return function(accumulator, value, index, collection) &#123; return func.call(context, accumulator, value, index, collection); &#125;; &#125; return function() &#123; return func.apply(context, arguments); &#125;;&#125;; 这个地方 switch 只是一个性能的优化，其实简化来看就是这样的123456var optimizeCb = function(func, context, argCount) &#123; if (context === void 0) return func; return function() &#123; return func.apply(context, arguments); &#125;;&#125;; 之所以有那段 switch 前面一篇已经有提到了，只是一个优化而已。使用 call 快于 apply。不过好像最新的 Chrome 已经可以自己优化这个过程，但为了提升性能，加上也无妨。解释下段代码的意思，字如起名 optimizeCb 优化回调。这个函数传入三个参数依次是函数，上下文，参数个数。如果没有指定上下文则返回函数本身，如果有，则对该上下文绑定到传入的函数，根据传入的参数个数，在做一个性能优化。这个函数就是这个意思。我们看下他的使用。123456789101112131415_.each = _.forEach = function(obj, iteratee, context) &#123; iteratee = optimizeCb(iteratee, context); var i, length; if (isArrayLike(obj)) &#123; for (i = 0, length = obj.length; i &lt; length; i++) &#123; iteratee(obj[i], i, obj); &#125; &#125; else &#123; var keys = _.keys(obj); for (i = 0, length = keys.length; i &lt; length; i++) &#123; iteratee(obj[keys[i]], keys[i], obj); &#125; &#125; return obj;&#125;; 这个函数是用来实现数组或者对象的遍历的，他是怎么做到呢？首先是1iteratee = optimizeCb(iteratee, context);","text":"Underscore 源码的学习落下了好几天，因为前几天一直正在重构项目和搞 React，不过这几天应该会花较多时间在 Underscore 上面了。这次主要说下 Underscore 两个比较重要的函数吧，一个是optimizeCb，另一个是cb，这两个花了我挺长时间看的，而且是整个 Underscore 非常重要的函数，后面很多地方都使用到了它。 optimizeCb 函数1234567891011121314151617var optimizeCb = function(func, context, argCount) &#123; if (context === void 0) return func; switch (argCount == null ? 3 : argCount) &#123; case 1: return function(value) &#123; return func.call(context, value); &#125;; case 3: return function(value, index, collection) &#123; return func.call(context, value, index, collection); &#125;; case 4: return function(accumulator, value, index, collection) &#123; return func.call(context, accumulator, value, index, collection); &#125;; &#125; return function() &#123; return func.apply(context, arguments); &#125;;&#125;; 这个地方 switch 只是一个性能的优化，其实简化来看就是这样的123456var optimizeCb = function(func, context, argCount) &#123; if (context === void 0) return func; return function() &#123; return func.apply(context, arguments); &#125;;&#125;; 之所以有那段 switch 前面一篇已经有提到了，只是一个优化而已。使用 call 快于 apply。不过好像最新的 Chrome 已经可以自己优化这个过程，但为了提升性能，加上也无妨。解释下段代码的意思，字如起名 optimizeCb 优化回调。这个函数传入三个参数依次是函数，上下文，参数个数。如果没有指定上下文则返回函数本身，如果有，则对该上下文绑定到传入的函数，根据传入的参数个数，在做一个性能优化。这个函数就是这个意思。我们看下他的使用。123456789101112131415_.each = _.forEach = function(obj, iteratee, context) &#123; iteratee = optimizeCb(iteratee, context); var i, length; if (isArrayLike(obj)) &#123; for (i = 0, length = obj.length; i &lt; length; i++) &#123; iteratee(obj[i], i, obj); &#125; &#125; else &#123; var keys = _.keys(obj); for (i = 0, length = keys.length; i &lt; length; i++) &#123; iteratee(obj[keys[i]], keys[i], obj); &#125; &#125; return obj;&#125;; 这个函数是用来实现数组或者对象的遍历的，他是怎么做到呢？首先是1iteratee = optimizeCb(iteratee, context); 这个是优化 iteratee 这个函数，如果指定了上下文(context)则做绑定。一开始没理解 iteratee 这东西，其实他就是一个函数而已，比如123456789101112var stu = &#123; 'age': 20, 'school': 'SCNU', 'sex': 'male'&#125;;_.each(stu, function(value, key, obj) &#123; console.log(key + ' : ' + value); &#125;);// consoleage : 20school : SCNUsex : male 我们传入了一个函数，这个函数可以有三个回调参数分别是 value, key, obj 分别表示键值，键名，迭代对象。重新看回 each 这个函数，isArrayLike 函数判断 obj 是不是数组，如果是的话，一个循环分别把 obj[i], i, obj 分别传入这个 iteratee 这个传入来的函数，比如上面的 function(value, key, obj){} 里面，一一对应到 value, key, obj。从而实现迭代。在下面的是对象的处理，没什么好说的。然后我们就讲完了 optimizeCb 这个函数了，其实也挺好理解的。 cb 函数1234567891011121314var cb = function(value, context, argCount) &#123; // 如果改变了iteratee的行为，则返回自定义的iteratee if (_.iteratee !== builtinIteratee) return _.iteratee(value, context); // 没有传入value，返回当前迭代元素自身，比如var results = _.map([1,2,3]) =&gt; results: [1,2,3] if (value == null) return _.identity; // 是函数返回优化回调函数，比如var results = _.map([1,2,3], function(value, index, obj) &#123;...&#125;) if (_.isFunction(value)) return optimizeCb(value, context, argCount); // 是对象返回一个能判断对象是否相等的函数，比如 // var results = _.map([&#123;name:'qq'&#125;,&#123;name:'w',age:13&#125;], &#123;name:'w'&#125;) =&gt; results: [false, true] if (_.isObject(value)) return _.matcher(value); // 返回获取对象属性的函数，比如 // var results = _.map([&#123;name: 'qq'&#125;, &#123;name: 'ww'&#125;], 'name') =&gt; results: ['qq', 'ww']return _.property(value);&#125;; 首先是 buildinIteratee 这东西，这要结合下面这个来看123_.iteratee = builtinIteratee = function(value, context) &#123; return cb(value, context, Infinity);&#125;; 这个是给用户自定义迭代规则用的。怎么自定义呢，比如这样123456_.iteratee = function(value, context) &#123; // value 为对象时返回自身 if (value == null || _.isObject(value)) return _.identity; if (_.isFunction(value)) return optimizeCb(value, context, argCount); return _.property(value);&#125; 还有 identity 其实就这样，返回一个返回自身的函数…1234// Keep the identity function around for default iteratees._.identity = function(value) &#123;return value;&#125;; 我们自定义的这个迭代规则，如果 value 不为空而且是对象，则返回一个可以返回自身的函数。注意我们改变的只是 iteratee 函数，builtinIteratee 存的是默认规则，在 cb 函数中如果发现 iteratee 的行为更改了，则使用更改的行为来处理，否则往下默认处理，上面已经备注的很清楚了，自己看吧。我们举个例子说下 cb 函数的用法，例如1234567891011_.map = _.collect = function(obj, iteratee, context) &#123; iteratee = cb(iteratee, context); var keys = !isArrayLike(obj) &amp;&amp; _.keys(obj), length = (keys || obj).length, results = Array(length); for (var index = 0; index &lt; length; index++) &#123; var currentKey = keys ? keys[index] : index; results[index] = iteratee(obj[currentKey], currentKey, obj); &#125; return results;&#125;; 注意我们是怎么使用 map 的，比如123var results = _.map([1, 2, 3], function(value, index, obj) &#123; return '['+obj+']' + '\\'s '+index+' position is '+value;&#125;); 我们使用 map 传入两个参数，一个是迭代对象，这里是 [1, 2, 3]，第二个参数是迭代函数，这里是 function (value, index, obj){...}。这个函数在 map 内部也就是 iteratee，然后我们再来看1iteratee = cb(iteratee, context) iteratee 是一个函数，使用上面这个句子返回了 optimizeCb(value, context, argCount)，这里的 value 就对应了我们的 function(value, index, obj){...} 函数。接着回到 map，他对对象进行遍历依次把通过调用 iteratee 也就是我们传入的函数得到的结果复制给 result，最后返回了 result。所以上面例子的结果是12345results: [ \"[1,2,3]'s 0 position is 1\", \"[1,2,3]'s 1 position is 2\", \"[1,2,3]'s 2 position is 3\"]; 一定要理解 cb 和 optimizeCb 这两个的用法，他们在后面多次用到。好了，完了～","categories":[{"name":"Underscore","slug":"Underscore","permalink":"https://ruiming.github.io/categories/Underscore/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/tags/JavaScript/"},{"name":"Underscore","slug":"Underscore","permalink":"https://ruiming.github.io/tags/Underscore/"}]},{"title":"一次项目重构","slug":"一次项目重构","date":"2016-07-26T11:57:36.000Z","updated":"2016-08-04T09:29:06.000Z","comments":true,"path":"2016/07/26/一次项目重构/","link":"","permalink":"https://ruiming.github.io/2016/07/26/一次项目重构/","excerpt":"上学期由于期末停工的项目又要继续开展了，然而停了一个多月的时间，我已经看不下去他的代码了，简直惨不忍睹，花了我将近40个小时的时间去做了重构。虽然重构说明有进步了，但是一改就要改几十个页面啊…累觉不爱..说一说这次将近40小时的重构吧。 Angular 重构项目是基于 Angular 的 SPA，项目参考Angular规范进行重构，主要是以下几点： 把控制器的业务逻辑(主要是 HTTP 请求)分离到 Factory Controller 和 Directive 以及 Factory 全部用立即函数包装 Controller 和 Directive 以及 Factory 内部书写格式 使用 controllerAs 代替 $scope 全部 JavaScript 文件使用 use strict 严格模式 利用单体做部分数据的缓存 提取大部分可复用模块到 directive 全部 ng-repeat 加上 track by 过大的试图使用 ng-include 进行分离 去掉全部辅助变量，用 angular-promise-buttons 来达到按钮状态变化 去掉全部页面切换动画 手动进行依赖注入 使用 ES6 语法，用 babel 转为 ES5 使用 eslint 来做代码格式检查 之前我几乎没有使用 Factory 这一层，全部业务逻辑都在 Controller 里面做，随着项目越来越大(有26个页面)，页面之间函数重复的情况很多，而且控制器太厚，可读性差，给维护带来了巨大的困难。在这次重构之中，我把全部的 HTTP 请求全部放在 Factory 实现，从而做到了以下几点： 函数复用，多个控制器用一个 Factory，避免同个函数多次书写 HTTP 请求返回 promise，结合 angular-promise-buttons 做到了按钮状态的自动变化以及过渡效果，去掉了先前实现同样目的的全部辅助变量 对部分相对不变的数据，在第一次缓存后直接在该 Factory 进行缓存，第二次获取的时候直接返回内存中的数据，加快了部分页面的二次加载速度，对跨页面你的同个请求同样有效 容易做单元测试和更改逻辑，因为全部 HTTP 请求都放在 Factory 实现，对后期修改以及代码测试都带来了很大的方便","text":"上学期由于期末停工的项目又要继续开展了，然而停了一个多月的时间，我已经看不下去他的代码了，简直惨不忍睹，花了我将近40个小时的时间去做了重构。虽然重构说明有进步了，但是一改就要改几十个页面啊…累觉不爱..说一说这次将近40小时的重构吧。 Angular 重构项目是基于 Angular 的 SPA，项目参考Angular规范进行重构，主要是以下几点： 把控制器的业务逻辑(主要是 HTTP 请求)分离到 Factory Controller 和 Directive 以及 Factory 全部用立即函数包装 Controller 和 Directive 以及 Factory 内部书写格式 使用 controllerAs 代替 $scope 全部 JavaScript 文件使用 use strict 严格模式 利用单体做部分数据的缓存 提取大部分可复用模块到 directive 全部 ng-repeat 加上 track by 过大的试图使用 ng-include 进行分离 去掉全部辅助变量，用 angular-promise-buttons 来达到按钮状态变化 去掉全部页面切换动画 手动进行依赖注入 使用 ES6 语法，用 babel 转为 ES5 使用 eslint 来做代码格式检查 之前我几乎没有使用 Factory 这一层，全部业务逻辑都在 Controller 里面做，随着项目越来越大(有26个页面)，页面之间函数重复的情况很多，而且控制器太厚，可读性差，给维护带来了巨大的困难。在这次重构之中，我把全部的 HTTP 请求全部放在 Factory 实现，从而做到了以下几点： 函数复用，多个控制器用一个 Factory，避免同个函数多次书写 HTTP 请求返回 promise，结合 angular-promise-buttons 做到了按钮状态的自动变化以及过渡效果，去掉了先前实现同样目的的全部辅助变量 对部分相对不变的数据，在第一次缓存后直接在该 Factory 进行缓存，第二次获取的时候直接返回内存中的数据，加快了部分页面的二次加载速度，对跨页面你的同个请求同样有效 容易做单元测试和更改逻辑，因为全部 HTTP 请求都放在 Factory 实现，对后期修改以及代码测试都带来了很大的方便 举个例子，这是我项目中的部分代码，现在是能拿出手了，以前的代码我都不能再吐槽了 1234567891011121314151617181920212223242526272829303132333435363738/** IndexCtrl.js */(function() &#123; // 立即执行函数，避免作用域污染 'use strict'; // 严格模式，使代码更规范 // 空一行 angular // Angular控制器定义，控制器函数使用命名行数 .module('index') .controller('IndexCtrl', IndexCtrl); IndexCtrl.$inject = ['bookservice', 'booklistservice', 'slideservice']; // 手动依赖注入 // 再空一行 function IndexCtrl(bookservice, booklistservice, slideservice) &#123; // 控制器函数 var vm = this; // 不使用$scope vm.myInterval = 5000; vm.getHotBooklists = getHotBooklists; // 置顶绑定成员，函数声明隐藏实现细节 getPopularBooks(); // 即时只使用一次，也推荐封装成函数 getSlides(); function getPopularBooks() &#123; return bookservice.getPopularBooks().then(response =&gt; &#123; vm.books = response; &#125;); &#125; function getHotBooklists() &#123; return booklistservice.getHotBooklists().then(response =&gt; &#123; vm.booklists = response; &#125;); &#125; function getSlides() &#123; return slideservice.getSlides().then(response =&gt; &#123; vm.slides = response; &#125;); &#125; &#125;&#125;)(); 然后是 Factory 文件1234567891011121314151617181920212223242526272829303132/** SlideService.js */(function() &#123; 'use strict'; angular .module('index') .factory('slideservice', slideservice); slideservice.$inject = ['$http', '$q']; function slideservice($http, $q) &#123; let slides = null; return &#123; getSlides: getSlides &#125;; function getSlides() &#123; if(slides === null) &#123; return $http.get(host + '/slides') .then(response =&gt; &#123; slides = response.data; // 第一次获取后存入内存 return slides; &#125;); &#125; else &#123; let deferred = $q.defer(); deferred.resolve(slides); return deferred.promise; // 将数据封装入promise返回，保证透明性 &#125; &#125; &#125;&#125;)(); directive 就不给示例了，上面主要参考了这个Angular规范。这样写真的比我之前写的好了几百倍，controller 和 factory 和 directive 都按这个规范来，代码会很好维护。 这次重构让我知道我以前写的根本不叫 Angular，写的是一坨翔，MLGB 害我改了四天。 HTML 重构其实说白了也是 Angular 重构，在上面的 Angular 重构已经提到了一些了，但是上面主要是说 controller 和 factory，这里说下 directive 和视图。 部分页面复用在 Angular 中，HTML 部分复用有两种方案，一种是使用 ng-include，还有一种是使用 directive，其实区别很简单，ng-include 只是很简单的 HTML 复用，而 directive 你可以传递参数，directive 可以有自己的控制器，可以操纵 DOM，其实就是 HTML 和 JavaScript 文件的区别。不过这只是 directive 在页面复用这一块的作用，其实 directive 强大的很。 使用 ng-repeat 都带上 track by对于 ng-repeat 使用 track by 可以提升性能，对于任何 ng-repeat 都加上 track by 是一个好习惯。比如123&lt;ul&gt; &lt;li ng-repeat=\"book in vm.books track by book.isbn\"&gt;&#123;&#123;book.title&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 也可以直接使用 track by $index。 使用 controllerAs直接在路由使用 controllerAs12345678910.state('index', &#123; url: '/', views: &#123; 'main': &#123; templateUrl: 'index/index_tpl.html', controller: 'IndexCtrl', controllerAs: 'vm' &#125; &#125;&#125;) 然后在视图中就像上面的例子，在访问控制器的变量和方法的时候都要带上 vm，虽然这样会稍微麻烦了一点，但是可以避免很多坑，而且这种写法更接近 JavaScript 原生的写法。 CSS 重构恩，CSS 重构才是真正的大坑，先说下我之前是怎么写 CSS 代码的 使用了 Sass 预处理器 多层嵌套 命名混乱 过多复用 全部挤在一个文件 恩，挤在一个文件里面是最要命的，而且很任性的进行嵌套，导致多了或者少了一层都可能出问题，而且是2000多行的代码…所以我其实并没有做什么重构，我把它从一个文件分成了很多个文件，每个视图一个专属 scss 文件，对于复用的部分页面，用 directive 替代，并给该 directive 专属的 scss 文件。怎么做到专属呢，就是每个视图和每个 scss 都包装在一个类名里面，这样就保证了 scss 代码互不干扰。所以，其实我做的只是便于后期书写而已，总不能继续在这个文件书写下去，大坑啊。。","categories":[{"name":"Angular","slug":"Angular","permalink":"https://ruiming.github.io/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"https://ruiming.github.io/tags/Angular/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/tags/JavaScript/"}]},{"title":"JavaScript 闭包，继承与原型链","slug":"JavaScript闭包，继承与原型链","date":"2016-07-22T07:03:23.000Z","updated":"2016-10-26T14:54:36.000Z","comments":true,"path":"2016/07/22/JavaScript闭包，继承与原型链/","link":"","permalink":"https://ruiming.github.io/2016/07/22/JavaScript闭包，继承与原型链/","excerpt":"JavaScript 闭包和原型链学习心得，如果有不对的地方望指出。 闭包什么是闭包，有很多说法，我的理解是一个函数可以记住和使用外部变量，保存这个变量的引用在自己的一个环境之中。例如：1234567891011function makeAdder(x) &#123; return function(y) &#123; return x + y; &#125;;&#125;var add5 = makeAdder(5);var add10 = makeAdder(10);console.log(add5(2)); // 7console.log(add10(2)); // 12 这个例子中， makeAdder 是一个函数工厂，add5 和 add10 就是闭包，他们记住了外部变量 x。通常一个函数执行完毕后其运行期上下文会被释放，但由于闭包的属性包含了与运行期上下文作用域链相同的对象引用，导致这个激活对象无法销毁，这就会导致内存消耗，另外，闭包内部的作用域链并不处在闭包作用域链的前端，并且闭包经常使用外部变量的话，导致对象属性的遍历经常到其原型上面去（一个解决方法是把他赋值到闭包自身的作用域上面），从而增加性能消耗。既然闭包会导致内存增加和性能消耗，那为什么那么多人还使用它呢？上面的例子可能不太能说明问题，我们看下其他例子。123456789101112131415161718192021222324var Counter = (function() &#123; var privateCounter = 0; function changeBy(val) &#123; privateCounter += val; &#125; return &#123; increment: function() &#123; changeBy(1); &#125;, decrement: function() &#123; changeBy(-1); &#125;, value: function() &#123; return privateCounter; &#125; &#125; &#125;)();console.log(Counter.value()); /* logs 0 */Counter.increment();Counter.increment();console.log(Counter.value()); /* logs 2 */Counter.decrement();console.log(Counter.value()); /* logs 1 */ 这个例子中外部只能通过 value 方法获取 privateCounter 的值，只能通过 increment 和 decrement 方法来改变 privateCounter 的值，无法直接获取到 priavateCounter 和调用 changeBy 函数。这种模式叫 module模式，因为大部分模块都是这样写的，包括 Underscore 也是这样。上篇中就说道了 Underscore 使用了立即执行函数，其用途其一是为了不污染外部变量，因为 JavaScript 是函数作用域，其次它利用了闭包的特性又可以保持函数内部闭包的可调用和被闭包所引用变量在闭包环境中的存在，同时函数内部可以定义一些私有变量和私有方法。我们无需担心这些变量和函数在外部函数执行完毕结束后的失效。当你看到函数里面又 return 函数时，同时该函数又使用了外部变量，则该函数就是一个闭包。关于闭包还有一个很容易犯错的地方，比如你想实现第一秒输出1,第二秒输出2,以此类推。12345for (var i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i*1000);&#125; 但是实际运行结果是第一秒输出6,第二秒输出6…闭包是记住了外部变量的引用，每次循环都建立了一个 timer 函数，但 console 并还没有被执行，当循环结束后确实是建立了5个计时器或者说5个闭包，但当开始执行 console 的时候，由于这些闭包所引用的 i 此时结果为6，所以会输出5次 6。更能说明问题些，我们稍作修改下：","text":"JavaScript 闭包和原型链学习心得，如果有不对的地方望指出。 闭包什么是闭包，有很多说法，我的理解是一个函数可以记住和使用外部变量，保存这个变量的引用在自己的一个环境之中。例如：1234567891011function makeAdder(x) &#123; return function(y) &#123; return x + y; &#125;;&#125;var add5 = makeAdder(5);var add10 = makeAdder(10);console.log(add5(2)); // 7console.log(add10(2)); // 12 这个例子中， makeAdder 是一个函数工厂，add5 和 add10 就是闭包，他们记住了外部变量 x。通常一个函数执行完毕后其运行期上下文会被释放，但由于闭包的属性包含了与运行期上下文作用域链相同的对象引用，导致这个激活对象无法销毁，这就会导致内存消耗，另外，闭包内部的作用域链并不处在闭包作用域链的前端，并且闭包经常使用外部变量的话，导致对象属性的遍历经常到其原型上面去（一个解决方法是把他赋值到闭包自身的作用域上面），从而增加性能消耗。既然闭包会导致内存增加和性能消耗，那为什么那么多人还使用它呢？上面的例子可能不太能说明问题，我们看下其他例子。123456789101112131415161718192021222324var Counter = (function() &#123; var privateCounter = 0; function changeBy(val) &#123; privateCounter += val; &#125; return &#123; increment: function() &#123; changeBy(1); &#125;, decrement: function() &#123; changeBy(-1); &#125;, value: function() &#123; return privateCounter; &#125; &#125; &#125;)();console.log(Counter.value()); /* logs 0 */Counter.increment();Counter.increment();console.log(Counter.value()); /* logs 2 */Counter.decrement();console.log(Counter.value()); /* logs 1 */ 这个例子中外部只能通过 value 方法获取 privateCounter 的值，只能通过 increment 和 decrement 方法来改变 privateCounter 的值，无法直接获取到 priavateCounter 和调用 changeBy 函数。这种模式叫 module模式，因为大部分模块都是这样写的，包括 Underscore 也是这样。上篇中就说道了 Underscore 使用了立即执行函数，其用途其一是为了不污染外部变量，因为 JavaScript 是函数作用域，其次它利用了闭包的特性又可以保持函数内部闭包的可调用和被闭包所引用变量在闭包环境中的存在，同时函数内部可以定义一些私有变量和私有方法。我们无需担心这些变量和函数在外部函数执行完毕结束后的失效。当你看到函数里面又 return 函数时，同时该函数又使用了外部变量，则该函数就是一个闭包。关于闭包还有一个很容易犯错的地方，比如你想实现第一秒输出1,第二秒输出2,以此类推。12345for (var i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i*1000);&#125; 但是实际运行结果是第一秒输出6,第二秒输出6…闭包是记住了外部变量的引用，每次循环都建立了一个 timer 函数，但 console 并还没有被执行，当循环结束后确实是建立了5个计时器或者说5个闭包，但当开始执行 console 的时候，由于这些闭包所引用的 i 此时结果为6，所以会输出5次 6。更能说明问题些，我们稍作修改下：123456for (var i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i); i++; &#125;, i*1000);&#125; 结果是第一秒输出1，第二秒输出2…我们也可以这么做123456for (var i = 1; i &lt;= 5; i++) &#123; let j = i; setTimeout(function timer() &#123; console.log(j); &#125;, j*1000);&#125; 或者这样做 12345for (let i = 1; i &lt;= 5 ; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i*1000);&#125; 结果和上面一样，第一秒输出1，第二秒输出2… 这是为什么呢？第二个例子说明了闭包内使用的是外部变量的引用，他们都使用了同一个引用，所以最终输出取决与此时这个引用的值。第三个例子，每次循环都会新建一个变量 j，分别被每个闭包所引用，这些引用互不干扰，我们可以在 console.log(j) 后面加上 j++，结果是不会有变化的。 继承与原型链 在 javaScript 中，每个对象都有一个指向它的原型（prototype）对象的内部链接。这个原型对象又有自己的原型，直到某个对象的原型为 null 为止（也就是不再有原型指向），组成这条链的最后一环。这种一级一级的链结构就称为原型链（prototype chain）。 第一次接触 JavaScript 的原型链是在使用 Angular 的时候，如果有看到前面我的一篇写 Angular 的就会看到。在使用 Angular 的 ngIf 和 textarea 时，会创建新的子作用域，子作用域的原型是父级作用域一般就是 scope，以 textarea 为例子，假设一个用户修改评论的 textarea 框，我们首先把原先的评论写了回去，假设我们这样使用1&lt;textarea ng-model=\"content\", name=\"content\" class=\"form-control\" row=\"3\"&gt;&lt;/textarea&gt; 我们把用户的评论内容放到 $scope.content 里面去。结果是我们可以看到 textarea 确实一开始就被填入了用户原先的评论，可是如果此时我们更改 textarea 内部的内容，然后提交修改。你会发现 $scope.content 没有发生变化。这是因为 Angular 默认在 textarea 创建了一个新的子作用域，这个作用域本身一开始并不存在 content 这个值，即没有 hasOwnProperty(‘content’)，但他并不会因此就不做显示了，他会去找其原型，一般是 scope (如果在 ng-if 使用了 textarea，则其原型的原型才是 scope )，如果原型存在 content 则继承原型。所以你会看到初始状态是没问题的，当你修改评论内容时候，此时 textarea 自身的作用与就会新建了一个 content，内容就为你的评论内容，而其原型的 scope 将不再被使用，也不会被修改，所以你会发现 $scope.content 并没有发生变化。如果 textarea 的原型也不存在 content，它会再往上找，直到原型链最顶端为止，处在原型链最顶端的对象的原型是 null。以 Angular 的这个例子，我们就介绍完了 JavaScript 的原型链和继承，我们再举个例子说明下。12345678910var stu = &#123;name: \"stu\", age: 18, school: \"SCNU\"&#125;;var father = &#123;name: \"parent\", age: 40, job: \"engineer\", company: \"Google\"&#125;;stu.__proto__ = father;console.log(stu.job) /* logs \"engineer\" */stu.job = \"student\"console.log(stu.job) /* logs \"student\" */console.log(father.job) /* logs \"engineer\" */for( prop in stu ) &#123; console.log(stu.prop); /* logs stu, 18, SCNU, student, Google */&#125; 使用for…in…会遍历对象的所有属性，一个解决方法是使用 hasOwnProperty 判断是否是该层的属性。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/tags/JavaScript/"}]},{"title":"Underscore 源码学习(一)","slug":"Underscore源码学习(一)","date":"2016-07-20T07:52:11.000Z","updated":"2016-08-04T09:12:05.000Z","comments":true,"path":"2016/07/20/Underscore源码学习(一)/","link":"","permalink":"https://ruiming.github.io/2016/07/20/Underscore源码学习(一)/","excerpt":"暑假打算研究一下 Underscore 源码，我会对一些我觉得比较有意思的点拿出来讨论下，不过我不会过多介绍，也不会去分析 Underscore 的各个方法，但我会附上一些相关的不错的参考资料。由于我也是初学阶段，所以如果有说的不正确的地方望指出。 要点1：立即执行函数Underscore 的内容都用这么一个东西包装起来了。1(function()&#123;..&#125;()); 其实也可以这样写1(function()&#123;&#125;)(); Underscore 把全部内容封装在立即执行函数里面，就形成了一个独立的作用域，与外部隔离，并且这样做还形成了闭包，可以模拟私有方法。推荐阅读： immediately-invoked-function-expression(英) immediately-invoked-function-expression(中) JavaScript中的立即执行函数 Closures 要点2：兼容浏览器和 Node 环境浏览器和服务端的一个主要区别是全局对象命名的不同，在浏览器全局变量是 window，在服务端即 Node 环境则是 global。123var root = typeof self == 'object' &amp;&amp; self.self === self &amp;&amp; self || typeof global == 'object' &amp;&amp; global.global === global &amp;&amp; global || this; 这个地方之前的写法是这样的1var root = this; 我认为之所以改成前面那种写法，可能是为了确保 root 指向 global 或者 window(self) 。大部分框架和库都采用这种做法，这种做法更加安全。1234567// 这一步确保self是一个object，这样self.self才不会出错typeof self == 'object'// 这一步确保self.self严格等于自身，貌似只有window具备这个特性// 即window === window.window.windowself.self === self// 为什么还要进行这一步？self 推荐阅读： The Global Object in Various JavaScript Environments 要点3：提供命名冲突解决方法Underscore 在给 root 赋值前，先保存了原先 root 的 _ 对象。之所以这样做，是因为可能我们用的其他库也使用了 _ 这个作为命名空间。1var previousUnderscore = root._; 我们结合 Underscore 最下面的这个方法来看。1234_.noConflict = function() &#123; root._ = previousUnderscore; return this;&#125;; 如果 _ 出现了冲突，可以使用下面方法1var _new = _.noConflict(); 这样一来应该很明显了，noConflict 将 previousUnderscore 即原先的 root._ 重新放回去，然后重新定义 Underscore 命名给 _new，这样就解决了 _ 冲突问题。","text":"暑假打算研究一下 Underscore 源码，我会对一些我觉得比较有意思的点拿出来讨论下，不过我不会过多介绍，也不会去分析 Underscore 的各个方法，但我会附上一些相关的不错的参考资料。由于我也是初学阶段，所以如果有说的不正确的地方望指出。 要点1：立即执行函数Underscore 的内容都用这么一个东西包装起来了。1(function()&#123;..&#125;()); 其实也可以这样写1(function()&#123;&#125;)(); Underscore 把全部内容封装在立即执行函数里面，就形成了一个独立的作用域，与外部隔离，并且这样做还形成了闭包，可以模拟私有方法。推荐阅读： immediately-invoked-function-expression(英) immediately-invoked-function-expression(中) JavaScript中的立即执行函数 Closures 要点2：兼容浏览器和 Node 环境浏览器和服务端的一个主要区别是全局对象命名的不同，在浏览器全局变量是 window，在服务端即 Node 环境则是 global。123var root = typeof self == 'object' &amp;&amp; self.self === self &amp;&amp; self || typeof global == 'object' &amp;&amp; global.global === global &amp;&amp; global || this; 这个地方之前的写法是这样的1var root = this; 我认为之所以改成前面那种写法，可能是为了确保 root 指向 global 或者 window(self) 。大部分框架和库都采用这种做法，这种做法更加安全。1234567// 这一步确保self是一个object，这样self.self才不会出错typeof self == 'object'// 这一步确保self.self严格等于自身，貌似只有window具备这个特性// 即window === window.window.windowself.self === self// 为什么还要进行这一步？self 推荐阅读： The Global Object in Various JavaScript Environments 要点3：提供命名冲突解决方法Underscore 在给 root 赋值前，先保存了原先 root 的 _ 对象。之所以这样做，是因为可能我们用的其他库也使用了 _ 这个作为命名空间。1var previousUnderscore = root._; 我们结合 Underscore 最下面的这个方法来看。1234_.noConflict = function() &#123; root._ = previousUnderscore; return this;&#125;; 如果 _ 出现了冲突，可以使用下面方法1var _new = _.noConflict(); 这样一来应该很明显了，noConflict 将 previousUnderscore 即原先的 root._ 重新放回去，然后重新定义 Underscore 命名给 _new，这样就解决了 _ 冲突问题。 要点4：考虑压缩问题123456var ArrayProto = Array.prototype, ObjProto = Object.prototype;var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;var push = ArrayProto.push, slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty; 这里首先说一下Symbol，ES5 规定了六种语言类型即 Null, Undefined, Number, Boolean, String, Object，而新出台的 ES6 则新增了 Symbol。关于 Symbol 查看推荐阅读。这里把 Array 和 Object 和 Symbol 的原型都用变量来引用的原因是变量可以进行压缩，如果有使用过代码压缩工具的话，一个常见的压缩技巧就是用短变量名代替长变量名，而对于一些出现频率高的方法我们可以用变量来进行引用来便于压缩。而 push, slice, toString, hasOwnProperty 这些引用不仅便于压缩，还可以减少在原型链中的查找次数，提高速度。即直接在原型上操作，避免原型链查找。关于原型链是个大问题了，这里不打算过多讲解（其实是我也不怎么懂），下一篇再进行介绍。还有一个地方顺便提一下的是，Underscore 的源码不使用 undefined 而是使用 void 0。这个也是代码压缩的时候会做的事情。虽然从 ES5 开始 undefined 是全局对象的只读属性不能重写，但是在局部作用域中仍然可以被重写，而 void 运算符能对给定的表达式进行求值，然后返回 undefined，可以保证返回的是 undefined，void不能重写。再者，之所以跟的是0，只是因为0短并且习惯问题而已。推荐阅读： operators-void Symbol 要点5：区别apply, call和bind在 Underscore 源码中我们会经常看到 apply 和 call 的应用。例如：1234567891011switch (startIndex) &#123; case 0: return func.call(this, rest); case 1: return func.call(this, arguments[0], rest); case 2: return func.call(this, arguments[0], arguments[1], rest);&#125;var args = Array(startIndex + 1);for (index = 0; index &lt; startIndex; index++) &#123; args[index] = arguments[index];&#125;args[startIndex] = rest;return func.apply(this, args); apply 和 call 都是为了改变某个函数运行时的 context 即上下文而存在的，即改变函数提内部 this 的指向，他们的功能是相同的，只是用法稍有不同。1234var func1 = function(arg1, arg2) &#123;&#125;;// 可以通过下面两个方法来调用func1.call(this, arg1, arg2);func1.apply(this, [arg1, arg2]); 即 call 传递的是参数列表，而 apply 传递的是数组，当我们知道参数的数量时使用 call 方法，不知道参数数量时可以把参数放到一个数组然后使用 apply 方法调用。bind 也可以更改函数执行的上下文但是不同的是，bind 只进行绑定不会立即调用。再看看上面 Underscore 源码中的一部分，对于startIndex小于3的情况，他分别使用了 call 方法调用，而当startIndex大于3的时候，则将参数转为数组形式使用 apply 方式调用。为什么不直接用 apply 方法呢？简而言之，apply 比 call 慢。对于 apply 方法，Function 会检查传入的参数的类型是否符合要求，还要进行解构操作等等。所以应该尽量使用 call 方法。Underscore 源码关于这段代码还有个地方值得注意1startIndex = startIndex == null ? func.length - 1 : +startIndex; 为什么使用 +startIndex？+运算符尝试将后面的数转为数字，例如将字符串(“123”)转为数(123)，对数字不会产生影响，如果传入(“123NASD”)，会得到 NaN 。推荐阅读： why-is-call-so-much-faster-than-apply","categories":[{"name":"Underscore","slug":"Underscore","permalink":"https://ruiming.github.io/categories/Underscore/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/tags/JavaScript/"},{"name":"Underscore","slug":"Underscore","permalink":"https://ruiming.github.io/tags/Underscore/"}]},{"title":"ARP 攻击和无线网卡混杂模式","slug":"ARP攻击和无线网卡混杂模式","date":"2016-07-14T04:32:41.000Z","updated":"2016-08-04T09:05:54.000Z","comments":true,"path":"2016/07/14/ARP攻击和无线网卡混杂模式/","link":"","permalink":"https://ruiming.github.io/2016/07/14/ARP攻击和无线网卡混杂模式/","excerpt":"一次小小的 Hack 尝试…前段时间换上了 Arch，就开始想这捣鼓一些黑科技。脑海中立即浮现出两个词， monitor 和 ARP 。 ARP 攻击学过计算机网络了，大概了解ARP攻击这么一回事，但是当我真正去试的时候，才发现局域网原来真的这么脆弱，因为进行ARP攻击实在太容易了。实际上就是几条命令的事情。 主机发现和端口扫描进行攻击第一步当然就是找目标了。可以使用 nmap 这个工具来进行，这东西简直渗透利器。1nmap -sP 192.168.1.0/24 这样就可以扫描192.168.1.0这个网段里面的所有主机了，以 ping 方式扫描，当然他有很多参数很多用法，网上很多这方面的资料我就不叙述了。 发起攻击如果是进行ARP攻击，那也是加多三条命令就搞定的事情。123echo 1 &gt;&gt; /proc/sys/net/ipv4/ip_forwardarpspoof -i wlp3s0 -t 192.168.1.110 192.168.1.1arpspoof -i wlp3s0 -t 192.168.1.1 192.168.1.110 第一条是开启转发，不然会受害者流量到我们这里出不去就断网了。第二条是告诉受害者说我是网管。第三条是告诉网管我是受害者。这样就完成了 ARP 欺骗，图片以后再补。这之后对方的网络就完全在你的监控之下了。这告诉我们使用 https 和不连接免费 wifi 的重要性! 抓包抓包推荐使用 wireshark 。具体就不介绍了=.=。你还可以使用 Driftnet 这东西来将对方访问的图片在你这边显示出来～ 监听空气包大部分无线网卡都可以设置 monitor 模式，即无线网卡默认接受下全部经过他的以太网帧而不丢弃，这种方式可以抓到附近范围里面的所以以太网帧。在 Arch 下也是三条命令搞定的事情。123ifconfig wlp3s0 downiwconfig wlp3s0 mode monitorifconfig wlp3s0 up 接着同样开启 wireshark 抓包，你会发现很多802.11帧，不过这个并没有什么卵用，理论上应该对于没有加密的帧应该可以直接得到应用层报文才对，但是很奇怪我一直抓不到，即使是对于有加密的 Wifi，我填入 WAPKEY 解密也不行。这个有待继续研究。。。","text":"一次小小的 Hack 尝试…前段时间换上了 Arch，就开始想这捣鼓一些黑科技。脑海中立即浮现出两个词， monitor 和 ARP 。 ARP 攻击学过计算机网络了，大概了解ARP攻击这么一回事，但是当我真正去试的时候，才发现局域网原来真的这么脆弱，因为进行ARP攻击实在太容易了。实际上就是几条命令的事情。 主机发现和端口扫描进行攻击第一步当然就是找目标了。可以使用 nmap 这个工具来进行，这东西简直渗透利器。1nmap -sP 192.168.1.0/24 这样就可以扫描192.168.1.0这个网段里面的所有主机了，以 ping 方式扫描，当然他有很多参数很多用法，网上很多这方面的资料我就不叙述了。 发起攻击如果是进行ARP攻击，那也是加多三条命令就搞定的事情。123echo 1 &gt;&gt; /proc/sys/net/ipv4/ip_forwardarpspoof -i wlp3s0 -t 192.168.1.110 192.168.1.1arpspoof -i wlp3s0 -t 192.168.1.1 192.168.1.110 第一条是开启转发，不然会受害者流量到我们这里出不去就断网了。第二条是告诉受害者说我是网管。第三条是告诉网管我是受害者。这样就完成了 ARP 欺骗，图片以后再补。这之后对方的网络就完全在你的监控之下了。这告诉我们使用 https 和不连接免费 wifi 的重要性! 抓包抓包推荐使用 wireshark 。具体就不介绍了=.=。你还可以使用 Driftnet 这东西来将对方访问的图片在你这边显示出来～ 监听空气包大部分无线网卡都可以设置 monitor 模式，即无线网卡默认接受下全部经过他的以太网帧而不丢弃，这种方式可以抓到附近范围里面的所以以太网帧。在 Arch 下也是三条命令搞定的事情。123ifconfig wlp3s0 downiwconfig wlp3s0 mode monitorifconfig wlp3s0 up 接着同样开启 wireshark 抓包，你会发现很多802.11帧，不过这个并没有什么卵用，理论上应该对于没有加密的帧应该可以直接得到应用层报文才对，但是很奇怪我一直抓不到，即使是对于有加密的 Wifi，我填入 WAPKEY 解密也不行。这个有待继续研究。。。","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://ruiming.github.io/categories/网络安全/"}],"tags":[{"name":"Hack","slug":"Hack","permalink":"https://ruiming.github.io/tags/Hack/"}]},{"title":"从输入 URL 到页面展示","slug":"从输入URL到页面展示","date":"2016-06-24T07:43:38.000Z","updated":"2016-11-30T10:56:43.000Z","comments":true,"path":"2016/06/24/从输入URL到页面展示/","link":"","permalink":"https://ruiming.github.io/2016/06/24/从输入URL到页面展示/","excerpt":"本文从网络层以上讨论从浏览器输入 HTTPS 协议的 URL 到页面展现的全过程。由于不同浏览器之间也存在差异，这里以 Chrome 浏览器为例。 1. DNS查询DNS 缓存有好几个环节，浏览器缓存，系统缓存，路由器缓存，ISP 缓存。 浏览器首先会查看自身是否已经有进行 DNS 缓存。Chrome 可以通过 chrome://net-internals/#dns 查看缓存的 DNS，浏览器的 DNS 缓存可以加快 DNS 解析速度，但缓存时间不会太长。 如果浏览器没有相应的缓存，则查找系统缓存，浏览器会向系统发送一个查询请求，如果系统存在缓存或者设置了 host ，则返回相应的 ip 地址给浏览器。 如果系统没有缓存，那么它会发出一个 DNS 查询请求给路由器。 如果路由器有 DNS 缓存，他会提取出 IP 地址返回。否则，他会向本地域名服务器发出查询，从请求主机到本地域名服务器的请求一般是递归查询，而其他的查询一般是迭代查询。 请求报文如下 我们先简单分析下请求报文。 DNS 使用 UDP 协议，端口号53。 在 DNS 报文的 Flags 中的 RD=1。表示它建议域名服务器以递归方式查询。 Question section format 需要给出 QNAME, QTYPE, QCLASS。即查询的域名，查询的类型以及查询的类。 有关DNS报文的更多信息可以参考RFC1035 响应报文如下 我们也简单分析下，如果想详细了解，可以查看上面的 RFC1035 标准。 与请求报文相比，对比 Flags 可以发现，QR=1 表示这是一个响应报文。RA=1 表示递归查询可用。 ARecord 记录了DNS请求获得的一个或多个IP地址。一般还会得到 CNAME 记录和存活时间等信息。 这里对 Rcode 也稍加说明下，Rcode=0 表示成功，他还有好几种状态码，比如1表示 Format error，2表示 Server failure，3表示 Name error，4表示 Not lmplemented，5表示 Refused，具体信息可以参考 RFC1035。","text":"本文从网络层以上讨论从浏览器输入 HTTPS 协议的 URL 到页面展现的全过程。由于不同浏览器之间也存在差异，这里以 Chrome 浏览器为例。 1. DNS查询DNS 缓存有好几个环节，浏览器缓存，系统缓存，路由器缓存，ISP 缓存。 浏览器首先会查看自身是否已经有进行 DNS 缓存。Chrome 可以通过 chrome://net-internals/#dns 查看缓存的 DNS，浏览器的 DNS 缓存可以加快 DNS 解析速度，但缓存时间不会太长。 如果浏览器没有相应的缓存，则查找系统缓存，浏览器会向系统发送一个查询请求，如果系统存在缓存或者设置了 host ，则返回相应的 ip 地址给浏览器。 如果系统没有缓存，那么它会发出一个 DNS 查询请求给路由器。 如果路由器有 DNS 缓存，他会提取出 IP 地址返回。否则，他会向本地域名服务器发出查询，从请求主机到本地域名服务器的请求一般是递归查询，而其他的查询一般是迭代查询。 请求报文如下 我们先简单分析下请求报文。 DNS 使用 UDP 协议，端口号53。 在 DNS 报文的 Flags 中的 RD=1。表示它建议域名服务器以递归方式查询。 Question section format 需要给出 QNAME, QTYPE, QCLASS。即查询的域名，查询的类型以及查询的类。 有关DNS报文的更多信息可以参考RFC1035 响应报文如下 我们也简单分析下，如果想详细了解，可以查看上面的 RFC1035 标准。 与请求报文相比，对比 Flags 可以发现，QR=1 表示这是一个响应报文。RA=1 表示递归查询可用。 ARecord 记录了DNS请求获得的一个或多个IP地址。一般还会得到 CNAME 记录和存活时间等信息。 这里对 Rcode 也稍加说明下，Rcode=0 表示成功，他还有好几种状态码，比如1表示 Format error，2表示 Server failure，3表示 Name error，4表示 Not lmplemented，5表示 Refused，具体信息可以参考 RFC1035。 2. 三次握手建立连接经过上述过程，此时浏览器得到了要访问的域名的 IP 地址。由于 DNS 查询需要一定时间，所以有些网站会使用 DNS Prefetching 进行 DNS 预解析，结合浏览器的 DNS 缓存，以加快网站速度。这里不做详细叙述。 首先贴出 TCP 三次握手的建立图。 我们抓包依次进行分析。 第一个握手包 从这个包我们可以得到以下信息: Seq = 2988862522 这个是本报文段所发送的数据的第一个字节的序号 DataOffset = 32（字节） 指明 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远 SYN = 1 SYN=1 而 ACK=0 时表示这是一个连接请求报文。 Window = 8192（字节） 客户端滑动窗口8192字节，滑动窗口协议是设计来提高报文段的传输效率，这里不详细叙述，可以自己查资料。 Checksum = 0x5818 校验和，校验和字段校验的范围包括首部和数据这两个部分，在计算校验和时，要在 TCP 报文段的前面加上12字节的伪首部。接收方接收到此报文段后，加上这个伪首部来计算校验和。校验和是用来保证数据的无差错。 MaxSegmentSize = 1460（字节） 即 MSS，表示 TCP 报文段中数据字段的最大长度。注意它加上 TCP 首部才等于整个的 TCP 报文。有关 MSS 的信息自己查资料。 比较重要的就是上述信息，客户端需要在第一次发包时要告知自身的一些信息。 第二个握手包 在接收到客户端发来的握手包后，服务端进行应答，我们对这个包进行分析： Seq = 1648068786 Ack = 2988862523 表示服务端期望收到对方的下一个报文段的第一个数据字节的序号。 ACK = 1 当 ACK=1 时确认号字段有效。 SYN = 1 ACK=1 且 SYN=1 表示这是一个同意建立连接的响应报文。 Window = 63343（字节） 服务端的滑动窗口为63343字节。 MaxSegmentSize = 1448（字节） 服务端的 TCP 报文中数据字段的最大长度为1448字节。 在前两次握手时，双方交换一些信息如 Window 和 MSS，确定 seq 和 ack 起始号。 第三个握手包 服务端接受请求后，客户端还需要在发送一个握手包。这个握手包明显信息更少了，同样我们查看一些关键值： Seq = 2988862523 由于上一个握手包没有携带正文信息，不占用字节空间，所以 Seq 与上一个握手包的 Ack 值相同。 Ack = 1648068787 同上，双方建立通信之后是会进行数据交换，同样的，这个地方表示客户端期望收到对方的下一个报文段的第一个数据字节的序号。 ACK = 1 表示对上一个握手包的确认 Window = 260（字节） TCP 的发送窗口时会不断变化的，TCP 的流量控制和拥塞控制会根据情况动态地调整发送窗口上限值，从而控制发送数据的平均速率。 自此三次握手完成，连接建立，可以开始传输数据。 3. 建立HTTPS连接以上完成握手，只能建立 HTTP 连接。但如果网站使用了 HTTPS 协议，那么还需要进行 SSL/TLS 握手。 在这之前，我们先介绍下 SSL/TLS。 SSL/TLS 是一种互联网安全加密技术。HTTP 报文是进行明文传输的，这意味着用户的 cookie 或者其提交的信息比如账号和密码都是在互联网上裸奔，如果这个报文被其他人抓取到，会带来很大的不安全性。使用 HTTPS 协议是非常有必要的，并且目前最新的 HTTP2 规范也仅支持 HTTPS。而 SSL/TLS 协议位于 TCP/IP 协议与各个应用层协议之间，为数据通信提供安全支持。他们可以分为记录协议和握手协议。 那么 SSL 和 TLS 又有什么区别呢？ 简单的说，TLS 的建立在 SSL 3.0 协议规范之上的，是 SSL v3 的强化版，在整个协议格式上和 SSL 类似。TLS 增强了加密算法，并带来了更严格的警报，在安全性方面有很多改进。 关于 HTTP 与 HTTPS 和 SSL 与 TLS 的具体差别自行搜索。 关于 SSL/TLS 协议这里不做详解，此处主要讲述 TLS 握手的建立过程和 HTTPS 安全的原因。 我们来看看 TLS 握手的大致过程，这里不再详细叙述每个握手包 Client Hello 可以看到 TCP 报文的 Push 为1，表示接收方尽快对该报文要尽快交付而不是积累到足够多的数据。 这是一个 TLS 握手包，我们可以看到 HandShakeType 为 ClientHello ，对应 TLS 握手图的第一步。 同时，该过程浏览器还发送了自己支持的一套加密规则。 Server Hello 服务端接受到上述报文后，会发送 TCP 报文进行确认。报文如下 服务端发出 ACK 包的同时，发送 TLS 报文，此时 HandShakeType 为 ServerHello，对应 TLS 握手图的第二步。 接着上述的报文，服务端从客户端发来的加密规则中选出一组加密算法和 HASH 算法，并把自己的身份信息以证书形式发给客户端。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。如图，发送公钥使用了两个报文，最后客户端发送 ACK 确认报文进行确认，注意这个报文和上面的 ACK 报文一样不占用空间，只是进行确认而已。 Client Key Exchange 浏览器获得证书后，会首先验证证书的合法性，如果证书受信任，则浏览器栏里面会显示一个小绿锁。同时浏览器会生成一串随机数的密码，并用证书中提供的公钥进行加密，然后使用约定好的 HASH 算法计算握手信息，并使用未加密的随机数对消息进行加密。然后将消息重新发给服务端。这一步是加密握手包的开始。 Cipher Change Spec 服务端使用自己的私钥对信息进行解密取出密码（密码被用公钥加密，只有用私钥才能加开，非对称加密），然后用该密码来解密握手消息，然后验证 HASH 是否与浏览器发来的一致。 接着使用这个密码来加密一段握手信息，发给客户端即浏览器。 Finish 客户端用密码对加密握手包进行解密（注意此时已经变为对称加密），同时计算 HASH 值，若 HASH 值一致，则握手过程结束。之后双方通信都使用之前浏览器生成的密码来进行加密。 至此， HTTPS 连接已成功建立。由于浏览器会对证书进行校验，由证书授权机构保证其有效性，可以保证证书不被篡改。同时浏览器方面生成的随机数密码，一开始只有浏览器知道，而这个密码用公钥加密之后，只有私钥能解开，公钥也无法解开，这是非对称加密。服务器接收到该数据包后解开得到该密码，双方就可以使用该密码通过对称加密传输数据了。 现给出 TCP 三次握手和 TLS 握手的列表信息。 这之后双方都是用 TLS 来传输数据，但不带数据的 ACK 确认包不进行加密，仍然使用 TCP 协议来传输。 需要明确的是，TLS 协议还是建立在 TCP 协议之上的，此处为便于说明将两者区分对待。即 TCP 协议是不进行加密的，TLS 是进行加密的 TCP 协议。 这个过程其实是先进行 HTTP 连接建立的三次握手，然后服务器进行 3xx 重定向，然后再进行 HTTPS 的三次握手。这样既增加了连接建立的开销，而且也可能在 HTTP 连接建立的过程被劫持。所以有出现了 HSTS。 HTTP 严格传输安全(HTTP Strict Transport Security)是一套由互联网工程任务组发布的互联网安全策略机制。网站可以选择使用 HSTS 策略，来让浏览器强制使用 HTTPS 与网站进行通信，以减少会话劫持风险。 我们有时候会看到出现证警告的提醒，使用了 HSTS 之后用户将不再允许忽略警告。但是用户首次访问某个网站是不受 HSTS 保护的，因为首次访问时浏览器还未收到 HSTS ，目前比较流行的方案是浏览器预置 HTST 域名列表，Google Chrome, Firefox, IE, Edge 都实现了这一方案，我们可以在服务器配置相关信息后去进行登记。HSTS 可以抵御 SSL 剥离攻击，它利用用户通过 HTTP 建立连接再重定向到 HTTPS 连接，阻止浏览器与服务器建立 HTTPS 连接，攻击者可以在用户访问 HTTP 页面时替换所有 HTTPS 链接为 HTTP，达到阻止 HTTPS 的目的。 4. 客户端请求网站信息 如果访问的是网站的主页，那么此时会发送一个请求给服务器，如下： HTTP 里面附带了 URI, ProtocolVersion, Host, Connection 以及 Cookie 等很多信息。 这里只讨论正常访问的情况。 服务端接收到该请求后，验证无误后，首先发送 ACK 报文进行确认。接着对该请求进行处理，如果是静态页面则直接返回。但大多数时候服务端都需要动态生成一个新的页面再返回该页面。这里讨论下 php 的处理。 假设我们这时候访问的是index.php这个页面，服务器例如 Nginx 知道这个不是静态文件，它回去寻找 PHP 解析器去做处理，这依靠的就是 CGI 来实现。 下面介绍几个概念，即 CGI, PHP-CGI, FastCGI, PHP-FPM。 CGI CGI 全称是“公共网关接口”（Common Gateway Interface），HTTP 服务器与服务器上其他程序进行通讯的一种协议。 PHP-CGI 简单的说 PHP-CGI 就是HTTP服务器与 PHP 进行通讯的工具，当浏览器发出一个类似 /index.php 的请求时，HTTP 服务器请求 PHP-CGI 去处理这个请求，PHP-CGI 处理完成后再把处理结果发回给 HTTP 服务器，然后由 HTTP 服务器发给浏览器。 PHP-CGI 在处理请求之前，需要解析php.ini文件，初始化执行环境，然后才开始处理请求。 FastCGI FastCGI 全称是“快速通用网关接口”（Fast Common Gateway Interface / FastCGI）是一种让交互程序与 Web 服务器通信的协议。它是 CGI 的增强版本。 CGI 程序运行在独立的进程中，并对每一个请求建立一个进程，每个建立都要经过解析配置文件和初始化执行环境。这种方法易于实现，但效率很差，难以面对大量请求。 FastCGI 使用持续的进程来处理一连串的请求。这些进程由 FastCGI 服务器管理，而不是 Web 服务器。它是一个常驻型的 CGI(master)，只要激活后就不需要重新去解析 php.ini 和初始化，提高了效率。他在自身初始化后会启动多个 CGI 解析器(worker)，当有请求过来时，他会交给其中一个 worker 去处理。同时，它还可以动态调整 worker 的数量。 PHP-FPM PHP-FPM 是一个 PHP FastCGI 管理器，从 PHP 5.3.3 开始已经集成了 PHP-FPM，在编译安装时可以通过 -enable-fpm 参数开启。 所以浏览器如果请求 /index.html 那么 Web 服务器会直接把这个静态页面返回，如果是请求 /index.php，则交由 PHP-FPM 进行处理，PHP-FPM 处理后再把结果返回给 Web 服务器，由 Web 服务器发给浏览器。 我们来看看响应报文 可以看到除了对浏览器请求的 ACK 确认包之外，服务端发回了10个包。第一个报文里面有StatusCode, Etag, ContentEncoding 等信息。这里面涉及到不少网站优化的技巧，我们将在下一篇中再讨论。这里大概了解下就可以了。 接下来的9个报文都是跟着第1个报文一起过来的。最后一个报文设置了 PUSH 标志，因为报文已经传输完毕，所以它请求浏览器客户端尽快交付。 接着客户端会发送 ACK 确认报文，之所以这里客户端对最后一个报文进行了确认，是因为 TCP Delayed Ack 的原因，它是为了避免多次发送 ACK 确认报文而设置的延时，一般为 40ms，也就是说如果接收到一个报文 40ms 后没有接收到第二个报文，他就会对这个报文进行确认。 服务器发送完全部数据后，最后再发送一个报文，即图中的 #191 报文，表示我已经发完。客户端相应的发出 ACK 确认报文。主页请求结束。 5. 浏览器渲染浏览器接收到 index.html 后，开始浏览器渲染，这里讨论 webkit 内核，其他内核不讨论。主要分为四步进行。如下图: 浏览器渲染不是本文的重点，所以只做简单说明。 Parsing HTML to construct the DOM tree 数据会交给 HTMLDocumentParser，然后 HTMLDocumentParser 将文本字符的解析交给 HTMLDocumentTokenizer 来负责，HTMLDocumentTokenizer 解析出一个一个的标签，然后 HTMLDocumentParser 将标签交给 HTMLTreeBuilder 来构建 DOM 树。 有些节点需要加载其他资源，比如加载外链 CSS 和图片等。会调用资源加载器进行异步加载，不会阻碍当前 DOM 树的构造。但是如果是非 defer 非 async 的 script 标签，则需要停止当前 DOM 树的构造，直到脚本被加载并被 JavaScript 执行后才继续 DOM 树的构造。 因此我们有时候会要求 &lt;script&gt; 标签放到最后面，目的是为了不影响前面 DOM 树的构建。 对于 css 文件，会解析 css 生成 CSS Rule Tree。 对于 JavaScript` 文件，主要是通过 DOM API 和 CSSOM API 来操作 DOM TREE 和 CSS Rule Tree，从而改变渲染的效果。 Render tree construction 接着浏览器会开始构建渲染树(Rendering Tree)。Renderint Tree 只包括渲染页面需要的节点。 CSS Rule Tree 会匹配的把 CSS Rule 附加到相应的 Rendering Tree 的元素上面。 Layout of the render tree 到目前为止，我们已经计算了哪些节点是可见的，以及它们的计算样式，但还没有计算它们在设备视窗中的准确位置与尺寸。这就是布局阶段做的事情。 渲染树的构建、布局与绘制所需的时间取决于文档大小、应用的样式，当然，还有运行文档的设备：文档越大，浏览器要完成的工作就越多；样式越复杂，绘制需要的时间就越长（例如，绘制单色成本较低，而计算、呈现阴影的成本就非常高了）。 Painting the render tree 一旦布局完成，浏览器便会发出 Paint Setup 与 Paint 事件，将渲染树转化为屏幕上的实际像素。 大概可以用下图来表示整个过程。 参考资料 How DNS query works Render Tree Construction How browsers work","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://ruiming.github.io/categories/HTTP/"}],"tags":[{"name":"DNS","slug":"DNS","permalink":"https://ruiming.github.io/tags/DNS/"},{"name":"HTTPS","slug":"HTTPS","permalink":"https://ruiming.github.io/tags/HTTPS/"},{"name":"HTTP","slug":"HTTP","permalink":"https://ruiming.github.io/tags/HTTP/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://ruiming.github.io/tags/TCP-IP/"},{"name":"Webkit","slug":"Webkit","permalink":"https://ruiming.github.io/tags/Webkit/"}]},{"title":"Angular 学习总结","slug":"Angular学习总结","date":"2016-06-18T12:20:38.000Z","updated":"2016-08-04T09:24:58.000Z","comments":true,"path":"2016/06/18/Angular学习总结/","link":"","permalink":"https://ruiming.github.io/2016/06/18/Angular学习总结/","excerpt":"这学期基本都是在学习和使用 Angular ，这篇文章主要是想介绍几个 Angular 需要注意或者了解的地方。 Angular作用域​ 也许你知道 ng-if 和 ng-show 的区别是一个只有条件满足的时候才会创建 DOM ，一个是只有在条件满足的时候才会显示 DOM 也就是一开始也会跟着创建。但是你可能不知道， ng-if 会产生新的作用域， ng-repeat 和 ng-switch 和 ng-include 也是如此。这时候内部如果使用外部的变量，第一次的时候会正常显示，因为 Angular 的继承是原型链继承，如果子类没有这个属性就会去尝试继承父类的属性， Angular 会拿父类的属性来创建新的属于这个子类的属性，而这个属性将不再和外层的父类的属性挂钩，如果不注意很可能就会在这里踩坑。 读子类的属性时，子类有这个属性（hasOwnProperty）的时候则读子类自己的，子类没有的时候读父类的，不管子类有没有这个属性，在子类上都不会有新属性被创建。 写子类的属性时，如果子类有这个属性（hasOwnProperty）则写子类的，子类没有的话就会在子类上新建一个同名的新属性，而父类继承过来的属性被隐藏。 ​ 关于原型链继承这个可以参考此处JavaScript Prototypal Inheritance，或者[译文] 深入浅出 AngularJS 作用域 ​ 使用上述的 ng-if , ng-repeat , ng-switch , ng-include 都会自己创建一级作用域，这点一定要注意。如果想要和父类的属性挂钩，可以使用 $parent 。 ​ 但是，还没玩，也许这些你都知道。但是除了这些指令之外， textarea 也会自己创建一级作用域。所以你可能会发现你在 textarea 写的内容获取不到，但是却发现 textarea 总能取到第一次分配的初值。比如 1&lt;textarea ng-model=\"content\", name=\"content\" class=\"form-control\" row=\"3\"&gt;&lt;/textarea&gt; ​ 我们在控制器里面定义 1$scope.content = \"测试\" ​ 然后我们就会看到 textarea 的初值为”测试”，但是当我们更改其中的内容之后， $scope.content 却一直保持不变。 ​ 同样，我们可以使用 $parent 的方式来解决这个问题。 1&lt;textarea ng-model=\"$parent.content\", name=\"content\" class=\"form-control\" row=\"3\"&gt;&lt;/textarea&gt; ​ 那如果不想使用 $parent 的话，可以给 content 分配一个类名，比如 1&lt;textarea ng-model=\"comment.content\", name=\"content\" class=\"form-control\" row=\"3\"&gt;&lt;/textarea&gt; ​ 这样我们就可以通过 $scope.comment.content 来取值。 Angular track by​ 在使用 Angular 的 ng-repeat 迭代数组时，有时候会出现 Duplicates in a repeater are not allowed 的提示。 ​ track by 是用来建立 $watchCollection 和 DOM 之间的联系。建议自己加上 track by 后面带的值可以自己写，但要确保每个 ngRepeat 的值唯一，比如可以写 track by $index 。 ​ 之所以要这么做，是因为，如果不使用 track by ，那么每个 ng-repeat 都会添加一个 $$hashkey 来对的 DOM 进行跟踪，这样会导致不能存在相同的 DOM ，使用 track by 的意义是避免不必要的渲染。 ​ 官网API有进行详细的说明，不过我看了之后还是感觉不太明白，等我了解清楚了再来补充下。AngularJS: API: ngRepeat If you are working with objects that have an identifier property, you should track by the identifier instead of the whole object. Should you reload your data later, ngRepeat will not have to rebuild the DOM elements for items it has already rendered, even if the JavaScript objects in the collection have been substituted for new ones. For large collections, this significantly improves rendering performance. If you don’t have a unique identifier, track by $index can also provide a performance boost. Angular拦截器​ Angular 拦截器是 Angular 的一个强大功能，不过暂时没有怎么去研究，简单说下我的一些使用。","text":"这学期基本都是在学习和使用 Angular ，这篇文章主要是想介绍几个 Angular 需要注意或者了解的地方。 Angular作用域​ 也许你知道 ng-if 和 ng-show 的区别是一个只有条件满足的时候才会创建 DOM ，一个是只有在条件满足的时候才会显示 DOM 也就是一开始也会跟着创建。但是你可能不知道， ng-if 会产生新的作用域， ng-repeat 和 ng-switch 和 ng-include 也是如此。这时候内部如果使用外部的变量，第一次的时候会正常显示，因为 Angular 的继承是原型链继承，如果子类没有这个属性就会去尝试继承父类的属性， Angular 会拿父类的属性来创建新的属于这个子类的属性，而这个属性将不再和外层的父类的属性挂钩，如果不注意很可能就会在这里踩坑。 读子类的属性时，子类有这个属性（hasOwnProperty）的时候则读子类自己的，子类没有的时候读父类的，不管子类有没有这个属性，在子类上都不会有新属性被创建。 写子类的属性时，如果子类有这个属性（hasOwnProperty）则写子类的，子类没有的话就会在子类上新建一个同名的新属性，而父类继承过来的属性被隐藏。 ​ 关于原型链继承这个可以参考此处JavaScript Prototypal Inheritance，或者[译文] 深入浅出 AngularJS 作用域 ​ 使用上述的 ng-if , ng-repeat , ng-switch , ng-include 都会自己创建一级作用域，这点一定要注意。如果想要和父类的属性挂钩，可以使用 $parent 。 ​ 但是，还没玩，也许这些你都知道。但是除了这些指令之外， textarea 也会自己创建一级作用域。所以你可能会发现你在 textarea 写的内容获取不到，但是却发现 textarea 总能取到第一次分配的初值。比如 1&lt;textarea ng-model=\"content\", name=\"content\" class=\"form-control\" row=\"3\"&gt;&lt;/textarea&gt; ​ 我们在控制器里面定义 1$scope.content = \"测试\" ​ 然后我们就会看到 textarea 的初值为”测试”，但是当我们更改其中的内容之后， $scope.content 却一直保持不变。 ​ 同样，我们可以使用 $parent 的方式来解决这个问题。 1&lt;textarea ng-model=\"$parent.content\", name=\"content\" class=\"form-control\" row=\"3\"&gt;&lt;/textarea&gt; ​ 那如果不想使用 $parent 的话，可以给 content 分配一个类名，比如 1&lt;textarea ng-model=\"comment.content\", name=\"content\" class=\"form-control\" row=\"3\"&gt;&lt;/textarea&gt; ​ 这样我们就可以通过 $scope.comment.content 来取值。 Angular track by​ 在使用 Angular 的 ng-repeat 迭代数组时，有时候会出现 Duplicates in a repeater are not allowed 的提示。 ​ track by 是用来建立 $watchCollection 和 DOM 之间的联系。建议自己加上 track by 后面带的值可以自己写，但要确保每个 ngRepeat 的值唯一，比如可以写 track by $index 。 ​ 之所以要这么做，是因为，如果不使用 track by ，那么每个 ng-repeat 都会添加一个 $$hashkey 来对的 DOM 进行跟踪，这样会导致不能存在相同的 DOM ，使用 track by 的意义是避免不必要的渲染。 ​ 官网API有进行详细的说明，不过我看了之后还是感觉不太明白，等我了解清楚了再来补充下。AngularJS: API: ngRepeat If you are working with objects that have an identifier property, you should track by the identifier instead of the whole object. Should you reload your data later, ngRepeat will not have to rebuild the DOM elements for items it has already rendered, even if the JavaScript objects in the collection have been substituted for new ones. For large collections, this significantly improves rendering performance. If you don’t have a unique identifier, track by $index can also provide a performance boost. Angular拦截器​ Angular 拦截器是 Angular 的一个强大功能，不过暂时没有怎么去研究，简单说下我的一些使用。 判断请求是否成功 1234567891011$httpProvider.defaults.transformResponse.push((response) =&gt; &#123; if(typeof(response.data) != undefined &amp;&amp; response.status == 'success') &#123; response = response.data; return response; &#125; if(response.status == 'error') &#123; console.log(\"Err: \" + response.message); return; &#125; return response;&#125;); 应该都能看懂，就不过多解释了。需要说明你的是，我们只需要一次配置，即可在整个项目中适用，特别方便。​ timestampMarker 123456789101112app.factory('timestampMarker', [() =&gt; &#123; let timestampMarker = &#123; request: (config) = &gt; &#123; config.requestTimestamp = new Date().getTime(); return config; &#125;, response: (response) = &gt; &#123; response.config.responseTimestamp = new Date().getTime(); return response; &#125; &#125;;&#125;]); 这是给每个请求加上时间戳来防止浏览器缓存。 tokenInjector 123456789101112131415161718192021app.factory('tokenInjector', ['$injector', '$q', ($injector, $q) =&gt; &#123; let tokenInjector = &#123; request: (config) =&gt; &#123; let url = host + '/auth_verify'; let deferred = $q.defer(); let http = $injector.get('$http'); if(config.url === url) &#123; return config; &#125; if(sessionStorage.verify === 'true') &#123; let timestamp = new Date().getTime() / 1000; if(timestamp - sessionStorage.createdtime &gt;= 7000) &#123; sessionStorage.verify = false; &#125; config.headers['token'] = sessionStorage.token; config.headers['userid'] = sessionStorage.user_id; deferred.resolve(config); &#125; &#125; &#125;&#125;]) ​上面是我从我的项目中截取的代码，作用是每次请求时，如果已经验证过，判断 token 创建时间和当前时间以判断 token 是否过期，如未过期，将 token 和 userid 加到请求的 headers 中。如果没有验证或者已经超时，则要去获取新的 token ，这里没有把代码写上。 ​通过这三个例子，我想已经很明显的展示了 Angular 拦截器的强大之处。一次使用，终身受益，爽。","categories":[{"name":"Angular","slug":"Angular","permalink":"https://ruiming.github.io/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"https://ruiming.github.io/tags/Angular/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/tags/JavaScript/"},{"name":"Front end","slug":"Front-end","permalink":"https://ruiming.github.io/tags/Front-end/"}]},{"title":"谈谈前端自动构建工具 Gulp","slug":"谈谈前端自动构建工具gulp","date":"2016-06-18T12:18:17.000Z","updated":"2016-08-04T08:33:38.000Z","comments":true,"path":"2016/06/18/谈谈前端自动构建工具gulp/","link":"","permalink":"https://ruiming.github.io/2016/06/18/谈谈前端自动构建工具gulp/","excerpt":"​类似 Gulp 这样的工具可以说是前端利器，基本前端开发都离不开他，类似的解决方案还有 Grunt 和 Webpack 等，不过我用 Gulp 比较多一些，所以我只能谈谈 Gulp 了。 ​Gulp 上面优秀的插件特别多，我使用的有这些： 1234567891011121314import gulp from 'gulp'import babel from 'gulp-babel'import uglify from 'gulp-uglify'import ngAnnotate from 'gulp-ng-annotate'import concat from 'gulp-concat'import cleanCSS from 'gulp-clean-css'import imagemin from 'gulp-imagemin'import minifyHtml from 'gulp-minify-html'import ngTemplate from 'gulp-ng-template'import plumber from 'gulp-plumber'import sass from 'gulp-sass'import usemin from 'gulp-usemin'import runSequence from 'gulp-run-sequence'import eslint from 'gulp-eslint' gulp-uglify 对 JavaScript 进行压缩的插件，可以有效减少 JavaScript 的文件大小。 gulp-ng-annotate 对 Angular 的代码进行转换，因为使用上面的 gulp-uglify 对 Angular 的代码进行压缩时会破坏 Angular 文件的依赖注入功能，导致无法正常工作，这个基本上是 Angular 开发必备的了。 gulp-concat 文件合并，前端合并文件以减少请求是非常重要的优化技巧。 gulp-clean-css 字如其名，对css 进行合并压缩。 gulp-imagemin 对图片进行压缩。 gulp-minify-html 对html文件进行压缩。 gulp-ng-template 这个也是 Angular 里面比较响当当的一个插件了，他的作用是将 Angular 模板存到 templateCache ，可以提升模板加载速度。 gulp-plumber 这个貌似也是 Gulp 必不可少的插件之一了，可以避免 Gulp 出错导致整个进程崩掉。 gulp-sass 编译 sass 代码为 css，非常方便。 gulp-run-sequence 可以让 Gulp 的任务顺序执行，有些时候我们希望 Gulp 执行了一些任务完成之后才来执行下一个任务，这时候这个插件就派上用场了。 gulp-usemin 这个是用来从工作环境到生产环境进行部署的工具。 gulp-eslint eslint 代码检查。","text":"​类似 Gulp 这样的工具可以说是前端利器，基本前端开发都离不开他，类似的解决方案还有 Grunt 和 Webpack 等，不过我用 Gulp 比较多一些，所以我只能谈谈 Gulp 了。 ​Gulp 上面优秀的插件特别多，我使用的有这些： 1234567891011121314import gulp from 'gulp'import babel from 'gulp-babel'import uglify from 'gulp-uglify'import ngAnnotate from 'gulp-ng-annotate'import concat from 'gulp-concat'import cleanCSS from 'gulp-clean-css'import imagemin from 'gulp-imagemin'import minifyHtml from 'gulp-minify-html'import ngTemplate from 'gulp-ng-template'import plumber from 'gulp-plumber'import sass from 'gulp-sass'import usemin from 'gulp-usemin'import runSequence from 'gulp-run-sequence'import eslint from 'gulp-eslint' gulp-uglify 对 JavaScript 进行压缩的插件，可以有效减少 JavaScript 的文件大小。 gulp-ng-annotate 对 Angular 的代码进行转换，因为使用上面的 gulp-uglify 对 Angular 的代码进行压缩时会破坏 Angular 文件的依赖注入功能，导致无法正常工作，这个基本上是 Angular 开发必备的了。 gulp-concat 文件合并，前端合并文件以减少请求是非常重要的优化技巧。 gulp-clean-css 字如其名，对css 进行合并压缩。 gulp-imagemin 对图片进行压缩。 gulp-minify-html 对html文件进行压缩。 gulp-ng-template 这个也是 Angular 里面比较响当当的一个插件了，他的作用是将 Angular 模板存到 templateCache ，可以提升模板加载速度。 gulp-plumber 这个貌似也是 Gulp 必不可少的插件之一了，可以避免 Gulp 出错导致整个进程崩掉。 gulp-sass 编译 sass 代码为 css，非常方便。 gulp-run-sequence 可以让 Gulp 的任务顺序执行，有些时候我们希望 Gulp 执行了一些任务完成之后才来执行下一个任务，这时候这个插件就派上用场了。 gulp-usemin 这个是用来从工作环境到生产环境进行部署的工具。 gulp-eslint eslint 代码检查。 ​ 上面的这些插件都是我在一个项目中使用到的，通过这些工具实现了前端的自动化开发，我在项目中有开发环境和生产环境之分。 ​ 在 Gulp 中，我有一段在开发环境下执行的任务 1gulp.task('default', ['css', 'js', 'angular', 'img', 'templates:dist', 'sass', 'fonts']) ​ 这段代码帮我做了 css：进行 css 文件(这些文件是第三方 css 文件如 bootstrap)的合并。 javascript：进行 JavaScript 文件的合并，这是将所有我写的 Angular 文件进行合并，但不进行压缩以方便我调试。 angular：将项目所有的 JavaScript 依赖如 Angular, ui-router, jQuery 等文件进行压缩合并。 img：将图片进行压缩和迁移，这些图片压缩后放入生产环境对应的文件夹中。 templates:dist：对 Angular 的视图进行合并，使用了上述的 gulp-ng-template 插件，合并后为一个新的 JavaScript 文件。 sass：将我写的 scss 代码进行编译。 fonts：移动相应的字体文件到生产环境中。 ​开发环境下我们需要自动构建，也需要便于调试，所以我用上面这样的方式来处理，并且开启了 watch 监视变化，在有更改发生时自动构建。当我处理完全部工作后需要 push 到服务器上面时，会执行 gulp product 即下面的 task。 12345678910111213141516171819gulp.task('product', function(cb)&#123; runSequence('together', 'move', cb)&#125;);gulp.task('together', function(cb)&#123; gulp.src('index.html') .pipe(plumber()) .pipe(usemin(&#123; cssProduct: ['concat'], jsProduct: [ngAnnotate(),'concat',uglify()] &#125;)) .pipe(gulp.dest('backend/app/')) .on('end',cb);&#125;);gulp.task('move', function()&#123; return gulp.src('backend/app/index.html') .pipe(gulp.dest('backend/app/templates/'));&#125;); ​ 这里使用了上述说的 ng-run-sequence 插件，这里会在执行完 together 的任务后才开始执行 move 的任务。这里主要使用的插件是 gulp-usemin，我用它来做了这些事情，为了方便说明，我贴下代码。需要先说明的是，我在项目中一共有3个 index.html 文件。 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\" ng-app=\"index\"&gt;&lt;head&gt; &lt;!-- build:cssProduct /static/css/app.min.css --&gt; &lt;link rel=\"stylesheet\" href=\"src/css/app.min.css\"&gt; &lt;link rel=\"stylesheet\" href=\"src/css/bookist.css\"&gt; &lt;!-- endbuild --&gt;&lt;body&gt; ... &lt;!-- build:jsProduct /static/js/app.min.js --&gt; &lt;script src=\"src/js/dependence.min.js\"&gt;&lt;/script&gt; &lt;script src=\"src/js/app.js\"&gt;&lt;/script&gt; &lt;script src=\"src/js/templates.js\"&gt;&lt;/script&gt; &lt;!-- endbuild --&gt; &lt;!-- build:remove --&gt; &lt;!-- 这段注释会被移除 --&gt; &lt;!-- endbuild--&gt;&lt;/body&gt;&lt;/head&gt; ​ 省去了没有用的代码，这里需要你对 ng-usemin 有一定的了解。这个 index.html 是我在开发环境下使用的，使用了我开发环境的 task 生成文件，我在上面有补充说明了。 ​ 所以，在部署生产环境时执行这段 task 的意义是，将开发环境下的代码再做进一步的合并和压缩。ng-usemin 这个插件会帮我们处理这个 index.html 文件，最后会在我们指定的目录下部署好这些东西。但是因为后端处理 index.html 的路径原因，我还要对 index.html 做一次移动，所以有了第三个 index.html。 ​ 最终生成的 index 和相应的资源位置如下 123456789&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\" ng-app=\"index\"&gt;&lt;head&gt; &lt;link rel=\"stylesheet\" href=\"/static/css/app.min.css\"/&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=\"/static/js/app.min.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/categories/JavaScript/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"https://ruiming.github.io/tags/Angular/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://ruiming.github.io/tags/JavaScript/"},{"name":"Front end","slug":"Front-end","permalink":"https://ruiming.github.io/tags/Front-end/"},{"name":"Gulp","slug":"Gulp","permalink":"https://ruiming.github.io/tags/Gulp/"}]}]}